<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Chisel-1.9.1逆向分析 | Daily Study</title><meta name="author" content="C0KE"><meta name="copyright" content="C0KE"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Chisel-1.9.1逆向分析前言为了写针对Chisel的内网穿透工具的流量报警，这里对该工具进行流量分析和逆向分析 逆向解析命令行123456version :&#x3D; flag.Bool(&quot;version&quot;, false, &quot;&quot;)v :&#x3D; flag.Bool(&quot;v&quot;, false, &quot;&quot;)flag.Bool(&amp;quot">
<meta property="og:type" content="article">
<meta property="og:title" content="Chisel-1.9.1逆向分析">
<meta property="og:url" content="http://example.com/2024/07/10/Chisel-1.9.1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="Daily Study">
<meta property="og:description" content="Chisel-1.9.1逆向分析前言为了写针对Chisel的内网穿透工具的流量报警，这里对该工具进行流量分析和逆向分析 逆向解析命令行123456version :&#x3D; flag.Bool(&quot;version&quot;, false, &quot;&quot;)v :&#x3D; flag.Bool(&quot;v&quot;, false, &quot;&quot;)flag.Bool(&amp;quot">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/sealed%E7%99%BD%E5%A4%A9.png">
<meta property="article:published_time" content="2024-07-10T04:04:54.179Z">
<meta property="article:modified_time" content="2024-07-10T07:51:03.135Z">
<meta property="article:author" content="C0KE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/sealed%E7%99%BD%E5%A4%A9.png"><link rel="shortcut icon" href="/img/fa.jpg"><link rel="canonical" href="http://example.com/2024/07/10/Chisel-1.9.1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Chisel-1.9.1逆向分析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-10 15:51:03'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/73c31ad1881611ebb6edd017c2d2eca2.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">370</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">53</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/sealed%E7%99%BD%E5%A4%A9.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Daily Study"><span class="site-name">Daily Study</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Chisel-1.9.1逆向分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-10T04:04:54.179Z" title="发表于 2024-07-10 12:04:54">2024-07-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-10T07:51:03.135Z" title="更新于 2024-07-10 15:51:03">2024-07-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/RE%E7%AC%94%E8%AE%B0/">RE笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Chisel-1.9.1逆向分析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Chisel-1-9-1逆向分析"><a href="#Chisel-1-9-1逆向分析" class="headerlink" title="Chisel-1.9.1逆向分析"></a>Chisel-1.9.1逆向分析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了写针对Chisel的内网穿透工具的流量报警，这里对该工具进行流量分析和逆向分析</p>
<h2 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h2><h3 id="解析命令行"><a href="#解析命令行" class="headerlink" title="解析命令行"></a>解析命令行</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">version := flag.Bool(<span class="string">&quot;version&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">v := flag.Bool(<span class="string">&quot;v&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">flag.Bool(<span class="string">&quot;help&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">flag.Bool(<span class="string">&quot;h&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">flag.Usage = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">flag.Parse()</span><br></pre></td></tr></table></figure>

<p>这段代码用于处理命<code>flag</code>包的作用是帮助Go程序处理命令行参数和选项。</p>
<p><code>flag</code>包的作用是帮助Go程序处理命令行参数和选项。它允许程序员定义各种命令行标志，然后在运行程序时根据传递的参数来设置这些标志的值。这有助于使命令行工具更加灵活，并且能够接受用户提供的参数来控制程序的行为。</p>
<p>一旦使用<code>flag.Parse()</code>解析了命令行参数，程序就可以根据这些参数来执行不同的逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">args := flag.Args()</span><br></pre></td></tr></table></figure>

<p>这段代码用于获取在命令行参数之后的非标志（non-flag）参数列表。在Go的<code>flag</code>包中，命令行参数通常分为标志（flags）和非标志参数。</p>
<ul>
<li>标志（flags）是那些以<code>-</code>或<code>--</code>开头的参数，通常用于传递配置选项和参数值。例如，<code>-version</code>或<code>--verbose</code>。</li>
<li>非标志参数是那些没有标志前缀的参数，它们通常用于传递操作对象或其他非配置性参数。这些参数按照它们在命令行中出现的顺序保存在<code>flag.Args()</code>返回的字符串切片中。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">subcmd := <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args) &gt; <span class="number">0</span> &#123;</span><br><span class="line">   subcmd = args[<span class="number">0</span>]</span><br><span class="line">   args = args[<span class="number">1</span>:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> subcmd &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;server&quot;</span>:</span><br><span class="line">   server(args)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;client&quot;</span>:</span><br><span class="line">   client(args)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">   fmt.Print(help)</span><br><span class="line">   os.Exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>这段代码首先对第一个参数进行判断是否为<code>server</code>或者<code>client</code>，如果是则将后面的命令行参数当成参数传递给对应的函数，否则打印<code>help</code>字符</p>
<h2 id="server函数"><a href="#server函数" class="headerlink" title="server函数"></a>server函数</h2><h3 id="解析命令行-1"><a href="#解析命令行-1" class="headerlink" title="解析命令行"></a>解析命令行</h3><p>首先解析传入的参数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">flags := flag.NewFlagSet(<span class="string">&quot;server&quot;</span>, flag.ContinueOnError)</span><br><span class="line"></span><br><span class="line">config := &amp;chserver.Config&#123;&#125;</span><br><span class="line">flags.StringVar(&amp;config.KeySeed, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">flags.StringVar(&amp;config.KeyFile, <span class="string">&quot;keyfile&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">flags.StringVar(&amp;config.AuthFile, <span class="string">&quot;authfile&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">flags.StringVar(&amp;config.Auth, <span class="string">&quot;auth&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">flags.DurationVar(&amp;config.KeepAlive, <span class="string">&quot;keepalive&quot;</span>, <span class="number">25</span>*time.Second, <span class="string">&quot;&quot;</span>)</span><br><span class="line">flags.StringVar(&amp;config.Proxy, <span class="string">&quot;proxy&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">flags.StringVar(&amp;config.Proxy, <span class="string">&quot;backend&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">flags.BoolVar(&amp;config.Socks5, <span class="string">&quot;socks5&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">flags.BoolVar(&amp;config.Reverse, <span class="string">&quot;reverse&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">flags.StringVar(&amp;config.TLS.Key, <span class="string">&quot;tls-key&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">flags.StringVar(&amp;config.TLS.Cert, <span class="string">&quot;tls-cert&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">flags.Var(multiFlag&#123;&amp;config.TLS.Domains&#125;, <span class="string">&quot;tls-domain&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">flags.StringVar(&amp;config.TLS.CA, <span class="string">&quot;tls-ca&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">host := flags.String(<span class="string">&quot;host&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">p := flags.String(<span class="string">&quot;p&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">port := flags.String(<span class="string">&quot;port&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">pid := flags.Bool(<span class="string">&quot;pid&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">verbose := flags.Bool(<span class="string">&quot;v&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">keyGen := flags.String(<span class="string">&quot;keygen&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">flags.Usage = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Print(serverHelp)</span><br><span class="line">    os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">flags.Parse(args)</span><br></pre></td></tr></table></figure>

<p>将结构体里面的一些变量与命令行参数进行连接，和本地的一些局部变量进行连接，最后通过<code>flags.parse(arfs)</code>进行解析，Config结构体定义了服务器的一些设置，结构体如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Config is the configuration for the chisel service</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeySeed   <span class="type">string</span></span><br><span class="line">    KeyFile   <span class="type">string</span></span><br><span class="line">    AuthFile  <span class="type">string</span></span><br><span class="line">    Auth      <span class="type">string</span></span><br><span class="line">    Proxy     <span class="type">string</span></span><br><span class="line">    Socks5    <span class="type">bool</span></span><br><span class="line">    Reverse   <span class="type">bool</span></span><br><span class="line">    KeepAlive time.Duration</span><br><span class="line">    TLS       TLSConfig</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="密钥初始化和解析其他选项"><a href="#密钥初始化和解析其他选项" class="headerlink" title="密钥初始化和解析其他选项"></a>密钥初始化和解析其他选项</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> *keyGen != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := ccrypto.GenerateKeyFile(*keyGen, config.KeySeed); err != <span class="literal">nil</span> &#123;</span><br><span class="line">       log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> config.KeySeed != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    log.Print(<span class="string">&quot;Option `--key` is deprecated and will be removed in a future version of chisel.&quot;</span>)</span><br><span class="line">    log.Print(<span class="string">&quot;Please use `chisel server --keygen /file/path`, followed by `chisel server --keyfile /file/path` to specify the SSH private key&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的作用是检查用户是否请求生成密钥文件，如果是，则生成密钥文件并退出程序。这通常用于初始化或更新程序所需的密钥文件。</p>
<p>更据后面的输出消息可以知道选项 <code>--key</code> 已弃用，并将在 chisel 的未来版本中删除。请使用<code>chisel server --keygen /file/path</code>，后跟<code>chisel server --keyfile /file/path</code>指定SSH私钥</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> *host == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    *host = os.Getenv(<span class="string">&quot;HOST&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> *host == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    *host = <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> *port == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    *port = *p</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> *port == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    *port = os.Getenv(<span class="string">&quot;PORT&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> *port == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    *port = <span class="string">&quot;8080&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置端口和IP，如果不设置，则默认为0.0.0.0:8080。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> config.KeyFile == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    config.KeyFile = settings.Env(<span class="string">&quot;KEY_FILE&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> config.KeySeed == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    config.KeySeed = settings.Env(<span class="string">&quot;KEY&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">s, err := chserver.NewServer(config)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结起来，这段代码的目的是在用户没有在命令行参数中指定密钥文件路径 (<code>KeyFile</code>) 或密钥的种子 (<code>KeySeed</code>) 的情况下，尝试从环境变量中获取这些值作为默认值，以便程序在没有显式配置这些参数的情况下仍然能够正常运行。如果环境变量中也没有定义这些值，那么这些字段仍然会保持为空。</p>
<p>然后调用<code>NewServer函数</code>去根据<code>config结构体</code>初始化服务器，最后调用<code>StartContext</code>函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generatePidFile</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pid := []<span class="type">byte</span>(strconv.Itoa(os.Getpid()))</span><br><span class="line">    <span class="keyword">if</span> err := ioutil.WriteFile(<span class="string">&quot;chisel.pid&quot;</span>, pid, <span class="number">0644</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">       log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-------------------------------*/</span></span><br><span class="line">	s.Debug = *verbose</span><br><span class="line">	<span class="keyword">if</span> *pid &#123;</span><br><span class="line">		generatePidFile()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> cos.GoStats()</span><br><span class="line">	ctx := cos.InterruptContext()</span><br><span class="line">	<span class="keyword">if</span> err := s.StartContext(ctx, *host, *port); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := s.Wait(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说，这段代码的目的是启动Chisel服务器并管理它的运行。它可以处理调试模式、生成PID文件、收集性能统计信息以及处理服务器的启动和关闭。</p>
<h3 id="NewServer函数"><a href="#NewServer函数" class="headerlink" title="NewServer函数"></a>NewServer函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server := &amp;Server&#123;</span><br><span class="line">    config:     c,</span><br><span class="line">    httpServer: cnet.NewHTTPServer(),</span><br><span class="line">    Logger:     cio.NewLogger(<span class="string">&quot;server&quot;</span>),</span><br><span class="line">    sessions:   settings.NewUsers(),</span><br><span class="line">&#125;</span><br><span class="line">server.Info = <span class="literal">true</span></span><br><span class="line">server.users = settings.NewUserIndex(server.Logger)</span><br><span class="line"><span class="keyword">if</span> c.AuthFile != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := server.users.LoadUsers(c.AuthFile); err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> c.Auth != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    u := &amp;settings.User&#123;Addrs: []*regexp.Regexp&#123;settings.UserAllowAll&#125;&#125;</span><br><span class="line">    u.Name, u.Pass = settings.ParseAuth(c.Auth)</span><br><span class="line">    <span class="keyword">if</span> u.Name != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">       server.users.AddUser(u)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说，这段代码用于初始化Chisel服务器的配置，包括日志记录、用户管理和身份验证配置。它确保服务器在启动时具有必要的配置信息，以便能够接受连接并验证用户身份。</p>
<p>首先判断是否有<code>AuthFile</code>，<code>Auth</code>这两个参数，如果有则解析对应的Authfile文件或者Auth所携带的<code>name</code>和<code>pass</code>。</p>
<pre><code>server := &amp;Server&#123;
    config:     c,
    httpServer: cnet.NewHTTPServer(),
    Logger:     cio.NewLogger(&quot;server&quot;),
    sessions:   settings.NewUsers(),
&#125;
</code></pre>
<p>这段代码表示实现一个server服务器实例，然后对对应服务进行初始化</p>
<ol>
<li><code>server := &amp;Server&#123;...&#125;</code>：创建一个名为 <code>server</code> 的 <code>Server</code> 结构体实例。这是Chisel服务器的主要配置和运行对象。</li>
<li><code>server.config = c</code>：将传递给函数的配置 <code>c</code> 赋值给 <code>server</code> 结构体的 <code>config</code> 字段，以便后续使用。</li>
<li><code>server.httpServer = cnet.NewHTTPServer()</code>：创建一个新的 HTTP 服务器实例，并将其分配给 <code>server</code> 结构体的 <code>httpServer</code> 字段。这将用于处理HTTP连接。</li>
<li><code>server.Logger = cio.NewLogger(&quot;server&quot;)</code>：创建一个名为 “server” 的日志记录器，并将其分配给 <code>server</code> 结构体的 <code>Logger</code> 字段。这用于记录服务器的日志消息。</li>
<li><code>server.sessions = settings.NewUsers()</code>：创建一个新的用户集合实例，并将其分配给 <code>server</code> 结构体的 <code>sessions</code> 字段。这用于跟踪与服务器建立的会话。</li>
<li><code>server.Info = true</code>：设置 <code>server</code> 结构体的 <code>Info</code> 字段为 <code>true</code>，表示服务器应该记录详细的信息日志。</li>
<li><code>server.users = settings.NewUserIndex(server.Logger)</code>：创建一个新的用户索引实例，并将其分配给 <code>server</code> 结构体的 <code>users</code> 字段。这用于管理服务器允许连接的用户。</li>
</ol>
<h4 id="配置ssh密钥"><a href="#配置ssh密钥" class="headerlink" title="配置ssh密钥"></a>配置ssh密钥</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pemBytes []<span class="type">byte</span></span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line"><span class="keyword">if</span> c.KeyFile != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> key []<span class="type">byte</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ccrypto.IsChiselKey([]<span class="type">byte</span>(c.KeyFile)) &#123;</span><br><span class="line">       key = []<span class="type">byte</span>(c.KeyFile)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       key, err = os.ReadFile(c.KeyFile)</span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          log.Fatalf(<span class="string">&quot;Failed to read key file %s&quot;</span>, c.KeyFile)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pemBytes = key</span><br><span class="line">    <span class="keyword">if</span> ccrypto.IsChiselKey(key) &#123;</span><br><span class="line">       pemBytes, err = ccrypto.ChiselKey2PEM(key)</span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          log.Fatalf(<span class="string">&quot;Invalid key %s&quot;</span>, <span class="type">string</span>(key))</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//generate private key (optionally using seed)</span></span><br><span class="line">    pemBytes, err = ccrypto.Seed2PEM(c.KeySeed)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       log.Fatal(<span class="string">&quot;Failed to generate key&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的主要目的是获取Chisel服务器所需的私钥，并确保它以PEM编码形式可用。如果密钥文件已经包含了PEM编码的密钥，它会直接使用，否则会根据种子生成新的私钥并进行PEM编码。无论哪种情况，最终的私钥都以PEM编码形式存储在 <code>pemBytes</code> 变量中，供服务器使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//convert into ssh.PrivateKey</span></span><br><span class="line">private, err := ssh.ParsePrivateKey(pemBytes)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">&quot;Failed to parse key&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fingerprint this key，计算 SSH 公钥的 SHA256 哈希值</span></span><br><span class="line">server.fingerprint = ccrypto.FingerprintKey(private.PublicKey())</span><br><span class="line"><span class="comment">//create ssh config</span></span><br><span class="line">server.sshConfig = &amp;ssh.ServerConfig&#123;</span><br><span class="line">    ServerVersion:    <span class="string">&quot;SSH-&quot;</span> + chshare.ProtocolVersion + <span class="string">&quot;-server&quot;</span>,</span><br><span class="line">    PasswordCallback: server.authUser,</span><br><span class="line">&#125;</span><br><span class="line">server.sshConfig.AddHostKey(private)</span><br><span class="line"><span class="comment">//setup reverse proxy</span></span><br><span class="line"><span class="keyword">if</span> c.Proxy != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    u, err := url.Parse(c.Proxy)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> u.Host == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>, server.Errorf(<span class="string">&quot;Missing protocol (%s)&quot;</span>, u)</span><br><span class="line">    &#125;</span><br><span class="line">    server.reverseProxy = httputil.NewSingleHostReverseProxy(u)</span><br><span class="line">    <span class="comment">//always use proxy host</span></span><br><span class="line">    server.reverseProxy.Director = <span class="function"><span class="keyword">func</span><span class="params">(r *http.Request)</span></span> &#123;</span><br><span class="line">       <span class="comment">//enforce origin, keep path</span></span><br><span class="line">       r.URL.Scheme = u.Scheme</span><br><span class="line">       r.URL.Host = u.Host</span><br><span class="line">       r.Host = u.Host</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之，这段代码负责配置Chisel服务器的SSH密钥和（如果已配置）反向代理。密钥用于SSH连接的身份验证，而反向代理用于转发传入的连接到其他主机。</p>
<ol>
<li><code>private, err := ssh.ParsePrivateKey(pemBytes)</code>：将之前生成的PEM编码形式的密钥 <code>pemBytes</code> 解析为SSH私钥。如果解析失败，将记录错误并终止程序。</li>
<li><code>server.fingerprint = ccrypto.FingerprintKey(private.PublicKey())</code>：计算SSH密钥的指纹（fingerprint）并将其存储在服务器结构体的 <code>fingerprint</code> 字段中。指纹通常用于验证密钥的唯一性。</li>
<li><code>server.sshConfig = &amp;ssh.ServerConfig&#123; ... &#125;</code>：创建SSH服务器配置，其中包括以下设置：<ul>
<li><code>ServerVersion</code>：指定SSH服务器的版本信息，这里使用Chisel的协议版本。</li>
<li><code>PasswordCallback</code>：指定一个回调函数 <code>server.authUser</code>，用于验证SSH用户的用户名和密码组合。</li>
<li><code>AddHostKey(private)</code>：将之前解析的私钥 <code>private</code> 添加为SSH服务器的主机密钥，以用于SSH连接。</li>
</ul>
</li>
<li><code>if c.Proxy != &quot;&quot; &#123; ... &#125;</code>：检查是否已配置代理。如果已配置代理，执行以下操作：<ul>
<li><code>u, err := url.Parse(c.Proxy)</code>：解析代理URL，将其存储在 <code>u</code> 变量中。如果解析失败，将记录错误并终止程序。</li>
<li><code>if u.Host == &quot;&quot; &#123; ... &#125;</code>：检查代理URL是否包含主机信息，如果不包含，将返回一个错误消息。</li>
<li><code>server.reverseProxy = httputil.NewSingleHostReverseProxy(u)</code>：创建一个反向代理，将传入的HTTP请求代理到指定的URL <code>u</code>。</li>
<li><code>server.reverseProxy.Director</code>：配置反向代理的Director函数，用于处理传入请求。此函数将强制设置请求的URL方案和主机，以确保请求正确代理到目标主机。</li>
</ul>
</li>
</ol>
<h4 id="user-password-callback函数"><a href="#user-password-callback函数" class="headerlink" title="user-password callback函数"></a>user-password callback函数</h4><p>上面出现了校验user和pass的函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> authUser(c ssh.ConnMetadata, password []<span class="type">byte</span>) (*ssh.Permissions, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// check if user authentication is enabled and if not, allow all</span></span><br><span class="line">    <span class="keyword">if</span> s.users.Len() == <span class="number">0</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check the user exists and has matching password</span></span><br><span class="line">    n := c.User()</span><br><span class="line">    user, found := s.users.Get(n)</span><br><span class="line">    <span class="keyword">if</span> !found || user.Pass != <span class="type">string</span>(password) &#123;</span><br><span class="line">       s.Debugf(<span class="string">&quot;Login failed for user: %s&quot;</span>, n)</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;Invalid authentication for username: %s&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// insert the user session map</span></span><br><span class="line">    <span class="comment">// TODO this should probably have a lock on it given the map isn&#x27;t thread-safe</span></span><br><span class="line">    s.sessions.Set(<span class="type">string</span>(c.SessionID()), user)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的作用是验证SSH用户的身份和密码组合。如果用户列表为空，表示用户认证未启用，允许所有连接。否则，它会检查用户名和密码是否匹配，并在成功认证时将用户信息存储在会话映射中。</p>
<p>果用户成功认证，将用户信息插入到用户会话映射中。这个映射用于跟踪用户会话。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//print when reverse tunnelling is enabled</span></span><br><span class="line"><span class="keyword">if</span> c.Reverse &#123;</span><br><span class="line">    server.Infof(<span class="string">&quot;Reverse tunnelling enabled&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有Reverse这个选项，直接打印就行</p>
<h3 id="StartContext函数"><a href="#StartContext函数" class="headerlink" title="StartContext函数"></a>StartContext函数</h3><p>接下来看<code>startContext</code>函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">	ctx := cos.InterruptContext()</span><br><span class="line">	<span class="keyword">if</span> err := s.StartContext(ctx, *host, *port); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := s.Wait(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/*----------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> StartContext(ctx context.Context, host, port <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">    s.Infof(<span class="string">&quot;Fingerprint %s&quot;</span>, s.fingerprint)</span><br><span class="line">    <span class="keyword">if</span> s.users.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">       s.Infof(<span class="string">&quot;User authentication enabled&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> s.reverseProxy != <span class="literal">nil</span> &#123;</span><br><span class="line">       s.Infof(<span class="string">&quot;Reverse proxy enabled&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    l, err := s.listener(host, port)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    h := http.Handler(http.HandlerFunc(s.handleClientHandler))</span><br><span class="line">    <span class="keyword">if</span> s.Debug &#123;</span><br><span class="line">       o := requestlog.DefaultOptions</span><br><span class="line">       o.TrustProxy = <span class="literal">true</span></span><br><span class="line">       h = requestlog.WrapWith(h, o)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.httpServer.GoServe(ctx, l, h)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*----------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> Wait() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.httpServer.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这三段代码一起协同工作，用于启动和运行服务器以提供服务。以下是它们的详细解释：</p>
<p>第一段代码</p>
<ol>
<li><code>cos.InterruptContext()</code> 创建了一个用于处理中断信号（例如Ctrl+C）的上下文对象<code>ctx</code>，这样服务器可以在接收到中断信号时优雅地关闭。</li>
<li><code>s.StartContext(ctx, *host, *port)</code> 调用了<code>Server</code>结构体的<code>StartContext</code>方法，传递了上下文<code>ctx</code>、主机<code>host</code>和端口<code>port</code>作为参数，开始启动服务器。</li>
<li>如果启动服务器时出现错误，<code>log.Fatal(err)</code> 将记录错误信息并终止程序。</li>
</ol>
<p>第二段代码</p>
<ol>
<li>这个方法首先记录服务器的指纹信息和是否启用了用户认证和反向代理。</li>
<li>然后，它通过调用 <code>s.listener(host, port)</code> 创建监听器，该监听器绑定到指定的主机和端口。</li>
<li>接下来，它创建一个HTTP请求处理程序，将请求传递给<code>handleClientHandler</code>方法进行处理。如果服务器的调试模式已启用，将包装处理程序以记录请求和响应日志。</li>
<li>最后，它调用<code>s.httpServer.GoServe(ctx, l, h)</code>来启动HTTP服务器，使用传递的上下文<code>ctx</code>、监听器<code>l</code>和HTTP处理程序<code>h</code>。这将使服务器开始监听传入的连接，处理HTTP请求。</li>
</ol>
<p>第三段代码</p>
<ul>
<li><code>s.httpServer.Wait()</code> 是等待HTTP服务器关闭的操作。当HTTP服务器启动后，它将一直运行并监听传入连接，直到某个条件满足，例如通过调用服务器的关闭方法或发生错误。</li>
<li><code>s.httpServer.Wait()</code> 返回一个错误，表示等待过程中发生的任何错误。如果没有发生错误，它将返回<code>nil</code>，否则返回一个描述错误的错误对象。</li>
</ul>
<h3 id="GoServer函数"><a href="#GoServer函数" class="headerlink" title="GoServer函数"></a>GoServer函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HTTPServer)</span></span> GoServe(ctx context.Context, l net.Listener, handler http.Handler) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ctx == <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> errors.New(<span class="string">&quot;ctx must be set&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    h.waiterMux.Lock()</span><br><span class="line">    <span class="keyword">defer</span> h.waiterMux.Unlock()</span><br><span class="line">    h.Handler = handler</span><br><span class="line">    h.waiter, ctx = errgroup.WithContext(ctx)</span><br><span class="line">    h.waiter.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> h.Serve(l)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       &lt;-ctx.Done()</span><br><span class="line">       h.Close()</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说，这段代码的作用是启动HTTP服务器，同时处理HTTP请求，并使用上下文对象来支持启动和关闭操作的管理。它使用了 <code>errgroup</code> 来跟踪HTTP服务器的运行状态和错误。</p>
<ul>
<li><code>if ctx == nil &#123; return errors.New(&quot;ctx must be set&quot;) &#125;</code>：首先检查传入的上下文对象 <code>ctx</code> 是否为空，如果为空则返回一个错误，要求上下文对象必须设置。</li>
<li><code>h.waiterMux.Lock()</code> 和 <code>defer h.waiterMux.Unlock()</code>：这两行代码用于加锁和解锁 <code>h.waiterMux</code>，这是一个互斥锁，用于保护多个goroutine同时访问 <code>HTTPServer</code> 结构体的相关字段。</li>
<li><code>h.Handler = handler</code>：将传入的 <code>handler</code> 赋值给 <code>HTTPServer</code> 结构体的 <code>Handler</code> 字段，以指定处理HTTP请求的处理程序。</li>
<li><code>h.waiter, ctx = errgroup.WithContext(ctx)</code>：使用 <code>errgroup.WithContext</code> 函数创建一个错误组，并将传入的上下文对象 <code>ctx</code> 分配给 <code>h.waiter</code>，以便在启动HTTP服务器时跟踪错误。</li>
<li><code>h.waiter.Go(func() error &#123; return h.Serve(l) &#125;)</code>：使用 <code>errgroup</code> 的 <code>Go</code> 方法启动一个新的goroutine，该goroutine将调用 <code>HTTPServer</code> 结构体的 <code>Serve</code> 方法来启动HTTP服务器，并将 <code>l</code> 作为参数传递给 <code>Serve</code> 方法。</li>
<li><code>go func() &#123; &lt;-ctx.Done(); h.Close() &#125;()</code>：在新的goroutine中，启动一个匿名函数，该函数在 <code>ctx.Done()</code> 通道关闭时调用 <code>h.Close()</code> 方法来关闭HTTP服务器。</li>
<li><code>return nil</code>：最后，返回nil表示成功启动HTTP服务器。</li>
</ul>
<h3 id="handleClientHandler函数"><a href="#handleClientHandler函数" class="headerlink" title="handleClientHandler函数"></a>handleClientHandler函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handleClientHandler is the main http websocket handler for the chisel server</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> handlxeClientHandler(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    <span class="comment">//websockets upgrade AND has chisel prefix</span></span><br><span class="line">    upgrade := strings.ToLower(r.Header.Get(<span class="string">&quot;Upgrade&quot;</span>))</span><br><span class="line">    protocol := r.Header.Get(<span class="string">&quot;Sec-WebSocket-Protocol&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> upgrade == <span class="string">&quot;websocket&quot;</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> protocol == chshare.ProtocolVersion &#123;</span><br><span class="line">          s.handleWebsocket(w, r)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//print into server logs and silently fall-through</span></span><br><span class="line">       s.Infof(<span class="string">&quot;ignored client connection using protocol &#x27;%s&#x27;, expected &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">          protocol, chshare.ProtocolVersion)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//proxy target was provided</span></span><br><span class="line">    <span class="keyword">if</span> s.reverseProxy != <span class="literal">nil</span> &#123;</span><br><span class="line">       s.reverseProxy.ServeHTTP(w, r)</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//no proxy defined, provide access to health/version checks</span></span><br><span class="line">    <span class="keyword">switch</span> r.URL.Path &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;/health&quot;</span>:</span><br><span class="line">       w.Write([]<span class="type">byte</span>(<span class="string">&quot;OK\n&quot;</span>))</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;/version&quot;</span>:</span><br><span class="line">       w.Write([]<span class="type">byte</span>(chshare.BuildVersion))</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//missing :O</span></span><br><span class="line">    w.WriteHeader(<span class="number">404</span>)</span><br><span class="line">    w.Write([]<span class="type">byte</span>(<span class="string">&quot;Not found&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由注释可以看出<code>handleClientHandler</code>是<code>chisel</code>服务器的主要http websocket处理程序</p>
<p>这段代码的作用是根据 HTTP 请求的内容和头部信息来处理不同类型的请求，包括 WebSocket 连接、反向代理、健康检查和版本信息。</p>
<p>该处理程序负责处理传入的 HTTP 请求，并根据请求的不同内容执行不同的操作。</p>
<ul>
<li><code>func (s *Server) handleClientHandler(w http.ResponseWriter, r *http.Request)</code>：这是 <code>Server</code> 结构体中的一个方法，用于处理传入的 HTTP 请求。它接受两个参数，<code>w</code> 表示 HTTP 响应写入器，<code>r</code> 表示 HTTP 请求对象。</li>
<li><code>upgrade := strings.ToLower(r.Header.Get(&quot;Upgrade&quot;))</code> 和 <code>protocol := r.Header.Get(&quot;Sec-WebSocket-Protocol&quot;)</code>：这两行代码分别从 HTTP 请求头中获取 <code>Upgrade</code> 和 <code>Sec-WebSocket-Protocol</code> 字段的值，并将它们转换为小写。这些字段通常用于检测是否存在 WebSocket 连接和 WebSocket 协议版本。</li>
<li><code>if upgrade == &quot;websocket&quot; </code>：这是一个条件语句，用于检查是否存在 WebSocket 升级请求。</li>
<li><code>if protocol == chshare.ProtocolVersion</code>：这是另一个条件语句，用于检查 WebSocket 协议版本是否与预期的版本（<code>chshare.ProtocolVersion</code>）匹配。</li>
<li><code>s.handleWebsocket(w, r)</code>：如果升级请求是 WebSocket 且协议版本匹配，那么调用 <code>s.handleWebsocket</code> 方法来处理 WebSocket 连接。</li>
<li><code>s.Infof(&quot;ignored client connection using protocol &#39;%s&#39;, expected &#39;%s&#39;&quot;, protocol, chshare.ProtocolVersion)</code>：如果 WebSocket 协议版本不匹配，记录一条信息到服务器日志，指示客户端连接使用了不匹配的协议版本。</li>
<li><code>if s.reverseProxy != nil</code>：这是另一个条件语句，用于检查是否存在反向代理配置。</li>
<li><code>s.reverseProxy.ServeHTTP(w, r)</code>：如果存在反向代理配置，则将请求转发给反向代理处理。</li>
<li><code>switch r.URL.Path</code>：这是一个 <code>switch</code> 语句，用于根据请求的 URL 路径执行不同的操作。</li>
<li><code>case &quot;/health&quot;:</code>：如果请求的路径是 “&#x2F;health”，则返回 “OK\n” 表示健康检查通过。</li>
<li><code>case &quot;/version&quot;:</code>：如果请求的路径是 “&#x2F;version”，则返回 chisel 的版本号。</li>
<li><code>default:</code>：如果请求的路径不匹配任何已知路径，返回状态码 404 表示未找到资源，并返回 “Not found”。</li>
</ul>
<h3 id="handleWebsocket函数"><a href="#handleWebsocket函数" class="headerlink" title="handleWebsocket函数"></a>handleWebsocket函数</h3><p>在上面的handleClientHandler函数中对于websocket的数据包交给了这个函数进行处理，从函数的注释中也可以看出来。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//handleWebsocket负责处理websocket连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> handleWebsocket(w http.ResponseWriter, req *http.Request) &#123;</span><br><span class="line">    id := atomic.AddInt32(&amp;s.sessCount, <span class="number">1</span>)</span><br><span class="line">    l := s.Fork(<span class="string">&quot;session#%d&quot;</span>, id)</span><br><span class="line">    wsConn, err := upgrader.Upgrade(w, req, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       l.Debugf(<span class="string">&quot;Failed to upgrade (%s)&quot;</span>, err)</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    conn := cnet.NewWebSocketConn(wsConn)</span><br><span class="line">    <span class="comment">//在网络上执行SSH握手</span></span><br><span class="line">    l.Debugf(<span class="string">&quot;Handshaking with %s...&quot;</span>, req.RemoteAddr)</span><br><span class="line">    sshConn, chans, reqs, err := ssh.NewServerConn(conn, s.sshConfig)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       s.Debugf(<span class="string">&quot;Failed to handshake (%s)&quot;</span>, err)</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从session map 中提取用户</span></span><br><span class="line">    <span class="keyword">var</span> user *settings.User</span><br><span class="line">    <span class="keyword">if</span> s.users.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">       sid := <span class="type">string</span>(sshConn.SessionID())</span><br><span class="line">       u, ok := s.sessions.Get(sid)</span><br><span class="line">       <span class="keyword">if</span> !ok &#123;</span><br><span class="line">          <span class="built_in">panic</span>(<span class="string">&quot;bug in ssh auth handler&quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line">       user = u</span><br><span class="line">       s.sessions.Del(sid)</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//chisel 服务器握手（与客户端握手相反）</span></span><br><span class="line">	<span class="comment">//验证配置</span></span><br><span class="line">    l.Debugf(<span class="string">&quot;Verifying configuration&quot;</span>)</span><br><span class="line">    <span class="comment">//等待请求，超时</span></span><br><span class="line">    <span class="keyword">var</span> r *ssh.Request</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> r = &lt;-reqs:</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(settings.EnvDuration(<span class="string">&quot;CONFIG_TIMEOUT&quot;</span>, <span class="number">10</span>*time.Second)):</span><br><span class="line">       l.Debugf(<span class="string">&quot;Timeout waiting for configuration&quot;</span>)</span><br><span class="line">       sshConn.Close()</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    failed := <span class="function"><span class="keyword">func</span><span class="params">(err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">       l.Debugf(<span class="string">&quot;Failed: %s&quot;</span>, err)</span><br><span class="line">       r.Reply(<span class="literal">false</span>, []<span class="type">byte</span>(err.Error()))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> r.Type != <span class="string">&quot;config&quot;</span> &#123;</span><br><span class="line">       failed(s.Errorf(<span class="string">&quot;expecting config request&quot;</span>))</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    c, err := settings.DecodeConfig(r.Payload)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       failed(s.Errorf(<span class="string">&quot;invalid config&quot;</span>))</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果客户端和服务器版本不匹配，则打印</span></span><br><span class="line">    <span class="keyword">if</span> c.Version != chshare.BuildVersion &#123;</span><br><span class="line">       v := c.Version</span><br><span class="line">       <span class="keyword">if</span> v == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">          v = <span class="string">&quot;&lt;unknown&gt;&quot;</span></span><br><span class="line">       &#125;</span><br><span class="line">       l.Infof(<span class="string">&quot;Client version (%s) differs from server version (%s)&quot;</span>,</span><br><span class="line">          v, chshare.BuildVersion)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//验证远程</span></span><br><span class="line">    <span class="keyword">for</span> _, r := <span class="keyword">range</span> c.Remotes &#123;</span><br><span class="line">	<span class="comment">//如果提供了用户，请确保他们有</span></span><br><span class="line">	<span class="comment">//访问所需的遥控器</span></span><br><span class="line">       <span class="keyword">if</span> user != <span class="literal">nil</span> &#123;</span><br><span class="line">          addr := r.UserAddr()</span><br><span class="line">          <span class="keyword">if</span> !user.HasAccess(addr) &#123;</span><br><span class="line">             failed(s.Errorf(<span class="string">&quot;access to &#x27;%s&#x27; denied&quot;</span>, addr))</span><br><span class="line">             <span class="keyword">return</span></span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//确认允许反向隧道</span></span><br><span class="line">       <span class="keyword">if</span> r.Reverse &amp;&amp; !s.config.Reverse &#123;</span><br><span class="line">          l.Debugf(<span class="string">&quot;Denied reverse port forwarding request, please enable --reverse&quot;</span>)</span><br><span class="line">          failed(s.Errorf(<span class="string">&quot;Reverse port forwaring not enabled on server&quot;</span>))</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//确认反向通道可用</span></span><br><span class="line">       <span class="keyword">if</span> r.Reverse &amp;&amp; !r.CanListen() &#123;</span><br><span class="line">          failed(s.Errorf(<span class="string">&quot;Server cannot listen on %s&quot;</span>, r.String()))</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成功验证配置！</span></span><br><span class="line">    r.Reply(<span class="literal">true</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">//每个ssh连接的隧道</span></span><br><span class="line">    tunnel := tunnel.New(tunnel.Config&#123;</span><br><span class="line">       Logger:    l,</span><br><span class="line">       Inbound:   s.config.Reverse,</span><br><span class="line">       Outbound:  <span class="literal">true</span>, <span class="comment">//server always accepts outbound</span></span><br><span class="line">       Socks:     s.config.Socks5,</span><br><span class="line">       KeepAlive: s.config.KeepAlive,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//bind</span></span><br><span class="line">    eg, ctx := errgroup.WithContext(req.Context())</span><br><span class="line">    eg.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">       <span class="comment">//已连接，切换ssh连接以供隧道使用，并阻塞</span></span><br><span class="line">       <span class="keyword">return</span> tunnel.BindSSH(ctx, sshConn, reqs, chans)</span><br><span class="line">    &#125;)</span><br><span class="line">    eg.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">       <span class="comment">//已连接，设置反向遥控器？</span></span><br><span class="line">       serverInbound := c.Remotes.Reversed(<span class="literal">true</span>)</span><br><span class="line">       <span class="keyword">if</span> <span class="built_in">len</span>(serverInbound) == <span class="number">0</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//block</span></span><br><span class="line">       <span class="keyword">return</span> tunnel.BindRemotes(ctx, serverInbound)</span><br><span class="line">    &#125;)</span><br><span class="line">    err = eg.Wait()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; !strings.HasSuffix(err.Error(), <span class="string">&quot;EOF&quot;</span>) &#123;</span><br><span class="line">       l.Debugf(<span class="string">&quot;Closed connection (%s)&quot;</span>, err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       l.Debugf(<span class="string">&quot;Closed connection&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的主要作用是将 WebSocket 连接升级为 SSH 连接，并根据客户端请求的配置信息进行验证和隧道传输的设置，以便在客户端和服务器之间进行安全通信。</p>
<ul>
<li><code>func (s *Server) handleWebsocket(w http.ResponseWriter, req *http.Request)</code>：这是 <code>Server</code> 结构体中的一个方法，用于处理 WebSocket 连接。它接受两个参数，<code>w</code> 表示 HTTP 响应写入器，<code>req</code> 表示 HTTP 请求对象。</li>
<li><code>id := atomic.AddInt32(&amp;s.sessCount, 1)</code>：这一行代码用于为每个 WebSocket 连接生成一个唯一的会话标识符。会话计数器 <code>s.sessCount</code> 是一个原子计数器，每次调用 <code>AddInt32</code> 都会增加其值。</li>
<li><code>l := s.Fork(&quot;session#%d&quot;, id)</code>：这一行代码创建一个新的日志记录器（Logger），用于记录与当前 WebSocket 会话相关的日志。<code>Fork</code> 方法会根据提供的前缀和会话标识符创建一个新的日志记录器。</li>
<li><code>wsConn, err := upgrader.Upgrade(w, req, nil)</code>：这一行代码使用 <code>upgrader</code> 将 HTTP 连接升级为 WebSocket 连接，并返回一个 WebSocket 连接对象 <code>wsConn</code>。如果升级失败，将会返回一个错误。</li>
<li><code>conn := cnet.NewWebSocketConn(wsConn)</code>：这一行代码创建一个 <code>WebSocketConn</code> 对象，用于封装 WebSocket 连接。</li>
<li><code>l.Debugf(&quot;Handshaking with %s...&quot;, req.RemoteAddr)</code>：这一行代码记录一个调试级别的日志，表示正在进行 WebSocket 连接的握手。</li>
<li><code>sshConn, chans, reqs, err := ssh.NewServerConn(conn, s.sshConfig)</code>：这一行代码使用 SSH 包中的 <code>NewServerConn</code> 函数，将 WebSocket 连接升级为 SSH 连接，并返回 SSH 连接对象 <code>sshConn</code>、通道（channel）和请求（request）。</li>
<li><code>var user *settings.User</code>：这一行代码声明了一个变量 <code>user</code>，用于存储连接的用户信息。</li>
<li><code>if s.users.Len() &gt; 0</code>：这是一个条件语句，用于检查是否存在用户验证功能。</li>
<li><code>sid := string(sshConn.SessionID())</code>：这一行代码获取 SSH 连接的会话 ID，用于从会话映射中获取用户信息。</li>
<li><code>u, ok := s.sessions.Get(sid)</code>：这一行代码从会话映射中获取与会话 ID 相关联的用户信息。</li>
<li><code>user = u</code>：如果找到与会话 ID 相关联的用户信息，则将其分配给变量 <code>user</code>。</li>
<li><code>s.sessions.Del(sid)</code>：从会话映射中删除已经使用的会话信息。</li>
<li><code>select</code> 语句：这个 <code>select</code> 语句用于等待 SSH 客户端发送的请求，包括配置请求和其他类型的请求。</li>
<li><code>case r = &lt;-reqs:</code>：如果收到了一个请求，将其分配给变量 <code>r</code>。</li>
<li><code>case &lt;-time.After(settings.EnvDuration(&quot;CONFIG_TIMEOUT&quot;, 10*time.Second)):</code>：如果在指定的时间内未收到请求，将会触发超时。</li>
<li><code>failed := func(err error)</code>：这是一个匿名函数，用于记录连接失败的详细信息，并回复请求。</li>
<li><code>if r.Type != &quot;config&quot;</code>：这是一个条件语句，用于检查请求的类型是否为配置请求。</li>
<li><code>c, err := settings.DecodeConfig(r.Payload)</code>：这一行代码用于解码客户端发送的配置信息，并将其存储在变量 <code>c</code> 中。</li>
<li><code>if r.Type != &quot;config&quot;</code> 和 <code>c, err := settings.DecodeConfig(r.Payload)</code>：如果请求类型不是配置请求或配置信息无效，则触发失败函数，记录失败信息。</li>
<li><code>l.Infof(&quot;Client version (%s) differs from server version (%s)&quot;, v, chshare.BuildVersion)</code>：如果客户端版本与服务器版本不匹配，记录一条信息到服务器日志，指示版本不一致。</li>
<li><code>for _, r := range c.Remotes</code>：这是一个循环，用于迭代客户端发送的所有远程配置项。</li>
<li><code>addr := r.UserAddr()</code>：获取远程配置项的地址信息。</li>
<li><code>if !user.HasAccess(addr)</code>：如果存在用户验证并且用户没有访问权限，触发失败函数，拒绝访问。</li>
<li><code>if r.Reverse &amp;&amp; !s.config.Reverse</code>：如果客户端请求了反向端口转发，但服务器没有启用反向模式，则触发失败函数，拒绝请求。</li>
<li><code>if r.Reverse &amp;&amp; !r.CanListen()</code>：如果客户端请求的反向端口转发无法在服务器上监听，则触发失败函数，拒绝请求。</li>
<li><code>r.Reply(true, nil)</code>：如果所有验证都通过，回复客户端请求，表示验证成功。</li>
<li><code>tunnel := tunnel.New(tunnel.Config&#123;...&#125;)</code>：创建一个名为 <code>tunnel</code> 的隧道对象，用于处理 SSH 隧道的传输。</li>
<li><code>eg, ctx := errgroup.WithContext(req.Context())</code>：创建一个 <code>errgroup</code> 对象，用于管理多个并发任务，并传入请求的上下文。</li>
<li><code>eg.Go(func() error &#123; ... &#125;)</code>：使用 <code>errgroup</code> 启动一个协程，用于处理 SSH 连接的绑定和隧道的传输。</li>
<li><code>eg.Go(func() error &#123; ... &#125;)</code>：启动另一个协程，用于处理反向隧道的绑定（如果存在）。</li>
<li><code>err = eg.Wait()</code>：等待所有并发任务完成，如果出现错误（除了正常关闭连接时的 “EOF” 错误），则记录错误日志。</li>
</ul>
<h2 id="client函数"><a href="#client函数" class="headerlink" title="client函数"></a>client函数</h2><h3 id="解析命令行-2"><a href="#解析命令行-2" class="headerlink" title="解析命令行"></a>解析命令行</h3><p>首先解析传入的参数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">flags := flag.NewFlagSet(<span class="string">&quot;client&quot;</span>, flag.ContinueOnError)</span><br><span class="line">config := chclient.Config&#123;Headers: http.Header&#123;&#125;&#125;</span><br><span class="line">flags.StringVar(&amp;config.Fingerprint, <span class="string">&quot;fingerprint&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">flags.StringVar(&amp;config.Auth, <span class="string">&quot;auth&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">flags.DurationVar(&amp;config.KeepAlive, <span class="string">&quot;keepalive&quot;</span>, <span class="number">25</span>*time.Second, <span class="string">&quot;&quot;</span>)</span><br><span class="line">flags.IntVar(&amp;config.MaxRetryCount, <span class="string">&quot;max-retry-count&quot;</span>, <span class="number">-1</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">flags.DurationVar(&amp;config.MaxRetryInterval, <span class="string">&quot;max-retry-interval&quot;</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">flags.StringVar(&amp;config.Proxy, <span class="string">&quot;proxy&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">flags.StringVar(&amp;config.TLS.CA, <span class="string">&quot;tls-ca&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">flags.BoolVar(&amp;config.TLS.SkipVerify, <span class="string">&quot;tls-skip-verify&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">flags.StringVar(&amp;config.TLS.Cert, <span class="string">&quot;tls-cert&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">flags.StringVar(&amp;config.TLS.Key, <span class="string">&quot;tls-key&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">flags.Var(&amp;headerFlags&#123;config.Headers&#125;, <span class="string">&quot;header&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">hostname := flags.String(<span class="string">&quot;hostname&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">sni := flags.String(<span class="string">&quot;sni&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">pid := flags.Bool(<span class="string">&quot;pid&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">verbose := flags.Bool(<span class="string">&quot;v&quot;</span>, <span class="literal">false</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">flags.Usage = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Print(clientHelp)</span><br><span class="line">    os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">flags.Parse(args)</span><br><span class="line"><span class="comment">//pull out options, put back remaining args</span></span><br><span class="line">args = flags.Args()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args) &lt; <span class="number">2</span> &#123;</span><br><span class="line">    log.Fatalf(<span class="string">&quot;A server and least one remote is required&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">config.Server = args[<span class="number">0</span>]</span><br><span class="line">config.Remotes = args[<span class="number">1</span>:]</span><br><span class="line"><span class="comment">//default auth</span></span><br><span class="line"><span class="keyword">if</span> config.Auth == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    config.Auth = os.Getenv(<span class="string">&quot;AUTH&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//move hostname onto headers</span></span><br><span class="line"><span class="keyword">if</span> *hostname != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    config.Headers.Set(<span class="string">&quot;Host&quot;</span>, *hostname)</span><br><span class="line">    config.TLS.ServerName = *hostname</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> *sni != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    config.TLS.ServerName = *sni</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和server一样的，将结构体里面的一些变量与命令行参数进行连接，和本地的一些局部变量进行连接，最后通过<code>flags.parse(arfs)</code>进行解析，Config结构体定义了服务器的一些设置，但是结构体不一样，结构体如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Config represents a client configuration</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    Fingerprint      <span class="type">string</span></span><br><span class="line">    Auth             <span class="type">string</span></span><br><span class="line">    KeepAlive        time.Duration</span><br><span class="line">    MaxRetryCount    <span class="type">int</span></span><br><span class="line">    MaxRetryInterval time.Duration</span><br><span class="line">    Server           <span class="type">string</span></span><br><span class="line">    Proxy            <span class="type">string</span></span><br><span class="line">    Remotes          []<span class="type">string</span></span><br><span class="line">    Headers          http.Header</span><br><span class="line">    TLS              TLSConfig</span><br><span class="line">    DialContext      <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, network, addr <span class="type">string</span>)</span></span> (net.Conn, <span class="type">error</span>)</span><br><span class="line">    Verbose          <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动客户端初始化"><a href="#启动客户端初始化" class="headerlink" title="启动客户端初始化"></a>启动客户端初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">c, err := chclient.NewClient(&amp;config)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">c.Debug = *verbose</span><br><span class="line"><span class="keyword">if</span> *pid &#123;</span><br><span class="line">    generatePidFile()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> cos.GoStats()</span><br><span class="line">ctx := cos.InterruptContext()</span><br><span class="line"><span class="keyword">if</span> err := c.Start(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := c.Wait(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码用与启动一个client客户端的初始化，根据<code>Config</code>结构体去初始化客户端，然后运行Start函数</p>
<h3 id="NewClient函数"><a href="#NewClient函数" class="headerlink" title="NewClient函数"></a>NewClient函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewClient creates a new client instance</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewClient</span><span class="params">(c *Config)</span></span> (*Client, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">//apply default scheme</span></span><br><span class="line">    <span class="keyword">if</span> !strings.HasPrefix(c.Server, <span class="string">&quot;http&quot;</span>) &#123;</span><br><span class="line">       c.Server = <span class="string">&quot;http://&quot;</span> + c.Server</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> c.MaxRetryInterval &lt; time.Second &#123;</span><br><span class="line">       c.MaxRetryInterval = <span class="number">5</span> * time.Minute</span><br><span class="line">    &#125;</span><br><span class="line">    u, err := url.Parse(c.Server)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//swap to websockets scheme</span></span><br><span class="line">    u.Scheme = strings.Replace(u.Scheme, <span class="string">&quot;http&quot;</span>, <span class="string">&quot;ws&quot;</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">//apply default port</span></span><br><span class="line">    <span class="keyword">if</span> !regexp.MustCompile(<span class="string">`:\d+$`</span>).MatchString(u.Host) &#123;</span><br><span class="line">       <span class="keyword">if</span> u.Scheme == <span class="string">&quot;wss&quot;</span> &#123;</span><br><span class="line">          u.Host = u.Host + <span class="string">&quot;:443&quot;</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          u.Host = u.Host + <span class="string">&quot;:80&quot;</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    hasReverse := <span class="literal">false</span></span><br><span class="line">    hasSocks := <span class="literal">false</span></span><br><span class="line">    hasStdio := <span class="literal">false</span></span><br><span class="line">    client := &amp;Client&#123;</span><br><span class="line">       Logger: cio.NewLogger(<span class="string">&quot;client&quot;</span>),</span><br><span class="line">       config: c,</span><br><span class="line">       computed: settings.Config&#123;</span><br><span class="line">          Version: chshare.BuildVersion,</span><br><span class="line">       &#125;,</span><br><span class="line">       server:    u.String(),</span><br><span class="line">       tlsConfig: <span class="literal">nil</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//set default log level</span></span><br><span class="line">    client.Logger.Info = <span class="literal">true</span></span><br><span class="line">    <span class="comment">//configure tls</span></span><br><span class="line">    <span class="keyword">if</span> u.Scheme == <span class="string">&quot;wss&quot;</span> &#123;</span><br><span class="line">       tc := &amp;tls.Config&#123;&#125;</span><br><span class="line">       <span class="keyword">if</span> c.TLS.ServerName != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">          tc.ServerName = c.TLS.ServerName</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//certificate verification config</span></span><br><span class="line">       <span class="keyword">if</span> c.TLS.SkipVerify &#123;</span><br><span class="line">          client.Infof(<span class="string">&quot;TLS verification disabled&quot;</span>)</span><br><span class="line">          tc.InsecureSkipVerify = <span class="literal">true</span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> c.TLS.CA != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">          rootCAs := x509.NewCertPool()</span><br><span class="line">          <span class="keyword">if</span> b, err := ioutil.ReadFile(c.TLS.CA); err != <span class="literal">nil</span> &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;Failed to load file: %s&quot;</span>, c.TLS.CA)</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> ok := rootCAs.AppendCertsFromPEM(b); !ok &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;Failed to decode PEM: %s&quot;</span>, c.TLS.CA)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             client.Infof(<span class="string">&quot;TLS verification using CA %s&quot;</span>, c.TLS.CA)</span><br><span class="line">             tc.RootCAs = rootCAs</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//provide client cert and key pair for mtls</span></span><br><span class="line">       <span class="keyword">if</span> c.TLS.Cert != <span class="string">&quot;&quot;</span> &amp;&amp; c.TLS.Key != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">          c, err := tls.LoadX509KeyPair(c.TLS.Cert, c.TLS.Key)</span><br><span class="line">          <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;Error loading client cert and key pair: %v&quot;</span>, err)</span><br><span class="line">          &#125;</span><br><span class="line">          tc.Certificates = []tls.Certificate&#123;c&#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> c.TLS.Cert != <span class="string">&quot;&quot;</span> || c.TLS.Key != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;Please specify client BOTH cert and key&quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line">       client.tlsConfig = tc</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//validate remotes</span></span><br><span class="line">    <span class="keyword">for</span> _, s := <span class="keyword">range</span> c.Remotes &#123;</span><br><span class="line">       r, err := settings.DecodeRemote(s)</span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;Failed to decode remote &#x27;%s&#x27;: %s&quot;</span>, s, err)</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> r.Socks &#123;</span><br><span class="line">          hasSocks = <span class="literal">true</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> r.Reverse &#123;</span><br><span class="line">          hasReverse = <span class="literal">true</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> r.Stdio &#123;</span><br><span class="line">          <span class="keyword">if</span> hasStdio &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;Only one stdio is allowed&quot;</span>)</span><br><span class="line">          &#125;</span><br><span class="line">          hasStdio = <span class="literal">true</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//confirm non-reverse tunnel is available</span></span><br><span class="line">       <span class="keyword">if</span> !r.Reverse &amp;&amp; !r.Stdio &amp;&amp; !r.CanListen() &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;Client cannot listen on %s&quot;</span>, r.String())</span><br><span class="line">       &#125;</span><br><span class="line">       client.computed.Remotes = <span class="built_in">append</span>(client.computed.Remotes, r)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//outbound proxy</span></span><br><span class="line">    <span class="keyword">if</span> p := c.Proxy; p != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">       client.proxyURL, err = url.Parse(p)</span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;Invalid proxy URL (%s)&quot;</span>, err)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ssh auth and config</span></span><br><span class="line">    user, pass := settings.ParseAuth(c.Auth)</span><br><span class="line">    client.sshConfig = &amp;ssh.ClientConfig&#123;</span><br><span class="line">       User:            user,</span><br><span class="line">       Auth:            []ssh.AuthMethod&#123;ssh.Password(pass)&#125;,</span><br><span class="line">       ClientVersion:   <span class="string">&quot;SSH-&quot;</span> + chshare.ProtocolVersion + <span class="string">&quot;-client&quot;</span>,</span><br><span class="line">       HostKeyCallback: client.verifyServer,</span><br><span class="line">       Timeout:         settings.EnvDuration(<span class="string">&quot;SSH_TIMEOUT&quot;</span>, <span class="number">30</span>*time.Second),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//prepare client tunnel</span></span><br><span class="line">    client.tunnel = tunnel.New(tunnel.Config&#123;</span><br><span class="line">       Logger:    client.Logger,</span><br><span class="line">       Inbound:   <span class="literal">true</span>, <span class="comment">//client always accepts inbound</span></span><br><span class="line">       Outbound:  hasReverse,</span><br><span class="line">       Socks:     hasReverse &amp;&amp; hasSocks,</span><br><span class="line">       KeepAlive: client.config.KeepAlive,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> client, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终，函数返回一个新的<code>Client</code>实例作为结果，如果在创建过程中发生任何错误，将返回相应的错误信息。这个函数的主要作用是根据配置信息创建一个客户端实例，并进行一些配置参数的处理和验证。</p>
<ol>
<li><code>func NewClient(c *Config) (*Client, error) &#123; ... &#125;</code>：这是一个名为<code>NewClient</code>的函数，它接受一个<code>*Config</code>类型的参数<code>c</code>，并返回一个指向<code>Client</code>类型的指针和一个错误。这个函数用于创建一个新的客户端实例。</li>
<li><code>if !strings.HasPrefix(c.Server, &quot;http&quot;) &#123; ... &#125;</code>：这个条件语句检查配置中的服务器地址<code>c.Server</code>是否以”http”或”https”开头。如果不是的话，它会自动在地址前添加”http:&#x2F;&#x2F;“，以确保服务器地址的正确格式。</li>
<li><code>if c.MaxRetryInterval &lt; time.Second &#123; ... &#125;</code>：这个条件语句检查配置中的最大重试间隔<code>c.MaxRetryInterval</code>是否小于1秒。如果小于1秒，它将最大重试间隔设置为5分钟，以确保不会太频繁地进行重试。</li>
<li><code>u, err := url.Parse(c.Server)</code>：这一行代码使用Go标准库中的<code>url.Parse</code>函数来解析服务器地址<code>c.Server</code>，并将结果存储在变量<code>u</code>中。同时，它也会检查是否有解析错误，并将错误存储在变量<code>err</code>中。</li>
<li><code>u.Scheme = strings.Replace(u.Scheme, &quot;http&quot;, &quot;ws&quot;, 1)</code>：这一行代码将解析得到的URL的协议方案从”http”替换为”ws”，以便后续使用WebSocket连接。</li>
<li><code>if !regexp.MustCompile(</code>:\d+$<code>).MatchString(u.Host) &#123; ... &#125;</code>：这个条件语句检查解析得到的URL的主机部分是否包含端口号。如果不包含端口号，则根据协议方案添加默认端口号（80或443）。</li>
<li><code>hasReverse := false</code>、<code>hasSocks := false</code>、<code>hasStdio := false</code>：这些变量用于标记配置中是否包含反向隧道、Socks代理或标准输入&#x2F;输出通道。</li>
<li>创建一个<code>Client</code>结构体实例，并设置了各种字段，包括日志记录器、配置信息、服务器地址、TLS配置等。</li>
<li><code>for _, s := range c.Remotes &#123; ... &#125;</code>：这个循环迭代配置中的远程设置，对每个远程设置进行解码和验证，并根据其类型设置相关标志。</li>
<li><code>if p := c.Proxy; p != &quot;&quot; &#123; ... &#125;</code>：如果配置中指定了代理服务器地址，则解析代理URL并存储在<code>client.proxyURL</code>中。</li>
<li><code>user, pass := settings.ParseAuth(c.Auth)</code>：这一行代码解析配置中的身份验证信息，将用户名和密码提取出来，然后设置SSH客户端配置。</li>
<li>创建一个<code>Client</code>结构体实例的<code>tunnel</code>字段，用于处理隧道相关的配置。</li>
</ol>
<h3 id="start函数"><a href="#start函数" class="headerlink" title="start函数"></a>start函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start client and does not block</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> Start(ctx context.Context) <span class="type">error</span> &#123;</span><br><span class="line">    ctx, cancel := context.WithCancel(ctx)</span><br><span class="line">    c.stop = cancel</span><br><span class="line">    eg, ctx := errgroup.WithContext(ctx)</span><br><span class="line">    c.eg = eg</span><br><span class="line">    via := <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> c.proxyURL != <span class="literal">nil</span> &#123;</span><br><span class="line">       via = <span class="string">&quot; via &quot;</span> + c.proxyURL.String()</span><br><span class="line">    &#125;</span><br><span class="line">    c.Infof(<span class="string">&quot;Connecting to %s%s\n&quot;</span>, c.server, via)</span><br><span class="line">    <span class="comment">//connect to chisel server</span></span><br><span class="line">    eg.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> c.connectionLoop(ctx)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//listen sockets</span></span><br><span class="line">    eg.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">       clientInbound := c.computed.Remotes.Reversed(<span class="literal">false</span>)</span><br><span class="line">       <span class="keyword">if</span> <span class="built_in">len</span>(clientInbound) == <span class="number">0</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> c.tunnel.BindRemotes(ctx, clientInbound)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说，这段代码的作用是启动客户端并尝试连接到chisel服务器，同时监听本地的Socket连接（如果需要）。它使用goroutines来并发执行这些操作，不会阻塞当前线程，并可以在需要时取消。连接和监听操作的详细细节在匿名函数中执行，需要查看匿名函数内部的代码来了解具体的实现。</p>
<ol>
<li><code>func (c *Client) Start(ctx context.Context) error &#123; ... &#125;</code>：这是一个<code>Client</code>结构体的方法，用于启动客户端并连接到服务器，但不会阻塞当前线程。它接受一个<code>context.Context</code>类型的参数<code>ctx</code>，并返回一个错误。</li>
<li><code>ctx, cancel := context.WithCancel(ctx)</code>：这一行代码创建了一个新的上下文<code>ctx</code>，并返回一个<code>cancel</code>函数，用于在需要时取消这个上下文。</li>
<li><code>c.stop = cancel</code>：这一行代码将<code>cancel</code>函数赋值给<code>c</code>结构体的<code>stop</code>字段，以便稍后可以使用它来停止客户端。</li>
<li><code>eg, ctx := errgroup.WithContext(ctx)</code>：这一行代码使用<code>errgroup</code>包创建一个新的<code>errgroup.Group</code>实例，同时基于传入的上下文<code>ctx</code>创建一个新的上下文<code>ctx</code>。<code>errgroup</code>是一个用于处理一组goroutine的包，可以等待它们全部完成或任何一个失败。</li>
<li><code>via := &quot;&quot;</code>、<code>if c.proxyURL != nil &#123; ... &#125;</code>：这些行代码用于创建一个字符串<code>via</code>，其中包含代理服务器的信息，如果<code>c.proxyURL</code>不为<code>nil</code>，则将代理服务器的URL添加到<code>via</code>字符串中。</li>
<li><code>c.Infof(&quot;Connecting to %s%s\n&quot;, c.server, via)</code>：这一行代码使用<code>c</code>结构体的日志记录器打印连接服务器的信息，包括服务器地址和（如果存在）代理服务器信息。</li>
<li><code>eg.Go(func() error &#123; ... &#125;)</code>：这一行代码启动一个goroutine，其中包含一个匿名函数，用于执行连接到chisel服务器的操作。这个匿名函数返回连接操作的错误（如果有）。</li>
<li><code>eg.Go(func() error &#123; ... &#125;)</code>：这一行代码启动另一个goroutine，其中包含一个匿名函数，用于监听本地的Socket连接。它会检查客户端配置中是否有需要监听的Socket连接，如果有的话，会将这些连接绑定到chisel服务器上。如果没有需要监听的Socket连接，则不执行任何操作。</li>
<li><code>return nil</code>：最后，这个方法返回<code>nil</code>，表示启动过程不会返回错误。这意味着该方法会立即返回，而不会阻塞。</li>
</ol>
<h4 id="connectionLoop函数"><a href="#connectionLoop函数" class="headerlink" title="connectionLoop函数"></a>connectionLoop函数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> connectionLoop(ctx context.Context) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">//connection loop!</span></span><br><span class="line">    b := &amp;backoff.Backoff&#123;Max: c.config.MaxRetryInterval&#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">       connected, err := c.connectionOnce(ctx)</span><br><span class="line">       <span class="comment">//reset backoff after successful connections</span></span><br><span class="line">       <span class="keyword">if</span> connected &#123;</span><br><span class="line">          b.Reset()</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//connection error</span></span><br><span class="line">       attempt := <span class="type">int</span>(b.Attempt())</span><br><span class="line">       maxAttempt := c.config.MaxRetryCount</span><br><span class="line">       <span class="comment">//dont print closed-connection errors</span></span><br><span class="line">       <span class="keyword">if</span> strings.HasSuffix(err.Error(), <span class="string">&quot;use of closed network connection&quot;</span>) &#123;</span><br><span class="line">          err = io.EOF</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//show error message and attempt counts (excluding disconnects)</span></span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != io.EOF &#123;</span><br><span class="line">          msg := fmt.Sprintf(<span class="string">&quot;Connection error: %s&quot;</span>, err)</span><br><span class="line">          <span class="keyword">if</span> attempt &gt; <span class="number">0</span> &#123;</span><br><span class="line">             maxAttemptVal := fmt.Sprint(maxAttempt)</span><br><span class="line">             <span class="keyword">if</span> maxAttempt &lt; <span class="number">0</span> &#123;</span><br><span class="line">                maxAttemptVal = <span class="string">&quot;unlimited&quot;</span></span><br><span class="line">             &#125;</span><br><span class="line">             msg += fmt.Sprintf(<span class="string">&quot; (Attempt: %d/%s)&quot;</span>, attempt, maxAttemptVal)</span><br><span class="line">          &#125;</span><br><span class="line">          c.Infof(msg)</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//give up?</span></span><br><span class="line">       <span class="keyword">if</span> maxAttempt &gt;= <span class="number">0</span> &amp;&amp; attempt &gt;= maxAttempt &#123;</span><br><span class="line">          c.Infof(<span class="string">&quot;Give up&quot;</span>)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">       &#125;</span><br><span class="line">       d := b.Duration()</span><br><span class="line">       c.Infof(<span class="string">&quot;Retrying in %s...&quot;</span>, d)</span><br><span class="line">       <span class="keyword">select</span> &#123;</span><br><span class="line">       <span class="keyword">case</span> &lt;-cos.AfterSignal(d):</span><br><span class="line">          <span class="keyword">continue</span> <span class="comment">//retry now</span></span><br><span class="line">       <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">          c.Infof(<span class="string">&quot;Cancelled&quot;</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.Close()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是<code>Client</code>结构体中的一个方法，名为<code>connectionLoop</code>。它的主要作用是在一个循环中尝试连接到chisel服务器，如果连接失败，根据一定策略进行重试，同时记录连接尝试的次数和错误信息。</p>
<ol>
<li><code>b := &amp;backoff.Backoff&#123;Max: c.config.MaxRetryInterval&#125;</code>：创建一个<code>backoff.Backoff</code>的实例<code>b</code>，并设置最大的重试间隔为<code>c.config.MaxRetryInterval</code>，这是在客户端配置中定义的最大重试间隔。</li>
<li><code>for &#123; ... &#125;</code>：这是一个无限循环，表示不断尝试连接到chisel服务器。</li>
<li><code>connected, err := c.connectionOnce(ctx)</code>：调用<code>c.connectionOnce(ctx)</code>方法，该方法尝试一次连接到chisel服务器，并返回两个值，<code>connected</code>表示是否成功连接，<code>err</code>表示连接中出现的错误。</li>
<li><code>if connected &#123; ... &#125;</code>：如果成功连接到服务器，重置<code>backoff</code>实例<code>b</code>，以便在下一次连接尝试时使用最小的重试间隔。</li>
<li><code>attempt := int(b.Attempt())</code>：获取当前的连接尝试次数，这是<code>backoff</code>实例的属性。</li>
<li><code>maxAttempt := c.config.MaxRetryCount</code>：从客户端配置中获取最大重试次数。</li>
<li>如果<code>err</code>表示了关闭网络连接的错误（”use of closed network connection”），则将<code>err</code>重置为<code>io.EOF</code>，以避免打印此类错误。</li>
<li>如果<code>err</code>不为空且不是<code>io.EOF</code>，则打印连接错误消息，包括错误信息和连接尝试次数。</li>
<li>如果达到了最大连接尝试次数，并且<code>maxAttempt</code>大于等于0（表示有限次数的重试），则打印”Give up”消息，表示放弃连接，并退出循环。</li>
<li>计算下一次重试的等待时间<code>d</code>，使用<code>backoff</code>实例的<code>Duration</code>方法来获取。</li>
<li>打印”Retrying in %s…”消息，其中<code>%s</code>会被替换为等待时间<code>d</code>的字符串表示。</li>
<li>使用<code>select</code>语句等待以下两种事件中的任何一个发生：<ul>
<li>当前goroutine等待<code>d</code>时间后继续执行，表示进行下一次连接尝试。</li>
<li>当前上下文<code>ctx</code>被取消（可能是由于外部要求取消连接），则打印”Cancelled”消息，并返回<code>nil</code>表示取消连接尝试，然后退出循环。</li>
</ul>
</li>
<li>最后，如果退出循环，调用<code>c.Close()</code>方法来关闭客户端的连接，然后返回<code>nil</code>。</li>
</ol>
<h4 id="connectionOnce函数"><a href="#connectionOnce函数" class="headerlink" title="connectionOnce函数"></a>connectionOnce函数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// connectionOnce connects to the chisel server and blocks</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> connectionOnce(ctx context.Context) (connected <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">//already closed?</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>, errors.New(<span class="string">&quot;Cancelled&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">       <span class="comment">//still open</span></span><br><span class="line">    &#125;</span><br><span class="line">    ctx, cancel := context.WithCancel(ctx)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line">    <span class="comment">//prepare dialer</span></span><br><span class="line">    d := websocket.Dialer&#123;</span><br><span class="line">       HandshakeTimeout: settings.EnvDuration(<span class="string">&quot;WS_TIMEOUT&quot;</span>, <span class="number">45</span>*time.Second),</span><br><span class="line">       Subprotocols:     []<span class="type">string</span>&#123;chshare.ProtocolVersion&#125;,</span><br><span class="line">       TLSClientConfig:  c.tlsConfig,</span><br><span class="line">       ReadBufferSize:   settings.EnvInt(<span class="string">&quot;WS_BUFF_SIZE&quot;</span>, <span class="number">0</span>),</span><br><span class="line">       WriteBufferSize:  settings.EnvInt(<span class="string">&quot;WS_BUFF_SIZE&quot;</span>, <span class="number">0</span>),</span><br><span class="line">       NetDialContext:   c.config.DialContext,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//optional proxy</span></span><br><span class="line">    <span class="keyword">if</span> p := c.proxyURL; p != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> err := c.setProxy(p, &amp;d); err != <span class="literal">nil</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    wsConn, _, err := d.DialContext(ctx, c.server, c.config.Headers)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    conn := cnet.NewWebSocketConn(wsConn)</span><br><span class="line">    <span class="comment">// perform SSH handshake on net.Conn</span></span><br><span class="line">    c.Debugf(<span class="string">&quot;Handshaking...&quot;</span>)</span><br><span class="line">    sshConn, chans, reqs, err := ssh.NewClientConn(conn, <span class="string">&quot;&quot;</span>, c.sshConfig)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       e := err.Error()</span><br><span class="line">       <span class="keyword">if</span> strings.Contains(e, <span class="string">&quot;unable to authenticate&quot;</span>) &#123;</span><br><span class="line">          c.Infof(<span class="string">&quot;Authentication failed&quot;</span>)</span><br><span class="line">          c.Debugf(e)</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          c.Infof(e)</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> sshConn.Close()</span><br><span class="line">    <span class="comment">// chisel client handshake (reverse of server handshake)</span></span><br><span class="line">    <span class="comment">// send configuration</span></span><br><span class="line">    c.Debugf(<span class="string">&quot;Sending config&quot;</span>)</span><br><span class="line">    t0 := time.Now()</span><br><span class="line">    _, configerr, err := sshConn.SendRequest(</span><br><span class="line">       <span class="string">&quot;config&quot;</span>,</span><br><span class="line">       <span class="literal">true</span>,</span><br><span class="line">       settings.EncodeConfig(c.computed),</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       c.Infof(<span class="string">&quot;Config verification failed&quot;</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(configerr) &gt; <span class="number">0</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>, errors.New(<span class="type">string</span>(configerr))</span><br><span class="line">    &#125;</span><br><span class="line">    c.Infof(<span class="string">&quot;Connected (Latency %s)&quot;</span>, time.Since(t0))</span><br><span class="line">    <span class="comment">//connected, handover ssh connection for tunnel to use, and block</span></span><br><span class="line">    err = c.tunnel.BindSSH(ctx, sshConn, reqs, chans)</span><br><span class="line">    c.Infof(<span class="string">&quot;Disconnected&quot;</span>)</span><br><span class="line">    connected = time.Since(t0) &gt; <span class="number">5</span>*time.Second</span><br><span class="line">    <span class="keyword">return</span> connected, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说，这个方法的作用是进行一次连接到chisel服务器的尝试，包括WebSocket握手、SSH握手和与服务器的通信。如果连接成功，返回<code>true</code>和<code>nil</code>；如果连接失败，返回<code>false</code>和相应的错误信息。这个方法通常由<code>connectionLoop</code>方法调用，用于进行连接的具体实现。</p>
<h2 id="数据传输部分"><a href="#数据传输部分" class="headerlink" title="数据传输部分"></a>数据传输部分</h2><h3 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h3><h4 id="BindSSH函数"><a href="#BindSSH函数" class="headerlink" title="BindSSH函数"></a>BindSSH函数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BindSSH provides an active SSH for use for tunnelling</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tunnel)</span></span> BindSSH(ctx context.Context, c ssh.Conn, reqs &lt;-<span class="keyword">chan</span> *ssh.Request, chans &lt;-<span class="keyword">chan</span> ssh.NewChannel) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">//link ctx to ssh-conn</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       &lt;-ctx.Done()</span><br><span class="line">       <span class="keyword">if</span> c.Close() == <span class="literal">nil</span> &#123;</span><br><span class="line">          t.Debugf(<span class="string">&quot;SSH cancelled&quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line">       t.activatingConn.DoneAll()</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">//mark active and unblock</span></span><br><span class="line">    t.activeConnMut.Lock()</span><br><span class="line">    <span class="keyword">if</span> t.activeConn != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="built_in">panic</span>(<span class="string">&quot;double bind ssh&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    t.activeConn = c</span><br><span class="line">    t.activeConnMut.Unlock()</span><br><span class="line">    t.activatingConn.Done()</span><br><span class="line">    <span class="comment">//optional keepalive loop against this connection</span></span><br><span class="line">    <span class="keyword">if</span> t.Config.KeepAlive &gt; <span class="number">0</span> &#123;</span><br><span class="line">       <span class="keyword">go</span> t.keepAliveLoop(c)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//block until closed</span></span><br><span class="line">    <span class="keyword">go</span> t.handleSSHRequests(reqs)</span><br><span class="line">    <span class="keyword">go</span> t.handleSSHChannels(chans)</span><br><span class="line">    t.Debugf(<span class="string">&quot;SSH connected&quot;</span>)</span><br><span class="line">    err := c.Wait()</span><br><span class="line">    t.Debugf(<span class="string">&quot;SSH disconnected&quot;</span>)</span><br><span class="line">    <span class="comment">//mark inactive and block</span></span><br><span class="line">    t.activatingConn.Add(<span class="number">1</span>)</span><br><span class="line">    t.activeConnMut.Lock()</span><br><span class="line">    t.activeConn = <span class="literal">nil</span></span><br><span class="line">    t.activeConnMut.Unlock()</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说，这段代码的主要作用是为SSH隧道提供一个活跃的SSH连接，通过启动多个goroutines来处理SSH请求和通道，以及定期发送ping请求以保持SSH连接的活跃状态。连接关闭后，返回连接关闭时的错误。这个方法用于建立和维护SSH连接，以便进行数据传输。</p>
<ol>
<li><code>func (t *Tunnel) BindSSH(ctx context.Context, c ssh.Conn, reqs &lt;-chan *ssh.Request, chans &lt;-chan ssh.NewChannel) error &#123; ... &#125;</code>：这是一个<code>Tunnel</code>结构体的方法，用于为SSH隧道提供一个活跃的SSH连接，接受三个参数：上下文<code>ctx</code>、SSH连接<code>c</code>、SSH请求通道<code>reqs</code>和SSH新通道通道<code>chans</code>。</li>
<li><code>go func() &#123; ... &#125;()</code>：这是一个goroutine，用于将上下文<code>ctx</code>与SSH连接<code>c</code>关联起来。当上下文<code>ctx</code>被取消时，它会尝试关闭SSH连接<code>c</code>，并通知调试信息表明SSH连接被取消。同时，它调用<code>t.activatingConn.DoneAll()</code>来减少激活连接计数，表示连接已完成激活。</li>
<li><code>t.activeConnMut.Lock()</code>：获取<code>Tunnel</code>结构体中的<code>activeConnMut</code>互斥锁，用于保护对<code>activeConn</code>字段的并发访问。</li>
<li><code>if t.activeConn != nil &#123; ... &#125;</code>：检查<code>activeConn</code>字段是否已经被设置，如果已经设置，则抛出<code>panic</code>，表示不应该出现多次绑定SSH连接。</li>
<li><code>t.activeConn = c</code>：将SSH连接<code>c</code>设置为<code>activeConn</code>字段，表示当前SSH连接是活跃的。</li>
<li><code>t.activeConnMut.Unlock()</code>：释放<code>activeConnMut</code>互斥锁。</li>
<li><code>t.activatingConn.Done()</code>：通知<code>t.activatingConn</code>计数减少一个，表示SSH连接已完成激活。</li>
<li>如果配置中指定了保持活动的时间间隔<code>t.Config.KeepAlive &gt; 0</code>，则启动一个goroutine，调用<code>t.keepAliveLoop(c)</code>来定期发送ping请求以保持SSH连接的活跃状态。</li>
<li>启动两个goroutines，一个用于处理SSH请求通道<code>reqs</code>，另一个用于处理SSH新通道通道<code>chans</code>。这两个goroutines将负责处理SSH连接的请求和通道创建。</li>
<li>打印调试信息表示SSH连接已连接成功。</li>
<li><code>err := c.Wait()</code>：阻塞等待SSH连接的关闭，一旦连接关闭，将返回一个错误（如果有错误的话）。</li>
<li>打印调试信息表示SSH连接已断开。</li>
<li>重新增加<code>t.activatingConn</code>计数，表示SSH连接已完成激活。</li>
<li>获取<code>activeConnMut</code>互斥锁，将<code>activeConn</code>字段重置为<code>nil</code>，表示SSH连接不再活跃。</li>
<li>返回连接关闭时的错误（如果有错误的话）。</li>
</ol>
<h4 id="BindRemotes函数"><a href="#BindRemotes函数" class="headerlink" title="BindRemotes函数"></a>BindRemotes函数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BindRemotes converts the given remotes into proxies, and blocks</span></span><br><span class="line"><span class="comment">//until the caller cancels the context or there is a proxy error.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tunnel)</span></span> BindRemotes(ctx context.Context, remotes []*settings.Remote) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(remotes) == <span class="number">0</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> errors.New(<span class="string">&quot;no remotes&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !t.Inbound &#123;</span><br><span class="line">       <span class="keyword">return</span> errors.New(<span class="string">&quot;inbound connections blocked&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    proxies := <span class="built_in">make</span>([]*Proxy, <span class="built_in">len</span>(remotes))</span><br><span class="line">    <span class="keyword">for</span> i, remote := <span class="keyword">range</span> remotes &#123;</span><br><span class="line">       p, err := NewProxy(t.Logger, t, t.proxyCount, remote)</span><br><span class="line">       <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> err</span><br><span class="line">       &#125;</span><br><span class="line">       proxies[i] = p</span><br><span class="line">       t.proxyCount++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> handle tunnel close</span></span><br><span class="line">    eg, ctx := errgroup.WithContext(ctx)</span><br><span class="line">    <span class="keyword">for</span> _, proxy := <span class="keyword">range</span> proxies &#123;</span><br><span class="line">       p := proxy</span><br><span class="line">       eg.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> p.Run(ctx)</span><br><span class="line">       &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    t.Debugf(<span class="string">&quot;Bound proxies&quot;</span>)</span><br><span class="line">    err := eg.Wait()</span><br><span class="line">    t.Debugf(<span class="string">&quot;Unbound proxies&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说，这段代码的主要作用是将给定的远程配置转换为代理对象，并在后台运行这些代理对象，用于处理入站连接请求。它会等待所有代理运行结束，如果有任何代理出现错误，则返回其中一个代理的错误。这个方法用于管理和运行代理，以便允许入站连接请求并将它们转发到相应的远程目标。</p>
<ol>
<li><code>func (t *Tunnel) BindRemotes(ctx context.Context, remotes []*settings.Remote) error &#123; ... &#125;</code>：这是一个<code>Tunnel</code>结构体的方法，用于将给定的远程配置转换为代理并阻塞等待代理的运行，接受两个参数：上下文<code>ctx</code>和一个包含远程配置的切片<code>remotes</code>。</li>
<li><code>if len(remotes) == 0 &#123; ... &#125;</code>：检查<code>remotes</code>切片是否为空，如果没有配置远程代理，返回一个错误，表示没有远程配置可用。</li>
<li><code>if !t.Inbound &#123; ... &#125;</code>：检查<code>t.Inbound</code>字段，如果设置为<code>false</code>，表示入站连接被阻止，返回一个错误，表示无法创建入站连接。</li>
<li>创建一个长度等于<code>remotes</code>切片长度的切片<code>proxies</code>，用于存储代理对象。</li>
<li>使用循环遍历<code>remotes</code>切片，并为每个远程配置创建一个代理对象。这些代理对象会存储在<code>proxies</code>切片中。同时，会为每个代理对象分配一个唯一的标识<code>t.proxyCount</code>，用于标识代理。</li>
<li>使用<code>errgroup</code>包创建一个错误组<code>eg</code>，用于管理并发运行的代理对象。</li>
<li>针对每个代理对象，启动一个goroutine，调用<code>p.Run(ctx)</code>来运行代理。这些代理会在后台运行，并等待入站连接请求。</li>
<li>打印调试信息表示代理已经成功创建。</li>
<li>使用<code>eg.Wait()</code>等待所有代理对象的运行结束。如果任何一个代理对象返回错误，<code>eg.Wait()</code>会返回其中的一个错误。</li>
<li>打印调试信息表示代理已经全部解绑（即代理运行结束）。</li>
<li>返回代理运行结束后的错误（如果有错误的话）。</li>
</ol>
<h4 id="handleSSHChannels函数"><a href="#handleSSHChannels函数" class="headerlink" title="handleSSHChannels函数"></a>handleSSHChannels函数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tunnel)</span></span> handleSSHChannels(chans &lt;-<span class="keyword">chan</span> ssh.NewChannel) &#123;</span><br><span class="line">    <span class="keyword">for</span> ch := <span class="keyword">range</span> chans &#123;</span><br><span class="line">       <span class="keyword">go</span> t.handleSSHChannel(ch)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tunnel)</span></span> handleSSHChannel(ch ssh.NewChannel) &#123;</span><br><span class="line">    <span class="keyword">if</span> !t.Config.Outbound &#123;</span><br><span class="line">       t.Debugf(<span class="string">&quot;Denied outbound connection&quot;</span>)</span><br><span class="line">       ch.Reject(ssh.Prohibited, <span class="string">&quot;Denied outbound connection&quot;</span>)</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    remote := <span class="type">string</span>(ch.ExtraData())</span><br><span class="line">    <span class="comment">//extract protocol</span></span><br><span class="line">    hostPort, proto := settings.L4Proto(remote)</span><br><span class="line">    udp := proto == <span class="string">&quot;udp&quot;</span></span><br><span class="line">    socks := hostPort == <span class="string">&quot;socks&quot;</span></span><br><span class="line">    <span class="keyword">if</span> socks &amp;&amp; t.socksServer == <span class="literal">nil</span> &#123;</span><br><span class="line">       t.Debugf(<span class="string">&quot;Denied socks request, please enable socks&quot;</span>)</span><br><span class="line">       ch.Reject(ssh.Prohibited, <span class="string">&quot;SOCKS5 is not enabled&quot;</span>)</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    sshChan, reqs, err := ch.Accept()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       t.Debugf(<span class="string">&quot;Failed to accept stream: %s&quot;</span>, err)</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    stream := io.ReadWriteCloser(sshChan)</span><br><span class="line">    <span class="comment">//cnet.MeterRWC(t.Logger.Fork(&quot;sshchan&quot;), sshChan)</span></span><br><span class="line">    <span class="keyword">defer</span> stream.Close()</span><br><span class="line">    <span class="keyword">go</span> ssh.DiscardRequests(reqs)</span><br><span class="line">    l := t.Logger.Fork(<span class="string">&quot;conn#%d&quot;</span>, t.connStats.New())</span><br><span class="line">    <span class="comment">//ready to handle</span></span><br><span class="line">    t.connStats.Open()</span><br><span class="line">    l.Debugf(<span class="string">&quot;Open %s&quot;</span>, t.connStats.String())</span><br><span class="line">    <span class="keyword">if</span> socks &#123;</span><br><span class="line">       err = t.handleSocks(stream)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> udp &#123;</span><br><span class="line">       err = t.handleUDP(l, stream, hostPort)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       err = t.handleTCP(l, stream, hostPort)</span><br><span class="line">    &#125;</span><br><span class="line">    t.connStats.Close()</span><br><span class="line">    errmsg := <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; !strings.HasSuffix(err.Error(), <span class="string">&quot;EOF&quot;</span>) &#123;</span><br><span class="line">       errmsg = fmt.Sprintf(<span class="string">&quot; (error %s)&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    l.Debugf(<span class="string">&quot;Close %s%s&quot;</span>, t.connStats.String(), errmsg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说，这段代码的主要作用是根据SSH通道的类型和目标来将数据流量路由到相应的处理函数，并记录连接的信息以及处理过程中的调试信息。根据不同的协议类型，会调用不同的处理函数来处理数据流量，例如处理SOCKS代理请求、UDP流量或TCP流量。这有助于在SSH隧道中根据不同的通道类型进行灵活的数据传输。</p>
<ol>
<li><code>func (t *Tunnel) handleSSHChannel(ch ssh.NewChannel) &#123; ... &#125;</code>：这是一个<code>Tunnel</code>结构体的方法，用于处理SSH通道。</li>
<li><code>if !t.Config.Outbound &#123; ... &#125;</code>：检查<code>t.Config.Outbound</code>字段是否为<code>false</code>，如果是，则表示出站连接被禁止，打印调试信息并拒绝通道，返回<code>ssh.Prohibited</code>错误。</li>
<li><code>remote := string(ch.ExtraData())</code>：从通道的额外数据中获取远程地址信息，该额外数据通常包含了目标地址信息。</li>
<li>解析远程地址信息，提取出主机和端口以及协议类型（TCP或UDP），同时检查是否为SOCKS代理请求。<code>udp</code>表示协议类型为UDP，<code>socks</code>表示是SOCKS代理请求。</li>
<li>如果是SOCKS代理请求，并且SOCKS代理服务器未启用（<code>t.socksServer == nil</code>），则打印调试信息并拒绝通道，返回<code>ssh.Prohibited</code>错误。</li>
<li>通过<code>ch.Accept()</code>接受SSH通道，获取一个SSH通道和请求通道。如果无法接受通道，打印调试信息并返回。</li>
<li>创建一个<code>stream</code>，用于表示与SSH通道相关联的读写流。这个流将用于传输数据。</li>
<li>启动一个goroutine，通过<code>ssh.DiscardRequests(reqs)</code>来处理SSH请求通道，这里的请求通道主要是用于处理SSH的远程请求（例如端口转发）。</li>
<li>创建一个记录器（Logger）<code>l</code>，用于记录通道相关的调试信息。然后，通过<code>t.connStats.Open()</code>表示新建一个连接，打印连接信息。</li>
<li>根据通道的类型（SOCKS、UDP或TCP），分别调用相应的处理函数来处理数据流量。<ul>
<li>如果是SOCKS代理请求，调用<code>t.handleSocks(stream)</code>来处理SOCKS代理请求。</li>
<li>如果是UDP协议，调用<code>t.handleUDP(l, stream, hostPort)</code>来处理UDP流量。</li>
<li>如果是TCP协议，调用<code>t.handleTCP(l, stream, hostPort)</code>来处理TCP流量。</li>
</ul>
</li>
<li>在处理完数据流后，关闭连接计数（<code>t.connStats.Close()</code>），并在连接关闭时打印相应的调试信息，包括连接状态和错误信息（如果有错误）。</li>
</ol>
<h3 id="数据包转发"><a href="#数据包转发" class="headerlink" title="数据包转发"></a>数据包转发</h3><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tunnel)</span></span> handleTCP(l *cio.Logger, src io.ReadWriteCloser, hostPort <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">    dst, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, hostPort)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    s, r := cio.Pipe(src, dst)</span><br><span class="line">    l.Debugf(<span class="string">&quot;sent %s received %s&quot;</span>, sizestr.ToString(s), sizestr.ToString(r))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说，这段代码用于将TCP流量从SSH通道的数据流传输到目标主机和端口的TCP连接，并记录传输的数据量。这种方式可以用于在SSH隧道中转发TCP流量。、</p>
<ol>
<li><code>dst, err := net.Dial(&quot;tcp&quot;, hostPort)</code>：使用Go标准库的<code>net.Dial</code>函数建立一个TCP连接到指定的目标主机和端口（<code>hostPort</code>）。如果建立连接过程中出现错误，将返回错误信息。</li>
<li><code>s, r := cio.Pipe(src, dst)</code>：使用自定义的<code>cio.Pipe</code>函数，将源数据流（<code>src</code>，来自SSH通道）和目标TCP连接（<code>dst</code>）连接起来，创建一个数据管道，允许数据从源传输到目标。<code>s</code>和<code>r</code>分别代表已发送和已接收的数据量。</li>
<li><code>l.Debugf(&quot;sent %s received %s&quot;, sizestr.ToString(s), sizestr.ToString(r))</code>：使用记录器的<code>Debugf</code>方法，记录已发送和已接收的数据量，以便在调试时查看连接的数据流量。</li>
<li>最后，函数返回<code>nil</code>，表示成功处理TCP连接。</li>
</ol>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tunnel)</span></span> handleUDP(l *cio.Logger, rwc io.ReadWriteCloser, hostPort <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">    conns := &amp;udpConns&#123;</span><br><span class="line">       Logger: l,</span><br><span class="line">       m:      <span class="keyword">map</span>[<span class="type">string</span>]*udpConn&#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> conns.closeAll()</span><br><span class="line">    h := &amp;udpHandler&#123;</span><br><span class="line">       Logger:   l,</span><br><span class="line">       hostPort: hostPort,</span><br><span class="line">       udpChannel: &amp;udpChannel&#123;</span><br><span class="line">          r: gob.NewDecoder(rwc),</span><br><span class="line">          w: gob.NewEncoder(rwc),</span><br><span class="line">          c: rwc,</span><br><span class="line">       &#125;,</span><br><span class="line">       udpConns: conns,</span><br><span class="line">       maxMTU:   settings.EnvInt(<span class="string">&quot;UDP_MAX_SIZE&quot;</span>, <span class="number">9012</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    h.Debugf(<span class="string">&quot;UDP max size: %d bytes&quot;</span>, h.maxMTU)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">       p := udpPacket&#123;&#125;</span><br><span class="line">       <span class="keyword">if</span> err := h.handleWrite(&amp;p); err != <span class="literal">nil</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> err</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说，这段代码的主要作用是建立一个UDP数据包处理器，不断接收UDP数据包并将它们转发到目标主机和端口。这种方式可以用于在SSH隧道中转发UDP流量。UDP数据包的收发和转发是通过<code>udpHandler</code>和相关的结构体来管理的。</p>
<ol>
<li>创建一个<code>udpConns</code>结构体，用于管理UDP连接，包括记录每个UDP连接的状态。</li>
<li>在函数末尾使用<code>defer conns.closeAll()</code>确保在函数返回时关闭所有UDP连接。</li>
<li>创建一个<code>udpHandler</code>结构体，该结构体用于处理UDP数据包的收发和转发。它包括以下属性：<ul>
<li><code>Logger</code>：记录器，用于记录调试信息。</li>
<li><code>hostPort</code>：目标主机和端口，表示要将UDP数据包转发到的目标地址。</li>
<li><code>udpChannel</code>：UDP数据包的通信通道，包括读取器、写入器和通道本身。</li>
<li><code>udpConns</code>：管理UDP连接的结构体，用于跟踪每个连接的状态。</li>
<li><code>maxMTU</code>：UDP数据包的最大传输单元大小，可以通过环境变量配置，默认为9012字节。</li>
</ul>
</li>
<li>打印调试信息，显示UDP最大数据包大小。</li>
<li>进入一个无限循环，用于不断接收和处理UDP数据包。</li>
<li>在循环中，创建一个空的<code>udpPacket</code>结构体，用于表示UDP数据包。</li>
<li>调用<code>h.handleWrite(&amp;p)</code>来处理接收到的UDP数据包，其中<code>&amp;p</code>表示要处理的数据包的引用。</li>
<li>如果处理UDP数据包过程中出现错误，函数将返回错误信息。</li>
</ol>
<h4 id="SOCKS"><a href="#SOCKS" class="headerlink" title="SOCKS"></a>SOCKS</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tunnel)</span></span> handleSocks(src io.ReadWriteCloser) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.socksServer.ServeConn(cnet.NewRWCConn(src))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRWCConn</span><span class="params">(rwc io.ReadWriteCloser)</span></span> net.Conn &#123;</span><br><span class="line">	c := rwcConn&#123;</span><br><span class="line">		ReadWriteCloser: rwc,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说，这段代码的主要作用是处理 SOCKS 代理的连接请求，以及提供了一个用于创建网络连接的函数。它允许将<code>io.ReadWriteCloser</code>类型的对象转换为<code>net.Conn</code>类型的对象，以便在网络通信中使用。在 SOCKS 代理情境下，<code>handleSocks</code>函数将 SSH 通道的数据流转发给 SOCKS 代理服务器进行处理，而<code>NewRWCConn</code>函数用于创建符合<code>net.Conn</code>接口的对象。</p>
<ol>
<li><code>func (t *Tunnel) handleSocks(src io.ReadWriteCloser) error &#123; ... &#125;</code>：<ul>
<li>这个函数的主要作用是处理 SOCKS 代理的连接。</li>
<li>它接受一个实现了<code>io.ReadWriteCloser</code>接口的参数<code>src</code>，通常来自SSH通道的数据流。</li>
<li>函数通过调用<code>t.socksServer.ServeConn</code>将<code>src</code>转换为<code>net.Conn</code>类型并传递给 SOCKS 代理服务器来处理。</li>
<li>这个函数的实际作用是将 SOCKS 代理的连接请求转发给 SOCKS 代理服务器进行处理。</li>
</ul>
</li>
<li><code>func NewRWCConn(rwc io.ReadWriteCloser) net.Conn &#123; ... &#125;</code>：<ul>
<li>这个函数用于创建一个网络连接，返回一个<code>net.Conn</code>接口类型的对象。</li>
<li>它接受一个实现了<code>io.ReadWriteCloser</code>接口的参数<code>rwc</code>，通常是一个包含读写方法的对象，例如SSH通道的数据流。</li>
<li>在函数内部，它创建了一个<code>rwcConn</code>结构体，并将参数<code>rwc</code>赋值给<code>ReadWriteCloser</code>字段，然后返回这个<code>rwcConn</code>对象。</li>
<li><code>rwcConn</code>是一个自定义的类型，实现了<code>net.Conn</code>接口，用于包装<code>io.ReadWriteCloser</code>对象，以便它可以被当作<code>net.Conn</code>类型使用。</li>
</ul>
</li>
</ol>
<h2 id="wireshark抓包数据分析"><a href="#wireshark抓包数据分析" class="headerlink" title="wireshark抓包数据分析"></a>wireshark抓包数据分析</h2><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p><strong>1）</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsConn, err := upgrader.Upgrade(w, req, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>wsConn, err := upgrader.Upgrade(w, req, nil)</code>：这一行代码使用 <code>upgrader</code> 将 HTTP 连接升级为 WebSocket 连接，并返回一个 WebSocket 连接对象 <code>wsConn</code>。如果升级失败，将会返回一个错误。</p>
<p><img src="/picutre/Chisel-1.9.1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/image-20240116180058857.png" alt="image-20240116180058857"></p>
</li>
</ul>
<p><strong>2）</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sshConn, chans, reqs, err := ssh.NewServerConn(conn, s.sshConfig)</span><br></pre></td></tr></table></figure>

<p>server_hander.go里存在这段代码</p>
<ul>
<li><code>sshConn, chans, reqs, err := ssh.NewServerConn(conn, s.sshConfig)</code>：这一行代码使用 SSH 包中的 <code>NewServerConn</code> 函数，将 WebSocket 连接升级为 SSH 连接，并返回 SSH 连接对象 <code>sshConn</code>、通道（channel）和请求（request）。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.clientVersion, err = exchangeVersions(s.sshConn.conn, s.serverVersion)</span><br></pre></td></tr></table></figure>

<p>ssh&#x2F;server.go里面有这段代码，会将serverVersion传递给客户端</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.sshConfig = &amp;ssh.ServerConfig&#123;</span><br><span class="line">    ServerVersion:    <span class="string">&quot;SSH-&quot;</span> + chshare.ProtocolVersion + <span class="string">&quot;-server&quot;</span>,</span><br><span class="line">    PasswordCallback: server.authUser,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ProtocolVersion = <span class="string">&quot;chisel-v3&quot;</span></span><br></pre></td></tr></table></figure>

<p>main.go里面将version 定义为了<code>SSH-chisel-v3-server</code>，所以在传递的时候会和传递这个数据</p>
<p><img src="/picutre/Chisel-1.9.1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/image-20240116181038473.png" alt="image-20240116181038473"></p>
<p><strong>3）</strong></p>
<p>一段乱糟糟的数据，执行完</p>
<p><code>sshConn, chans, reqs, err := ssh.NewServerConn(conn, s.sshConfig)</code></p>
<p>这段函数后发送的，但是这个函数是ssh库的函数产生的，不具备特殊性</p>
<p><img src="/picutre/Chisel-1.9.1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/image-20240116181810929.png" alt="image-20240116181810929"></p>
<p>这段数据可以看出来是ssh的密钥交换算法的一部分，ssh key-exchange-algorithms，也就是ssh支持的算法什么的</p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p><strong>1）</strong></p>
<p><strong><img src="/picutre/Chisel-1.9.1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/image-20240117170453929.png" alt="image-20240117170453929"></strong></p>
<p>客户端发送一个websocket的升级请求，chisel的数据特征和普通的特征的区别是websocket的子协议存在<code>chisel</code>字段</p>
<p><strong>2)</strong></p>
<p><img src="/picutre/Chisel-1.9.1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/image-20240117170859973.png" alt="image-20240117170859973"></p>
<p>客户端发送的数据都是带有掩码异或的，但是服务端发送的数据不带有，所以从服务端的数据更能看出数据特征，这段数据便是经过掩码加密的，下图可以看到</p>
<p><img src="/picutre/Chisel-1.9.1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/image-20240117171059435.png" alt="image-20240117171059435"></p>
<p><strong>3）</strong></p>
<p><img src="/picutre/Chisel-1.9.1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/image-20240117171155296.png" alt="image-20240117171155296"></p>
<p>这段数据也是掩码加密的，实际数据如下</p>
<p><img src="/picutre/Chisel-1.9.1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/image-20240117171253956.png" alt="image-20240117171253956"></p>
<p><strong>4）</strong></p>
<p><img src="/picutre/Chisel-1.9.1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/image-20240117171340886.png" alt="image-20240117171340886"></p>
<p>这段数据经过掩码解密后的数据是乱码，很明显是经过加密的数据，不具备参考意义</p>
<p><strong>5）</strong></p>
<p><img src="/picutre/Chisel-1.9.1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/image-20240117171441167.png" alt="image-20240117171441167">后面的数据是在ssh登录的时候传递的数据，很明显无论是客户端还是服务端都不具备参考意义</p>
<h2 id="suricata规则"><a href="#suricata规则" class="headerlink" title="suricata规则"></a>suricata规则</h2><p>所以可以选择的特征如下</p>
<p><img src="/picutre/Chisel-1.9.1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/image-20240117175311322.png" alt="image-20240117175311322"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">C0KE</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/07/10/Chisel-1.9.1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/">http://example.com/2024/07/10/Chisel-1.9.1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Daily Study</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/sealed%E7%99%BD%E5%A4%A9.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/10/GO%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/" title="GO语言学习入门"><img class="cover" src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/sealed%E5%A4%9C%E6%99%9A.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">GO语言学习入门</div></div></a></div><div class="next-post pull-right"><a href="/2024/07/10/C#%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/" title="C#语言入门"><img class="cover" src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/Sci-Fi%20Energy%20Core.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C#语言入门</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/73c31ad1881611ebb6edd017c2d2eca2.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">C0KE</div><div class="author-info__description">C0KE's Study Diary</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">370</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">53</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/C0KE"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/C0KE" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://blog.csdn.net/weixin_62675330?spm=1000.2115.3001.5343" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="mailto:2269279877@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">人人都有选择如何活着的权力</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chisel-1-9-1%E9%80%86%E5%90%91%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">Chisel-1.9.1逆向分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%86%E5%90%91"><span class="toc-number">1.2.</span> <span class="toc-text">逆向</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%91%BD%E4%BB%A4%E8%A1%8C"><span class="toc-number">1.2.1.</span> <span class="toc-text">解析命令行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#server%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">server函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%91%BD%E4%BB%A4%E8%A1%8C-1"><span class="toc-number">1.3.1.</span> <span class="toc-text">解析命令行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%86%E9%92%A5%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E8%A7%A3%E6%9E%90%E5%85%B6%E4%BB%96%E9%80%89%E9%A1%B9"><span class="toc-number">1.3.2.</span> <span class="toc-text">密钥初始化和解析其他选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NewServer%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.3.</span> <span class="toc-text">NewServer函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEssh%E5%AF%86%E9%92%A5"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">配置ssh密钥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#user-password-callback%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">user-password callback函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StartContext%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.4.</span> <span class="toc-text">StartContext函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GoServer%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.5.</span> <span class="toc-text">GoServer函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#handleClientHandler%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.6.</span> <span class="toc-text">handleClientHandler函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#handleWebsocket%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.7.</span> <span class="toc-text">handleWebsocket函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#client%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">client函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%91%BD%E4%BB%A4%E8%A1%8C-2"><span class="toc-number">1.4.1.</span> <span class="toc-text">解析命令行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.4.2.</span> <span class="toc-text">启动客户端初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NewClient%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.3.</span> <span class="toc-text">NewClient函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#start%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.4.</span> <span class="toc-text">start函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#connectionLoop%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">connectionLoop函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#connectionOnce%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">connectionOnce函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E9%83%A8%E5%88%86"><span class="toc-number">1.5.</span> <span class="toc-text">数据传输部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.5.1.</span> <span class="toc-text">创建连接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BindSSH%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">BindSSH函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BindRemotes%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">BindRemotes函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#handleSSHChannels%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">handleSSHChannels函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8C%85%E8%BD%AC%E5%8F%91"><span class="toc-number">1.5.2.</span> <span class="toc-text">数据包转发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">TCP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">UDP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SOCKS"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">SOCKS</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wireshark%E6%8A%93%E5%8C%85%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90"><span class="toc-number">1.6.</span> <span class="toc-text">wireshark抓包数据分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.6.1.</span> <span class="toc-text">服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.6.2.</span> <span class="toc-text">客户端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#suricata%E8%A7%84%E5%88%99"><span class="toc-number">1.7.</span> <span class="toc-text">suricata规则</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/07/10/BP%20%E8%AF%AF%E5%B7%AE%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E6%B3%95%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%20-%20online/" title="BP 误差反向传播法数学知识 - online"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/sealed%E5%A4%9C%E6%99%9A.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BP 误差反向传播法数学知识 - online"/></a><div class="content"><a class="title" href="/2024/07/10/BP%20%E8%AF%AF%E5%B7%AE%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E6%B3%95%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%20-%20online/" title="BP 误差反向传播法数学知识 - online">BP 误差反向传播法数学知识 - online</a><time datetime="2024-07-10T07:41:47.045Z" title="发表于 2024-07-10 15:41:47">2024-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/10/%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/" title="线程，进程，协程的区别"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/sealed%E7%99%BD%E5%A4%A9.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线程，进程，协程的区别"/></a><div class="content"><a class="title" href="/2024/07/10/%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/" title="线程，进程，协程的区别">线程，进程，协程的区别</a><time datetime="2024-07-10T04:04:54.315Z" title="发表于 2024-07-10 12:04:54">2024-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/10/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/" title="进程间的通信"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/sealed%E5%A4%9C%E6%99%9A.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="进程间的通信"/></a><div class="content"><a class="title" href="/2024/07/10/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/" title="进程间的通信">进程间的通信</a><time datetime="2024-07-10T04:04:54.315Z" title="发表于 2024-07-10 12:04:54">2024-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/10/linux%E7%AE%A1%E9%81%93/" title="linux管道"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/sealed%E5%A4%9C%E6%99%9A.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="linux管道"/></a><div class="content"><a class="title" href="/2024/07/10/linux%E7%AE%A1%E9%81%93/" title="linux管道">linux管道</a><time datetime="2024-07-10T04:04:54.314Z" title="发表于 2024-07-10 12:04:54">2024-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/10/%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/" title="线程间的通信方式"><img src="https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/sealed%E7%99%BD%E5%A4%A9.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线程间的通信方式"/></a><div class="content"><a class="title" href="/2024/07/10/%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/" title="线程间的通信方式">线程间的通信方式</a><time datetime="2024-07-10T04:04:54.314Z" title="发表于 2024-07-10 12:04:54">2024-07-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://picgo-c0ke.oss-cn-hangzhou.aliyuncs.com/img/sealed%E7%99%BD%E5%A4%A9.png')"><div id="footer-wrap"><div class="copyright">&copy;2024 By C0KE</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="false" data-text="C0KE,LOVE,YOU" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>